============================= test session starts =============================
platform win32 -- Python 3.11.1, pytest-8.4.1, pluggy-1.6.0
rootdir: C:\final\backend
configfile: pytest.ini
plugins: anyio-4.10.0, asyncio-1.1.0
asyncio: mode=Mode.STRICT, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 261 items

tests\integration\test_api_integration.py FFF                            [  1%]
tests\integration\test_e2e_clinic.py .                                   [  1%]
tests\integration\test_e2e_doctor_visit.py EEEEEEEEEEEE                  [  6%]
tests\integration\test_e2e_migration_flow.py EE.EE                       [  8%]
tests\integration\test_e2e_patient_flow.py EEEEEEEEFF                    [ 11%]
tests\integration\test_e2e_payment_flow.py EE.EEEE.E                     [ 15%]
tests\integration\test_e2e_visit_flow.py EEEEEEE                         [ 18%]
tests\integration\test_migration_management_api.py E..EEEEEEEEEEEEEE.E   [ 25%]
tests\integration\test_online_queue_scenarios.py ......                  [ 27%]
tests\integration\test_queue_batch_api.py EEEEEEEEEEEEEEFE               [ 33%]
tests\integration\test_rbac_matrix.py ...................                [ 40%]
tests\integration\test_server_integration.py FFF                         [ 42%]
tests\integration\test_visit_confirmation_api.py E.EEFEEEEEEEEEEE        [ 48%]
tests\test_2fa_enforcement.py .....                                      [ 50%]
tests\test_api_responses.py ....................                         [ 57%]
tests\test_audit_logs.py FFFF...F.....                                   [ 62%]
tests\test_file_security.py FF.FF                                        [ 64%]
tests\test_payment_model.py .                                            [ 65%]
tests\test_security_middleware.py FFFF.FF....F                           [ 69%]
tests\test_settings.py ........                                          [ 72%]
tests\test_validators.py ................................                [ 85%]
tests\unit\test_confirmation_security.py E.EEE...EE..E..                 [ 90%]
tests\unit\test_migration_service.py ........EFE...F.....                [ 98%]
tests\unit\test_simple.py ....                                           [100%]

=================================== ERRORS ====================================
______ ERROR at setup of TestDoctorVisitFlow.test_doctor_can_view_queue _______

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC1081CA90>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
>           doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                first_name="╥хёЄ",
                last_name="─юъЄюЁют",
            )

tests\integration\test_e2e_doctor_visit.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.user.User object at 0x000001EC1224AD90>
kwargs = {'email': 'e2e_doctor@test.com', 'first_name': '╥хёЄ', 'hashed_password': '$argon2id$v=19$m=65536,t=3,p=4$a02pNcZYa+2ds3YOQUhpjQ$z9jgxVDdoqfz7Pbvyb7x8Wt+ezfykGUWS40SozvTBHo', 'is_active': True, ...}
cls_ = <class 'app.models.user.User'>, k = 'first_name'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'first_name' is an invalid keyword argument for User

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___ ERROR at setup of TestDoctorVisitFlow.test_doctor_can_call_next_patient ___

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC1223D010>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
>           doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                first_name="╥хёЄ",
                last_name="─юъЄюЁют",
            )

tests\integration\test_e2e_doctor_visit.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.user.User object at 0x000001EC12307F90>
kwargs = {'email': 'e2e_doctor@test.com', 'first_name': '╥хёЄ', 'hashed_password': '$argon2id$v=19$m=65536,t=3,p=4$SGntfc+Z815r7V1LCYHwvg$zsNYGthnADxts2lpKvmZG8w8X6UmLTYIMSZcQd4/a48', 'is_active': True, ...}
cls_ = <class 'app.models.user.User'>, k = 'first_name'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'first_name' is an invalid keyword argument for User

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
______ ERROR at setup of TestDoctorVisitFlow.test_doctor_can_start_visit ______

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC12078290>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
>           doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                first_name="╥хёЄ",
                last_name="─юъЄюЁют",
            )

tests\integration\test_e2e_doctor_visit.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.user.User object at 0x000001EC107E12D0>
kwargs = {'email': 'e2e_doctor@test.com', 'first_name': '╥хёЄ', 'hashed_password': '$argon2id$v=19$m=65536,t=3,p=4$8f5/zxljzBnD2HtPidGaEw$u3QRwXNsE1RekHos5a5KKipcHWGmTYcni3GCEgA704g', 'is_active': True, ...}
cls_ = <class 'app.models.user.User'>, k = 'first_name'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'first_name' is an invalid keyword argument for User

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______ ERROR at setup of TestDoctorVisitFlow.test_doctor_can_fill_emr ________

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC1081C710>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
>           doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                first_name="╥хёЄ",
                last_name="─юъЄюЁют",
            )

tests\integration\test_e2e_doctor_visit.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.user.User object at 0x000001EC12233310>
kwargs = {'email': 'e2e_doctor@test.com', 'first_name': '╥хёЄ', 'hashed_password': '$argon2id$v=19$m=65536,t=3,p=4$TSnlPAfAeO89x7j3PgcAYA$dO0Mh6KkcmFO7Gwbd8+TtK+BS/JtTvi792sxZn1j9uc', 'is_active': True, ...}
cls_ = <class 'app.models.user.User'>, k = 'first_name'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'first_name' is an invalid keyword argument for User

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___ ERROR at setup of TestDoctorVisitFlow.test_doctor_can_use_emr_template ____

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC121CA790>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
>           doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                first_name="╥хёЄ",
                last_name="─юъЄюЁют",
            )

tests\integration\test_e2e_doctor_visit.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.user.User object at 0x000001EC123D6010>
kwargs = {'email': 'e2e_doctor@test.com', 'first_name': '╥хёЄ', 'hashed_password': '$argon2id$v=19$m=65536,t=3,p=4$qHWOUaqVkhIixNhbS+kdAw$1MNai5fGbQsUrhm8fXljT6n2GebSl9pqiIS+BrczAIU', 'is_active': True, ...}
cls_ = <class 'app.models.user.User'>, k = 'first_name'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'first_name' is an invalid keyword argument for User

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestDoctorVisitFlow.test_doctor_can_add_diagnosis_with_ai_suggestion _

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC121F87D0>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
>           doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                first_name="╥хёЄ",
                last_name="─юъЄюЁют",
            )

tests\integration\test_e2e_doctor_visit.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.user.User object at 0x000001EC12087F10>
kwargs = {'email': 'e2e_doctor@test.com', 'first_name': '╥хёЄ', 'hashed_password': '$argon2id$v=19$m=65536,t=3,p=4$VsqZs3au1Zpz7l2rNQZgzA$9wh4vNJuO5RJqDgezFjHnyIHWIHrLCYkaH1n9ODafWM', 'is_active': True, ...}
cls_ = <class 'app.models.user.User'>, k = 'first_name'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'first_name' is an invalid keyword argument for User

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestDoctorVisitFlow.test_doctor_can_generate_prescription_pdf _

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC103FF990>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
>           doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                first_name="╥хёЄ",
                last_name="─юъЄюЁют",
            )

tests\integration\test_e2e_doctor_visit.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.user.User object at 0x000001EC122A4FD0>
kwargs = {'email': 'e2e_doctor@test.com', 'first_name': '╥хёЄ', 'hashed_password': '$argon2id$v=19$m=65536,t=3,p=4$izHGWOt9D2EsJURoDcEYIw$CoK0IOKS9GOXIZqGta2ngxSy0rGI9y9ZGqfeB/+buhs', 'is_active': True, ...}
cls_ = <class 'app.models.user.User'>, k = 'first_name'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'first_name' is an invalid keyword argument for User

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
____ ERROR at setup of TestDoctorVisitFlow.test_doctor_can_complete_visit _____

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC121EA8D0>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
>           doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                first_name="╥хёЄ",
                last_name="─юъЄюЁют",
            )

tests\integration\test_e2e_doctor_visit.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.user.User object at 0x000001EC107E19D0>
kwargs = {'email': 'e2e_doctor@test.com', 'first_name': '╥хёЄ', 'hashed_password': '$argon2id$v=19$m=65536,t=3,p=4$3Jtzztl7b43R2ntvTYnxXg$VUZlQI+gtO5ssSFJ4SHxsNRDIRqrTT1MbIo0MGWsj7E', 'is_active': True, ...}
cls_ = <class 'app.models.user.User'>, k = 'first_name'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'first_name' is an invalid keyword argument for User

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
__ ERROR at setup of TestDoctorQueueManagement.test_doctor_can_skip_patient ___

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC109FAF90>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
>           doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                first_name="╥хёЄ",
                last_name="─юъЄюЁют",
            )

tests\integration\test_e2e_doctor_visit.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.user.User object at 0x000001EC1080DC50>
kwargs = {'email': 'e2e_doctor@test.com', 'first_name': '╥хёЄ', 'hashed_password': '$argon2id$v=19$m=65536,t=3,p=4$FMI4R8j5nxOidG7N2Ztz7g$5ks48ElpDIaRsLckDwi8FLkTvZ5IH4HNaSHmZ9D5PAo', 'is_active': True, ...}
cls_ = <class 'app.models.user.User'>, k = 'first_name'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'first_name' is an invalid keyword argument for User

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestDoctorQueueManagement.test_doctor_can_get_patient_history _

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC12136C10>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
>           doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                first_name="╥хёЄ",
                last_name="─юъЄюЁют",
            )

tests\integration\test_e2e_doctor_visit.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.user.User object at 0x000001EC122A4450>
kwargs = {'email': 'e2e_doctor@test.com', 'first_name': '╥хёЄ', 'hashed_password': '$argon2id$v=19$m=65536,t=3,p=4$R2gNQcgZQ4iRcm5NSam1Ng$AuidbCrs2JLgm+juw8uN7fwxsULFx5wkHjzblHBc6xU', 'is_active': True, ...}
cls_ = <class 'app.models.user.User'>, k = 'first_name'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'first_name' is an invalid keyword argument for User

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestDoctorSecurity.test_doctor_cannot_access_admin_routes _

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC122A4D50>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
>           doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                first_name="╥хёЄ",
                last_name="─юъЄюЁют",
            )

tests\integration\test_e2e_doctor_visit.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.user.User object at 0x000001EC121CA690>
kwargs = {'email': 'e2e_doctor@test.com', 'first_name': '╥хёЄ', 'hashed_password': '$argon2id$v=19$m=65536,t=3,p=4$0RqDEIJQytm7V+odg5Ay5g$7ohSqIWFz2JU98tN6SKbBS7UTJhTxcmoORUlGxyBZ7c', 'is_active': True, ...}
cls_ = <class 'app.models.user.User'>, k = 'first_name'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'first_name' is an invalid keyword argument for User

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestDoctorSecurity.test_doctor_cannot_view_other_doctor_queue _

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC12050950>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
>           doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                first_name="╥хёЄ",
                last_name="─юъЄюЁют",
            )

tests\integration\test_e2e_doctor_visit.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.user.User object at 0x000001EC10A0FA10>
kwargs = {'email': 'e2e_doctor@test.com', 'first_name': '╥хёЄ', 'hashed_password': '$argon2id$v=19$m=65536,t=3,p=4$0VqL8V5rba3VmpPSmlNqzQ$iz1tRnbcoZmRdQ6bGW0aNCJCVZpgvW8oD6Z+QH0TuOg', 'is_active': True, ...}
cls_ = <class 'app.models.user.User'>, k = 'first_name'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'first_name' is an invalid keyword argument for User

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_____ ERROR at setup of TestE2EMigrationFlow.test_complete_migration_flow _____

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_complete_migration_flow>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC12297210>
admin_user = <app.models.user.User object at 0x000001EC10B57F90>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_ ERROR at setup of TestE2EMigrationFlow.test_migration_with_old_data_cleanup _

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_migration_with_old_data_cleanup>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC12233790>
admin_user = <app.models.user.User object at 0x000001EC120506D0>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_ ERROR at setup of TestE2EMigrationFlow.test_error_recovery_in_migration_flow _

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_error_recovery_in_migration_flow>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC12207ED0>
admin_user = <app.models.user.User object at 0x000001EC1240EF50>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_ ERROR at setup of TestE2EMigrationFlow.test_concurrent_migration_operations _

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_concurrent_migration_operations>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC12522C10>
admin_user = <app.models.user.User object at 0x000001EC123484D0>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
____ ERROR at setup of TestPatientFlow.test_patient_can_view_appointments _____

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC126D5650>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x000001EC123D6AD0>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestPatientFlow.test_patient_can_view_single_appointment __

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC122E5690>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x000001EC12655AD0>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestPatientFlow.test_patient_can_cancel_future_appointment _

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC1201D750>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x000001EC1240F1D0>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestPatientFlow.test_patient_cannot_cancel_soon_appointment _

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC12520610>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x000001EC1081E350>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
__ ERROR at setup of TestPatientFlow.test_patient_can_reschedule_appointment __

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC12523550>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x000001EC12657ED0>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___ ERROR at setup of TestPatientFlow.test_patient_can_get_available_slots ____

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC1240CA10>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x000001EC126D7D10>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______ ERROR at setup of TestPatientFlow.test_patient_can_view_results _______

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC1226E690>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x000001EC1240CCD0>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestPatientFlow.test_patient_cannot_view_others_appointments _

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC12657690>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x000001EC12654750>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______ ERROR at setup of TestPaymentFlow.test_create_payment_for_visit _______

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_create_payment_for_visit>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC1231F510>
admin_user = <app.models.user.User object at 0x000001EC12667010>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
______ ERROR at setup of TestPaymentFlow.test_get_pending_payments_list _______

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_get_pending_payments_list>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC12413210>
admin_user = <app.models.user.User object at 0x000001EC123288D0>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
__________ ERROR at setup of TestPaymentFlow.test_get_payment_status __________

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_get_payment_status>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC1232B290>
admin_user = <app.models.user.User object at 0x000001EC1270FFD0>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
______ ERROR at setup of TestPaymentFlow.test_payment_receipt_generation ______

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_payment_receipt_generation>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC121F87D0>
admin_user = <app.models.user.User object at 0x000001EC126D9710>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_______ ERROR at setup of TestPaymentProviders.test_click_payment_init ________

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_click_payment_init>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC1083C050>
admin_user = <app.models.user.User object at 0x000001EC1232DF10>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_______ ERROR at setup of TestPaymentProviders.test_payme_payment_init ________

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_payme_payment_init>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC1223D850>
admin_user = <app.models.user.User object at 0x000001EC126EA690>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_____ ERROR at setup of TestPaymentSecurity.test_invalid_amount_rejected ______

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_invalid_amount_rejected>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC1240DCD0>
admin_user = <app.models.user.User object at 0x000001EC12701510>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
______ ERROR at setup of TestE2EVisitFlow.test_complete_visit_flow_today ______

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_complete_visit_flow_today>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC12636A50>
admin_user = <app.models.user.User object at 0x000001EC126905D0>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
___ ERROR at setup of TestE2EVisitFlow.test_complete_visit_flow_future_date ___

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_complete_visit_flow_future_date>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC1204F0D0>
admin_user = <app.models.user.User object at 0x000001EC123C7650>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_______ ERROR at setup of TestE2EVisitFlow.test_morning_assignment_flow _______

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_morning_assignment_flow>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC1204D650>
admin_user = <app.models.user.User object at 0x000001EC1269BB10>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_____ ERROR at setup of TestE2EVisitFlow.test_registrar_confirmation_flow _____

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_registrar_confirmation_flow>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC1231F2D0>
admin_user = <app.models.user.User object at 0x000001EC126D8B50>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_ ERROR at setup of TestE2EVisitFlow.test_multiple_services_queue_assignment __

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_multiple_services_queue_assignment>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC12667590>
admin_user = <app.models.user.User object at 0x000001EC1226C350>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_______ ERROR at setup of TestE2EVisitFlow.test_error_handling_in_flow ________

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_error_handling_in_flow>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC123C6910>
admin_user = <app.models.user.User object at 0x000001EC126F21D0>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
______ ERROR at setup of TestE2EVisitFlow.test_notification_integration _______

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_notification_integration>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC12655510>
admin_user = <app.models.user.User object at 0x000001EC12296C10>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_ ERROR at setup of TestMigrationManagementAPI.test_check_migration_health_success _

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_check_migration_health_success>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC1264D550>
admin_user = <app.models.user.User object at 0x000001EC1268C150>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_ ERROR at setup of TestMigrationManagementAPI.test_check_data_integrity_success _

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_check_data_integrity_success>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC1267D6D0>
admin_user = <app.models.user.User object at 0x000001EC1268F750>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_ ERROR at setup of TestMigrationManagementAPI.test_check_data_integrity_with_data _

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_check_data_integrity_with_data>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC1269A2D0>
admin_user = <app.models.user.User object at 0x000001EC12348890>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_ ERROR at setup of TestMigrationManagementAPI.test_get_migration_stats_success _

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_get_migration_stats_success>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC12685FD0>
admin_user = <app.models.user.User object at 0x000001EC1233CE10>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_ ERROR at setup of TestMigrationManagementAPI.test_get_migration_stats_with_data _

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_get_migration_stats_with_data>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC12297AD0>
admin_user = <app.models.user.User object at 0x000001EC126E41D0>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_ ERROR at setup of TestMigrationManagementAPI.test_migrate_legacy_data_success _

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_migrate_legacy_data_success>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC1264D290>
admin_user = <app.models.user.User object at 0x000001EC12621150>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_ ERROR at setup of TestMigrationManagementAPI.test_backup_queue_data_success _

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_backup_queue_data_success>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC1226F490>
admin_user = <app.models.user.User object at 0x000001EC126D4990>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_ ERROR at setup of TestMigrationManagementAPI.test_backup_queue_data_specific_date _

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_backup_queue_data_specific_date>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC12705210>
admin_user = <app.models.user.User object at 0x000001EC127100D0>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_ ERROR at setup of TestMigrationManagementAPI.test_backup_queue_data_invalid_date _

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_backup_queue_data_invalid_date>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC123284D0>
admin_user = <app.models.user.User object at 0x000001EC126AD110>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_ ERROR at setup of TestMigrationManagementAPI.test_restore_queue_data_success _

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_restore_queue_data_success>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC1269BE50>
admin_user = <app.models.user.User object at 0x000001EC126860D0>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_ ERROR at setup of TestMigrationManagementAPI.test_restore_queue_data_file_not_found _

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_restore_queue_data_file_not_found>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC126D4450>
admin_user = <app.models.user.User object at 0x000001EC12681E10>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_ ERROR at setup of TestMigrationManagementAPI.test_cleanup_old_data_success __

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_cleanup_old_data_success>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC126D8150>
admin_user = <app.models.user.User object at 0x000001EC12691CD0>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_ ERROR at setup of TestMigrationManagementAPI.test_cleanup_old_data_with_old_data _

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_cleanup_old_data_with_old_data>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC1267C650>
admin_user = <app.models.user.User object at 0x000001EC1287AF90>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_ ERROR at setup of TestMigrationManagementAPI.test_cleanup_old_data_invalid_days _

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_cleanup_old_data_invalid_days>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC1264CA90>
admin_user = <app.models.user.User object at 0x000001EC126EA310>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_ ERROR at setup of TestMigrationManagementAPI.test_cleanup_old_data_max_days _

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_cleanup_old_data_max_days>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC1262D750>
admin_user = <app.models.user.User object at 0x000001EC126E4110>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
____ ERROR at setup of TestMigrationManagementAPI.test_api_error_handling _____

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_api_error_handling>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC12687DD0>
admin_user = <app.models.user.User object at 0x000001EC12881250>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_ ERROR at setup of TestQueueBatchAPI.test_create_single_queue_entry_success __

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC126C73D0>

    @pytest.fixture(scope="function")
    def test_services(db_session):
        """╤ючфрхЄ ЄхёЄют√х єёыєуш"""
        services = []
    
        # ╙ёыєур 1: ╩юэёєы№ЄрЎш  ърЁфшюыюур
>       service1 = Service(
            code="CARDIO_CONS",
            name="╩юэёєы№ЄрЎш  ърЁфшюыюур",
            price=150000.00,
            duration_minutes=30,
            is_active=True,
            requires_doctor=True,
            queue_tag="cardiology_common",
            is_consultation=True
        )

tests\integration\test_queue_batch_api.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.service.Service object at 0x000001EC12867950>
kwargs = {'code': 'CARDIO_CONS', 'duration_minutes': 30, 'is_active': True, 'is_consultation': True, ...}
cls_ = <class 'app.models.service.Service'>, k = 'is_active'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'is_active' is an invalid keyword argument for Service

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 9, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5IiwidXNlcm5hbWUiOiJ0ZXN0X3JlZ2lzdHJhciIsInJvbGUiOiJSZWdpc3RyYXIiLCJpc19hY3RpdmUiOnRydWUsImlzX3N1cGVydXNlciI6ZmFsc2UsImV4cCI6MTc2NTc0MzA5MSwidHlwZSI6ImFjY2VzcyJ9.tSPpsnNmMq7lgaDPSG7DEE6tLZ3Sf3Ii_keJPd_0cTs', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo5LCJqdGkiOiJhMzZlMzZiNS00MjUzLTRhMGYtYTk5Zi05Y2ViN2E5YmJkMmEiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzI5MX0.BaDpBhw47HWSexlwtCCaJ__dRx7e0JI2bbSqfH3e9ZU', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
_ ERROR at setup of TestQueueBatchAPI.test_create_multiple_queue_entries_different_specialists _

self = <sqlalchemy.engine.base.Connection object at 0x000001EC1233BD90>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC12655B90>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC128D2EC0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC12655B90>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC12207F10>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC128D2EC0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC12655B90>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 9, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5IiwidXNlcm5hbWUiOiJ0ZXN0X3JlZ2lzdHJhciIsInJvbGUiOiJSZWdpc3RyYXIiLCJpc19hY3RpdmUiOnRydWUsImlzX3N1cGVydXNlciI6ZmFsc2UsImV4cCI6MTc2NTc0MzA5MiwidHlwZSI6ImFjY2VzcyJ9.1iyzLRRlHHXSMFkKQVEb2dkYYc4S1AP0LK_hr1iQM7g', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo5LCJqdGkiOiIzZWM2MGFhNS1lODUxLTRmZjgtYTFkMS0wNTNlYjA0MTc2ZTEiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzI5Mn0.u_1OPJzSbU8l_Yg6lunCKFa-JfP6fDAct9oO8nQu4s0', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
________ ERROR at setup of TestQueueBatchAPI.test_source_preservation _________

self = <sqlalchemy.engine.base.Connection object at 0x000001EC12DBB1D0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC12ECEF50>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC131EE1C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC12ECEF50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC12F24C10>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC131EE1C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC12ECEF50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 9, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5IiwidXNlcm5hbWUiOiJ0ZXN0X3JlZ2lzdHJhciIsInJvbGUiOiJSZWdpc3RyYXIiLCJpc19hY3RpdmUiOnRydWUsImlzX3N1cGVydXNlciI6ZmFsc2UsImV4cCI6MTc2NTc0MzA5MiwidHlwZSI6ImFjY2VzcyJ9.1iyzLRRlHHXSMFkKQVEb2dkYYc4S1AP0LK_hr1iQM7g', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo5LCJqdGkiOiIzOGVlYzlmOC01Y2RiLTRjYmItOTgyNC02M2JjY2ZlZjYxM2IiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzI5Mn0.6hzFswEez2H4ZVK6_tqMLG1V83_LrgROGO2tBAMS5sI', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
________ ERROR at setup of TestQueueBatchAPI.test_duplicate_detection _________

self = <sqlalchemy.engine.base.Connection object at 0x000001EC123E6590>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC12665210>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC12F1A740>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC12665210>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC12216410>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC12F1A740>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC12665210>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 9, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5IiwidXNlcm5hbWUiOiJ0ZXN0X3JlZ2lzdHJhciIsInJvbGUiOiJSZWdpc3RyYXIiLCJpc19hY3RpdmUiOnRydWUsImlzX3N1cGVydXNlciI6ZmFsc2UsImV4cCI6MTc2NTc0MzA5MywidHlwZSI6ImFjY2VzcyJ9.dNreONTgRXeVQCpe_4uKNuo9TDl1EQrUXXwRiL0uZCU', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo5LCJqdGkiOiIxNzRkNWM5MC0xODQyLTQ0OWEtYWZkMC01MGI1YWJlMzlmZjkiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzI5M30.9J2x4sPiMhB1H1H6m69ei3iHOmfRIHyZv1MydeWHSik', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
___ ERROR at setup of TestQueueBatchAPI.test_service_grouping_by_specialist ___

self = <sqlalchemy.engine.base.Connection object at 0x000001EC12C97B10>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC128C4D50>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC1275E2C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC128C4D50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC12295B90>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC1275E2C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC128C4D50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 9, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5IiwidXNlcm5hbWUiOiJ0ZXN0X3JlZ2lzdHJhciIsInJvbGUiOiJSZWdpc3RyYXIiLCJpc19hY3RpdmUiOnRydWUsImlzX3N1cGVydXNlciI6ZmFsc2UsImV4cCI6MTc2NTc0MzA5NCwidHlwZSI6ImFjY2VzcyJ9.5hjypbmZM3SQqnNBAkjyZpsPucALlMLJV_gQ_jq-KxY', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo5LCJqdGkiOiJiY2VkM2YxYy0xZDU3LTRiNWMtOGQ5Yy0zZTg2M2I2MGE0NzQiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzI5NH0.awS5JgIxT5Q7ocwIaPtuwVU_SyKaw1TCtW8v8cCmzT4', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
______ ERROR at setup of TestQueueBatchAPI.test_auto_create_daily_queue _______

self = <sqlalchemy.engine.base.Connection object at 0x000001EC12622AD0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC12CEEBD0>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC131EFAC0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC12CEEBD0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC12297510>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC131EFAC0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC12CEEBD0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 9, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5IiwidXNlcm5hbWUiOiJ0ZXN0X3JlZ2lzdHJhciIsInJvbGUiOiJSZWdpc3RyYXIiLCJpc19hY3RpdmUiOnRydWUsImlzX3N1cGVydXNlciI6ZmFsc2UsImV4cCI6MTc2NTc0MzA5NCwidHlwZSI6ImFjY2VzcyJ9.5hjypbmZM3SQqnNBAkjyZpsPucALlMLJV_gQ_jq-KxY', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo5LCJqdGkiOiJiNTQ0NGQwZi0zMmFlLTRhYWItYTFhMS1kMjA4Zjc1OTg4OWMiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzI5NH0.zV4utfP6PmS2Y-INq-4sYl1tC0P4lAI1mzalzDazFrY', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
______ ERROR at setup of TestQueueBatchAPI.test_patient_not_found_error _______

self = <sqlalchemy.engine.base.Connection object at 0x000001EC126EA350>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC12320810>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC12D3BC40>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC12320810>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC1216F590>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC12D3BC40>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC12320810>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 9, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5IiwidXNlcm5hbWUiOiJ0ZXN0X3JlZ2lzdHJhciIsInJvbGUiOiJSZWdpc3RyYXIiLCJpc19hY3RpdmUiOnRydWUsImlzX3N1cGVydXNlciI6ZmFsc2UsImV4cCI6MTc2NTc0MzA5NSwidHlwZSI6ImFjY2VzcyJ9.6zd41jgvSKGkgAzy6hQouIoE9nQnt4LKeR_zA9d_Y1Y', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo5LCJqdGkiOiJiZTZhYTkzOC00OGIzLTQ4YzYtYjU0YS03YjM4NTNjMmZjYTEiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzI5NX0.70DxoyK9Tgz8a7HZ1t7-WBiPvfWqdX-AZgP02Czy7Jc', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
______ ERROR at setup of TestQueueBatchAPI.test_service_not_found_error _______

self = <sqlalchemy.engine.base.Connection object at 0x000001EC124A0F10>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC1270E350>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC128D0B40>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC1270E350>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC103FF990>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC128D0B40>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC1270E350>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 9, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5IiwidXNlcm5hbWUiOiJ0ZXN0X3JlZ2lzdHJhciIsInJvbGUiOiJSZWdpc3RyYXIiLCJpc19hY3RpdmUiOnRydWUsImlzX3N1cGVydXNlciI6ZmFsc2UsImV4cCI6MTc2NTc0MzA5NSwidHlwZSI6ImFjY2VzcyJ9.6zd41jgvSKGkgAzy6hQouIoE9nQnt4LKeR_zA9d_Y1Y', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo5LCJqdGkiOiIzN2JkODA2NS0zYmQ5LTRjNTgtOTYzMy0yMTI2N2M1ZmU4MjgiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzI5NX0.TqYqr0kGoe44e2J6UTRuY7dDFzPsjJ-GZnGpxCKIbGY', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
_____ ERROR at setup of TestQueueBatchAPI.test_specialist_not_found_error _____

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC1226DD50>

    @pytest.fixture(scope="function")
    def test_services(db_session):
        """╤ючфрхЄ ЄхёЄют√х єёыєуш"""
        services = []
    
        # ╙ёыєур 1: ╩юэёєы№ЄрЎш  ърЁфшюыюур
>       service1 = Service(
            code="CARDIO_CONS",
            name="╩юэёєы№ЄрЎш  ърЁфшюыюур",
            price=150000.00,
            duration_minutes=30,
            is_active=True,
            requires_doctor=True,
            queue_tag="cardiology_common",
            is_consultation=True
        )

tests\integration\test_queue_batch_api.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.service.Service object at 0x000001EC12ECC8D0>
kwargs = {'code': 'CARDIO_CONS', 'duration_minutes': 30, 'is_active': True, 'is_consultation': True, ...}
cls_ = <class 'app.models.service.Service'>, k = 'is_active'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'is_active' is an invalid keyword argument for Service

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 9, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5IiwidXNlcm5hbWUiOiJ0ZXN0X3JlZ2lzdHJhciIsInJvbGUiOiJSZWdpc3RyYXIiLCJpc19hY3RpdmUiOnRydWUsImlzX3N1cGVydXNlciI6ZmFsc2UsImV4cCI6MTc2NTc0MzA5NiwidHlwZSI6ImFjY2VzcyJ9.NUgQoIuVEK9UBFm9FulqFSaBR5e0N59fuLz_vWf-EaU', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo5LCJqdGkiOiI1M2RhOTk4Yy0wMjE2LTQyZTctYTkzOS03ZmQ2YzE3MzQxMDEiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzI5Nn0.6mJkKCLzBkDCnVKr9ZTYf7Cf9R3qZh-8s4Jr-js1oGE', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
________ ERROR at setup of TestQueueBatchAPI.test_invalid_source_error ________

self = <sqlalchemy.engine.base.Connection object at 0x000001EC12323290>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC1264F050>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC12A3D340>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC1264F050>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC1270DBD0>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC12A3D340>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC1264F050>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 9, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5IiwidXNlcm5hbWUiOiJ0ZXN0X3JlZ2lzdHJhciIsInJvbGUiOiJSZWdpc3RyYXIiLCJpc19hY3RpdmUiOnRydWUsImlzX3N1cGVydXNlciI6ZmFsc2UsImV4cCI6MTc2NTc0MzA5NiwidHlwZSI6ImFjY2VzcyJ9.NUgQoIuVEK9UBFm9FulqFSaBR5e0N59fuLz_vWf-EaU', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo5LCJqdGkiOiI0MDhjZWJjYy1hMTJkLTQ3NjItOWFmOC03OGQxNmM3NGQ5NWMiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzI5Nn0.dxlcwBmjqmtog1Jx5Y2l4N5w2QqfvkpZksuvNS1jUso', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
________ ERROR at setup of TestQueueBatchAPI.test_admin_access_allowed ________

fixturedef = <FixtureDef argname='auth_headers' scope='function' baseid='tests'>
request = <SubRequest 'auth_headers' for <Function test_admin_access_allowed>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

client = <starlette.testclient.TestClient object at 0x000001EC12840990>
admin_user = <app.models.user.User object at 0x000001EC12F8CAD0>

    @pytest.fixture(scope="function")
    def auth_headers(client, admin_user):
        """╤ючфрхЄ чруюыютъш ртЄюЁшчрЎшш фы  рфьшэшёЄЁрЄюЁр"""
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       assert response.status_code == 200
E       assert 401 == 200
E        +  where 401 = <Response [401 Unauthorized]>.status_code

tests\conftest.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
______ ERROR at setup of TestQueueBatchAPI.test_registrar_access_allowed ______

self = <sqlalchemy.engine.base.Connection object at 0x000001EC12699B90>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC125F4890>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC12D3B240>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC125F4890>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC1226EFD0>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC12D3B240>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC125F4890>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 9, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5IiwidXNlcm5hbWUiOiJ0ZXN0X3JlZ2lzdHJhciIsInJvbGUiOiJSZWdpc3RyYXIiLCJpc19hY3RpdmUiOnRydWUsImlzX3N1cGVydXNlciI6ZmFsc2UsImV4cCI6MTc2NTc0MzA5NywidHlwZSI6ImFjY2VzcyJ9.jpprQDlKKJ6XDSgBzKYjWaNkan0L_T8Fl3GgS0wVjyY', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo5LCJqdGkiOiI1ZGUyMTQ5OS02NmVmLTQyMDMtOTBhOS1mZDk3OTdlMGEyNjciLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzI5N30.1MSs3sxCk5uxP-d3AN_89pPjsaoS3xkt7cwtmkOgG34', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
________ ERROR at setup of TestQueueBatchAPI.test_doctor_access_denied ________

self = <sqlalchemy.engine.base.Connection object at 0x000001EC125C8DD0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC136D4110>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC12EAB140>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC136D4110>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC122E7210>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC12EAB140>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC136D4110>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_cardio
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_cardio', 'full_name': 'Test Cardiologist', 'email': 'cardio@test.com', 'role': 'cardio', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2NhcmRpbyIsInJvbGUiOiJjYXJkaW8iLCJpc19hY3RpdmUiOnRydWUsImlzX3N1cGVydXNlciI6ZmFsc2UsImV4cCI6MTc2NTc0MzA5NywidHlwZSI6ImFjY2VzcyJ9.qjb8DZPuAAMSkgdRREpx4tSzHFVIWzCWLEm2bEk7TCQ', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiJmYjkzOWI3MC01YTY4LTRhNGUtODRlNy1lMzUwZTRhNzMwMDgiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzI5N30.BRQXqRZvmknJUh0iDQm0QpEIx0XH5_g3szfydqvWB8g', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
___ ERROR at setup of TestQueueBatchAPI.test_unauthenticated_access_denied ____

self = <sqlalchemy.engine.base.Connection object at 0x000001EC12D10690>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC1224A590>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC1277D4C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC1224A590>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC123E6B90>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC1277D4C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC1224A590>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
________ ERROR at setup of TestQueueBatchAPI.test_fair_queue_numbering ________

self = <sqlalchemy.engine.base.Connection object at 0x000001EC12328F50>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC1317CA90>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC12D61BC0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC1317CA90>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001EC12D2B410>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001EC10A0FED0>
cursor = <sqlite3.Cursor object at 0x000001EC12D61BC0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001EC1317CA90>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 9, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5IiwidXNlcm5hbWUiOiJ0ZXN0X3JlZ2lzdHJhciIsInJvbGUiOiJSZWdpc3RyYXIiLCJpc19hY3RpdmUiOnRydWUsImlzX3N1cGVydXNlciI6ZmFsc2UsImV4cCI6MTc2NTc0MzA5OSwidHlwZSI6ImFjY2VzcyJ9.io3UqTaB36QD16UY6QvcfiaBLOpBEau3u3hoJ1ZT6j0', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo5LCJqdGkiOiI4Nzc4ZmM1Mi1lYmMzLTQwZmYtOWNhNi05MWYyNThkODdiMzciLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzI5OX0.-9GcEwInP8dw5RPtF-UtgoG3E0NVjKF7i98iigpDj7g', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
___ ERROR at setup of TestVisitConfirmationAPI.test_get_visit_info_success ____

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_get_visit_info_success>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC12E2FF90>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_get_visit_info_expired_token _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_get_visit_info_expired_token>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC12CEDAD0>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_telegram_success _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_telegram_success>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC1270CB10>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_telegram_wrong_channel _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_telegram_wrong_channel>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC126EA2D0>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
__ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_pwa_success __

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_pwa_success>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC1262CB50>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_pwa_phone_mismatch _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_pwa_phone_mismatch>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC12FDA910>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_registrar_success _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_registrar_success>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC12F8FC90>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_registrar_unauthorized _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_registrar_unauthorized>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC12E0B3D0>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_registrar_wrong_role _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_registrar_wrong_role>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC12FA79D0>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_creates_queue_entry_today _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_creates_queue_entry_today>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC126E57D0>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_no_queue_entry_future_date _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_no_queue_entry_future_date>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC12634D10>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_updates_status _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_updates_status>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC1270DC10>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_rate_limiting _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_rate_limiting>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC126AEDD0>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_security_validation _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_security_validation>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC122952D0>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestConfirmationSecurityService.test_validate_confirmation_request_valid_token _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_validate_confirmation_request_valid_token>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC12322D10>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestConfirmationSecurityService.test_validate_confirmation_request_expired_token _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_validate_confirmation_request_expired_token>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC12618090>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestConfirmationSecurityService.test_validate_confirmation_request_wrong_status _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_validate_confirmation_request_wrong_status>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC12D4D410>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestConfirmationSecurityService.test_validate_confirmation_request_suspicious_user_agent _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_validate_confirmation_request_suspicious_user_agent>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC1319AA90>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestConfirmationSecurityService.test_record_confirmation_attempt_success _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_record_confirmation_attempt_success>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC1259B550>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestConfirmationSecurityService.test_record_confirmation_attempt_failure _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_record_confirmation_attempt_failure>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC1261BA10>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestConfirmationSecurityService.test_logging_security_events _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_logging_security_events>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC12D0FA10>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestMigrationService.test_check_data_integrity_with_data __

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_check_data_integrity_with_data>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC1254B350>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___ ERROR at setup of TestMigrationService.test_backup_queue_data_with_data ___

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_backup_queue_data_with_data>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001EC126365D0>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
================================== FAILURES ===================================
___________________ TestAPIIntegration.test_health_endpoint ___________________

self = <urllib3.connection.HTTPConnection object at 0x000001EC10321D10>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
>           sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:85: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('127.0.0.1', 8000), timeout = 30, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address: tuple[str, int],
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        source_address: tuple[str, int] | None = None,
        socket_options: _TYPE_SOCKET_OPTIONS | None = None,
    ) -> socket.socket:
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            raise LocationParseError(f"'{host}', label empty or too long") from None
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not _DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:73: ConnectionRefusedError

The above exception was the direct cause of the following exception:

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001EC10321AD0>
method = 'GET', url = '/api/v1/health', body = None
headers = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate, br', 'Accept': '*/*', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=30, read=30, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None, preload_content = False
decode_content = False, response_kw = {}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v1/health', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(  # type: ignore[override]
        self,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | bool | int | None = None,
        redirect: bool = True,
        assert_same_host: bool = True,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        pool_timeout: int | None = None,
        release_conn: bool | None = None,
        chunked: bool = False,
        body_pos: _TYPE_BODY_POSITION | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        **response_kw: typing.Any,
    ) -> BaseHTTPResponse:
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method
           such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param bool preload_content:
            If True, the response's body will be preloaded into memory.
    
        :param bool decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of ``preload_content``
            which defaults to ``True``.
    
        :param bool chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
        """
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = preload_content
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = to_str(_encode_target(url))
        else:
            url = to_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()  # type: ignore[attr-defined]
            headers.update(self.proxy_headers)  # type: ignore[union-attr]
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]
    
            # Is this a closed/new connection that requires CONNECT tunnelling?
            if self.proxy is not None and http_tunnel_required and conn.is_closed:
                try:
                    self._prepare_proxy(conn)
                except (BaseSSLError, OSError, SocketTimeout) as e:
                    self._raise_timeout(
                        err=e, url=self.proxy.url, timeout_value=conn.timeout
                    )
                    raise
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Make the request on the HTTPConnection object
>           response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
                retries=retries,
                response_conn=response_conn,
                preload_content=preload_content,
                decode_content=decode_content,
                **response_kw,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:493: in _make_request
    conn.request(
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:494: in request
    self.endheaders()
C:\Program Files\Python311\Lib\http\client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
C:\Program Files\Python311\Lib\http\client.py:1037: in _send_output
    self.send(msg)
C:\Program Files\Python311\Lib\http\client.py:975: in send
    self.connect()
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:325: in connect
    self.sock = self._new_conn()
                ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <urllib3.connection.HTTPConnection object at 0x000001EC10321D10>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
            sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )
        except socket.gaierror as e:
            raise NameResolutionError(self.host, self, e) from e
        except SocketTimeout as e:
            raise ConnectTimeoutError(
                self,
                f"Connection to {self.host} timed out. (connect timeout={self.timeout})",
            ) from e
    
        except OSError as e:
>           raise NewConnectionError(
                self, f"Failed to establish a new connection: {e}"
            ) from e
E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x000001EC10321D10>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:213: NewConnectionError

The above exception was the direct cause of the following exception:

self = <requests.adapters.HTTPAdapter object at 0x000001EC103D2590>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
>           resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:486: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:841: in urlopen
    retries = retries.increment(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'GET', url = '/api/v1/health', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001EC10321D10>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001EC10321AD0>
_stacktrace = <traceback object at 0x000001EC10323240>

    def increment(
        self,
        method: str | None = None,
        url: str | None = None,
        response: BaseHTTPResponse | None = None,
        error: Exception | None = None,
        _pool: ConnectionPool | None = None,
        _stacktrace: TracebackType | None = None,
    ) -> Self:
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.BaseHTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or method is None or not self._is_method_retryable(method):
                raise reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            response_redirect_location = response.get_redirect_location()
            if response_redirect_location:
                redirect_location = response_redirect_location
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
            reason = error or ResponseError(cause)
>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/health (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001EC10321D10>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\urllib3\util\retry.py:519: MaxRetryError

During handling of the above exception, another exception occurred:

self = <test_api_integration.TestAPIIntegration object at 0x000001EC0BB6A590>

    def test_health_endpoint(self):
        """╥хёЄ health endpoint"""
>       response = requests.get(f"{self.base_url}/api/v1/health", timeout=self.timeout)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\integration\test_api_integration.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\requests\api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:703: in send
    r = adapter.send(request, **kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <requests.adapters.HTTPAdapter object at 0x000001EC103D2590>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/health (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001EC10321D10>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:519: ConnectionError
___________________ TestAPIIntegration.test_status_endpoint ___________________

self = <urllib3.connection.HTTPConnection object at 0x000001EC10B390D0>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
>           sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:85: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('127.0.0.1', 8000), timeout = 30, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address: tuple[str, int],
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        source_address: tuple[str, int] | None = None,
        socket_options: _TYPE_SOCKET_OPTIONS | None = None,
    ) -> socket.socket:
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            raise LocationParseError(f"'{host}', label empty or too long") from None
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not _DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:73: ConnectionRefusedError

The above exception was the direct cause of the following exception:

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001EC10B38C90>
method = 'GET', url = '/api/v1/status', body = None
headers = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate, br', 'Accept': '*/*', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=30, read=30, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None, preload_content = False
decode_content = False, response_kw = {}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v1/status', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(  # type: ignore[override]
        self,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | bool | int | None = None,
        redirect: bool = True,
        assert_same_host: bool = True,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        pool_timeout: int | None = None,
        release_conn: bool | None = None,
        chunked: bool = False,
        body_pos: _TYPE_BODY_POSITION | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        **response_kw: typing.Any,
    ) -> BaseHTTPResponse:
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method
           such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param bool preload_content:
            If True, the response's body will be preloaded into memory.
    
        :param bool decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of ``preload_content``
            which defaults to ``True``.
    
        :param bool chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
        """
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = preload_content
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = to_str(_encode_target(url))
        else:
            url = to_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()  # type: ignore[attr-defined]
            headers.update(self.proxy_headers)  # type: ignore[union-attr]
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]
    
            # Is this a closed/new connection that requires CONNECT tunnelling?
            if self.proxy is not None and http_tunnel_required and conn.is_closed:
                try:
                    self._prepare_proxy(conn)
                except (BaseSSLError, OSError, SocketTimeout) as e:
                    self._raise_timeout(
                        err=e, url=self.proxy.url, timeout_value=conn.timeout
                    )
                    raise
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Make the request on the HTTPConnection object
>           response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
                retries=retries,
                response_conn=response_conn,
                preload_content=preload_content,
                decode_content=decode_content,
                **response_kw,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:493: in _make_request
    conn.request(
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:494: in request
    self.endheaders()
C:\Program Files\Python311\Lib\http\client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
C:\Program Files\Python311\Lib\http\client.py:1037: in _send_output
    self.send(msg)
C:\Program Files\Python311\Lib\http\client.py:975: in send
    self.connect()
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:325: in connect
    self.sock = self._new_conn()
                ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <urllib3.connection.HTTPConnection object at 0x000001EC10B390D0>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
            sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )
        except socket.gaierror as e:
            raise NameResolutionError(self.host, self, e) from e
        except SocketTimeout as e:
            raise ConnectTimeoutError(
                self,
                f"Connection to {self.host} timed out. (connect timeout={self.timeout})",
            ) from e
    
        except OSError as e:
>           raise NewConnectionError(
                self, f"Failed to establish a new connection: {e}"
            ) from e
E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x000001EC10B390D0>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:213: NewConnectionError

The above exception was the direct cause of the following exception:

self = <requests.adapters.HTTPAdapter object at 0x000001EC10B3B950>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
>           resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:486: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:841: in urlopen
    retries = retries.increment(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'GET', url = '/api/v1/status', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001EC10B390D0>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001EC10B38C90>
_stacktrace = <traceback object at 0x000001EC10B39040>

    def increment(
        self,
        method: str | None = None,
        url: str | None = None,
        response: BaseHTTPResponse | None = None,
        error: Exception | None = None,
        _pool: ConnectionPool | None = None,
        _stacktrace: TracebackType | None = None,
    ) -> Self:
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.BaseHTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or method is None or not self._is_method_retryable(method):
                raise reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            response_redirect_location = response.get_redirect_location()
            if response_redirect_location:
                redirect_location = response_redirect_location
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
            reason = error or ResponseError(cause)
>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/status (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001EC10B390D0>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\urllib3\util\retry.py:519: MaxRetryError

During handling of the above exception, another exception occurred:

self = <test_api_integration.TestAPIIntegration object at 0x000001EC10250410>

    def test_status_endpoint(self):
        """╥хёЄ status endpoint"""
>       response = requests.get(f"{self.base_url}/api/v1/status", timeout=self.timeout)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\integration\test_api_integration.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\requests\api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:703: in send
    r = adapter.send(request, **kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <requests.adapters.HTTPAdapter object at 0x000001EC10B3B950>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/status (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001EC10B390D0>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:519: ConnectionError
_________________ TestAPIIntegration.test_api_responsiveness __________________

self = <urllib3.connection.HTTPConnection object at 0x000001EC1083D890>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
>           sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:85: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('127.0.0.1', 8000), timeout = 30, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address: tuple[str, int],
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        source_address: tuple[str, int] | None = None,
        socket_options: _TYPE_SOCKET_OPTIONS | None = None,
    ) -> socket.socket:
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            raise LocationParseError(f"'{host}', label empty or too long") from None
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not _DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:73: ConnectionRefusedError

The above exception was the direct cause of the following exception:

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001EC1083E150>
method = 'GET', url = '/api/v1/health', body = None
headers = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate, br', 'Accept': '*/*', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=30, read=30, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None, preload_content = False
decode_content = False, response_kw = {}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v1/health', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(  # type: ignore[override]
        self,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | bool | int | None = None,
        redirect: bool = True,
        assert_same_host: bool = True,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        pool_timeout: int | None = None,
        release_conn: bool | None = None,
        chunked: bool = False,
        body_pos: _TYPE_BODY_POSITION | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        **response_kw: typing.Any,
    ) -> BaseHTTPResponse:
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method
           such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param bool preload_content:
            If True, the response's body will be preloaded into memory.
    
        :param bool decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of ``preload_content``
            which defaults to ``True``.
    
        :param bool chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
        """
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = preload_content
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = to_str(_encode_target(url))
        else:
            url = to_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()  # type: ignore[attr-defined]
            headers.update(self.proxy_headers)  # type: ignore[union-attr]
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]
    
            # Is this a closed/new connection that requires CONNECT tunnelling?
            if self.proxy is not None and http_tunnel_required and conn.is_closed:
                try:
                    self._prepare_proxy(conn)
                except (BaseSSLError, OSError, SocketTimeout) as e:
                    self._raise_timeout(
                        err=e, url=self.proxy.url, timeout_value=conn.timeout
                    )
                    raise
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Make the request on the HTTPConnection object
>           response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
                retries=retries,
                response_conn=response_conn,
                preload_content=preload_content,
                decode_content=decode_content,
                **response_kw,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:493: in _make_request
    conn.request(
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:494: in request
    self.endheaders()
C:\Program Files\Python311\Lib\http\client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
C:\Program Files\Python311\Lib\http\client.py:1037: in _send_output
    self.send(msg)
C:\Program Files\Python311\Lib\http\client.py:975: in send
    self.connect()
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:325: in connect
    self.sock = self._new_conn()
                ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <urllib3.connection.HTTPConnection object at 0x000001EC1083D890>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
            sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )
        except socket.gaierror as e:
            raise NameResolutionError(self.host, self, e) from e
        except SocketTimeout as e:
            raise ConnectTimeoutError(
                self,
                f"Connection to {self.host} timed out. (connect timeout={self.timeout})",
            ) from e
    
        except OSError as e:
>           raise NewConnectionError(
                self, f"Failed to establish a new connection: {e}"
            ) from e
E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x000001EC1083D890>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:213: NewConnectionError

The above exception was the direct cause of the following exception:

self = <requests.adapters.HTTPAdapter object at 0x000001EC1083DB90>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
>           resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:486: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:841: in urlopen
    retries = retries.increment(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'GET', url = '/api/v1/health', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001EC1083D890>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001EC1083E150>
_stacktrace = <traceback object at 0x000001EC1083EEC0>

    def increment(
        self,
        method: str | None = None,
        url: str | None = None,
        response: BaseHTTPResponse | None = None,
        error: Exception | None = None,
        _pool: ConnectionPool | None = None,
        _stacktrace: TracebackType | None = None,
    ) -> Self:
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.BaseHTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or method is None or not self._is_method_retryable(method):
                raise reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            response_redirect_location = response.get_redirect_location()
            if response_redirect_location:
                redirect_location = response_redirect_location
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
            reason = error or ResponseError(cause)
>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/health (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001EC1083D890>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\urllib3\util\retry.py:519: MaxRetryError

During handling of the above exception, another exception occurred:

self = <test_api_integration.TestAPIIntegration object at 0x000001EC10250790>

    def test_api_responsiveness(self):
        """╥хёЄ юЄч√тўштюёЄш API"""
        start_time = time.time()
>       response = requests.get(f"{self.base_url}/api/v1/health", timeout=self.timeout)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\integration\test_api_integration.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\requests\api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:703: in send
    r = adapter.send(request, **kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <requests.adapters.HTTPAdapter object at 0x000001EC1083DB90>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/health (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001EC1083D890>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:519: ConnectionError
____________ TestPatientAuthFlow.test_unauthorized_access_rejected ____________

self = <test_e2e_patient_flow.TestPatientAuthFlow object at 0x000001EC10396050>
client = <starlette.testclient.TestClient object at 0x000001EC1226D710>

    def test_unauthorized_access_rejected(self, client: TestClient):
        """═хртЄюЁшчютрээ√щ фюёЄєя юЄъыюэ хЄё """
        response = client.get("/api/v1/patient/appointments")
>       assert response.status_code == 401
E       assert 404 == 401
E        +  where 404 = <Response [404 Not Found]>.status_code

tests\integration\test_e2e_patient_flow.py:312: AssertionError
_______________ TestPatientAuthFlow.test_invalid_token_rejected _______________

self = <test_e2e_patient_flow.TestPatientAuthFlow object at 0x000001EC10396950>
client = <starlette.testclient.TestClient object at 0x000001EC1083B510>

    def test_invalid_token_rejected(self, client: TestClient):
        """═хтрышфэ√щ Єюъхэ юЄъыюэ хЄё """
        response = client.get(
            "/api/v1/patient/appointments",
            headers={"Authorization": "Bearer invalid_token_here"},
        )
>       assert response.status_code in [401, 403]
E       assert 404 in [401, 403]
E        +  where 404 = <Response [404 Not Found]>.status_code

tests\integration\test_e2e_patient_flow.py:320: AssertionError
______________ TestQueueBatchAPI.test_empty_services_list_error _______________

self = <test_queue_batch_api.TestQueueBatchAPI object at 0x000001EC104DF790>
client = <starlette.testclient.TestClient object at 0x000001EC12865710>
registrar_auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5IiwidXNlcm5hbWUiOiJ0ZXN0X3JlZ2lzdHJhciIsInJ...sImlzX3N1cGVydXNlciI6ZmFsc2UsImV4cCI6MTc2NTc0MzA5OSwidHlwZSI6ImFjY2VzcyJ9.io3UqTaB36QD16UY6QvcfiaBLOpBEau3u3hoJ1ZT6j0'}
test_patient = <app.models.patient.Patient object at 0x000001EC12297010>

    def test_empty_services_list_error(
        self, client, registrar_auth_headers, test_patient
    ):
        """╥хёЄ: ╬°шсър - яєёЄющ ёяшёюъ єёыєу"""
        response = client.post(
            "/api/v1/registrar-integration/queue/entries/batch",
            headers=registrar_auth_headers,
            json={
                "patient_id": test_patient.id,
                "source": "desk",
                "services": []  # ╧єёЄющ ёяшёюъ
            }
        )
    
>       assert response.status_code == 422  # Validation error
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 200 == 422
E        +  where 200 = <Response [200 OK]>.status_code

tests\integration\test_queue_batch_api.py:539: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 9, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI5IiwidXNlcm5hbWUiOiJ0ZXN0X3JlZ2lzdHJhciIsInJvbGUiOiJSZWdpc3RyYXIiLCJpc19hY3RpdmUiOnRydWUsImlzX3N1cGVydXNlciI6ZmFsc2UsImV4cCI6MTc2NTc0MzA5OSwidHlwZSI6ImFjY2VzcyJ9.io3UqTaB36QD16UY6QvcfiaBLOpBEau3u3hoJ1ZT6j0', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo5LCJqdGkiOiIzNTNhOGEzZC00YzhlLTRkMmUtOGY1Yy1mZmQwZjYzNTlmMjMiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzI5OX0.J5tSKplYk5_Q1VZFMmOmqTeyGCd-kPa2A727Z-tlNz0', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
---------------------------- Captured stdout call -----------------------------
DEBUG: Checking roles for user 9 (test_registrar)
DEBUG: User Role: 'Registrar', Normalized: 'registrar'
DEBUG: Required Roles: ('Admin', 'Registrar'), Normalized: ['admin', 'registrar']
____________________________ test_health_endpoint _____________________________

self = <urllib3.connection.HTTPConnection object at 0x000001EC12687C50>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
>           sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:85: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('127.0.0.1', 8000), timeout = 30, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address: tuple[str, int],
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        source_address: tuple[str, int] | None = None,
        socket_options: _TYPE_SOCKET_OPTIONS | None = None,
    ) -> socket.socket:
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            raise LocationParseError(f"'{host}', label empty or too long") from None
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not _DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:73: ConnectionRefusedError

The above exception was the direct cause of the following exception:

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001EC12686290>
method = 'GET', url = '/api/v1/health', body = None
headers = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate, br', 'Accept': '*/*', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=30, read=30, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None, preload_content = False
decode_content = False, response_kw = {}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v1/health', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(  # type: ignore[override]
        self,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | bool | int | None = None,
        redirect: bool = True,
        assert_same_host: bool = True,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        pool_timeout: int | None = None,
        release_conn: bool | None = None,
        chunked: bool = False,
        body_pos: _TYPE_BODY_POSITION | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        **response_kw: typing.Any,
    ) -> BaseHTTPResponse:
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method
           such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param bool preload_content:
            If True, the response's body will be preloaded into memory.
    
        :param bool decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of ``preload_content``
            which defaults to ``True``.
    
        :param bool chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
        """
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = preload_content
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = to_str(_encode_target(url))
        else:
            url = to_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()  # type: ignore[attr-defined]
            headers.update(self.proxy_headers)  # type: ignore[union-attr]
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]
    
            # Is this a closed/new connection that requires CONNECT tunnelling?
            if self.proxy is not None and http_tunnel_required and conn.is_closed:
                try:
                    self._prepare_proxy(conn)
                except (BaseSSLError, OSError, SocketTimeout) as e:
                    self._raise_timeout(
                        err=e, url=self.proxy.url, timeout_value=conn.timeout
                    )
                    raise
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Make the request on the HTTPConnection object
>           response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
                retries=retries,
                response_conn=response_conn,
                preload_content=preload_content,
                decode_content=decode_content,
                **response_kw,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:493: in _make_request
    conn.request(
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:494: in request
    self.endheaders()
C:\Program Files\Python311\Lib\http\client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
C:\Program Files\Python311\Lib\http\client.py:1037: in _send_output
    self.send(msg)
C:\Program Files\Python311\Lib\http\client.py:975: in send
    self.connect()
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:325: in connect
    self.sock = self._new_conn()
                ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <urllib3.connection.HTTPConnection object at 0x000001EC12687C50>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
            sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )
        except socket.gaierror as e:
            raise NameResolutionError(self.host, self, e) from e
        except SocketTimeout as e:
            raise ConnectTimeoutError(
                self,
                f"Connection to {self.host} timed out. (connect timeout={self.timeout})",
            ) from e
    
        except OSError as e:
>           raise NewConnectionError(
                self, f"Failed to establish a new connection: {e}"
            ) from e
E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x000001EC12687C50>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:213: NewConnectionError

The above exception was the direct cause of the following exception:

self = <requests.adapters.HTTPAdapter object at 0x000001EC1252DB50>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
>           resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:486: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:841: in urlopen
    retries = retries.increment(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'GET', url = '/api/v1/health', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001EC12687C50>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001EC12686290>
_stacktrace = <traceback object at 0x000001EC12684D80>

    def increment(
        self,
        method: str | None = None,
        url: str | None = None,
        response: BaseHTTPResponse | None = None,
        error: Exception | None = None,
        _pool: ConnectionPool | None = None,
        _stacktrace: TracebackType | None = None,
    ) -> Self:
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.BaseHTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or method is None or not self._is_method_retryable(method):
                raise reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            response_redirect_location = response.get_redirect_location()
            if response_redirect_location:
                redirect_location = response_redirect_location
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
            reason = error or ResponseError(cause)
>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/health (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001EC12687C50>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\urllib3\util\retry.py:519: MaxRetryError

During handling of the above exception, another exception occurred:

    def test_health_endpoint():
        """╥хёЄ health endpoint"""
>       response = requests.get("http://127.0.0.1:8000/api/v1/health", timeout=30)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\integration\test_server_integration.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\requests\api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:703: in send
    r = adapter.send(request, **kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <requests.adapters.HTTPAdapter object at 0x000001EC1252DB50>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/health (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001EC12687C50>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:519: ConnectionError
____________________________ test_status_endpoint _____________________________

self = <urllib3.connection.HTTPConnection object at 0x000001EC12C77D90>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
>           sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:85: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('127.0.0.1', 8000), timeout = 30, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address: tuple[str, int],
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        source_address: tuple[str, int] | None = None,
        socket_options: _TYPE_SOCKET_OPTIONS | None = None,
    ) -> socket.socket:
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            raise LocationParseError(f"'{host}', label empty or too long") from None
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not _DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:73: ConnectionRefusedError

The above exception was the direct cause of the following exception:

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001EC12C77A90>
method = 'GET', url = '/api/v1/status', body = None
headers = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate, br', 'Accept': '*/*', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=30, read=30, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None, preload_content = False
decode_content = False, response_kw = {}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v1/status', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(  # type: ignore[override]
        self,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | bool | int | None = None,
        redirect: bool = True,
        assert_same_host: bool = True,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        pool_timeout: int | None = None,
        release_conn: bool | None = None,
        chunked: bool = False,
        body_pos: _TYPE_BODY_POSITION | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        **response_kw: typing.Any,
    ) -> BaseHTTPResponse:
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method
           such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param bool preload_content:
            If True, the response's body will be preloaded into memory.
    
        :param bool decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of ``preload_content``
            which defaults to ``True``.
    
        :param bool chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
        """
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = preload_content
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = to_str(_encode_target(url))
        else:
            url = to_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()  # type: ignore[attr-defined]
            headers.update(self.proxy_headers)  # type: ignore[union-attr]
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]
    
            # Is this a closed/new connection that requires CONNECT tunnelling?
            if self.proxy is not None and http_tunnel_required and conn.is_closed:
                try:
                    self._prepare_proxy(conn)
                except (BaseSSLError, OSError, SocketTimeout) as e:
                    self._raise_timeout(
                        err=e, url=self.proxy.url, timeout_value=conn.timeout
                    )
                    raise
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Make the request on the HTTPConnection object
>           response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
                retries=retries,
                response_conn=response_conn,
                preload_content=preload_content,
                decode_content=decode_content,
                **response_kw,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:493: in _make_request
    conn.request(
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:494: in request
    self.endheaders()
C:\Program Files\Python311\Lib\http\client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
C:\Program Files\Python311\Lib\http\client.py:1037: in _send_output
    self.send(msg)
C:\Program Files\Python311\Lib\http\client.py:975: in send
    self.connect()
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:325: in connect
    self.sock = self._new_conn()
                ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <urllib3.connection.HTTPConnection object at 0x000001EC12C77D90>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
            sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )
        except socket.gaierror as e:
            raise NameResolutionError(self.host, self, e) from e
        except SocketTimeout as e:
            raise ConnectTimeoutError(
                self,
                f"Connection to {self.host} timed out. (connect timeout={self.timeout})",
            ) from e
    
        except OSError as e:
>           raise NewConnectionError(
                self, f"Failed to establish a new connection: {e}"
            ) from e
E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x000001EC12C77D90>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:213: NewConnectionError

The above exception was the direct cause of the following exception:

self = <requests.adapters.HTTPAdapter object at 0x000001EC12C767D0>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
>           resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:486: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:841: in urlopen
    retries = retries.increment(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'GET', url = '/api/v1/status', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001EC12C77D90>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001EC12C77A90>
_stacktrace = <traceback object at 0x000001EC12C77CC0>

    def increment(
        self,
        method: str | None = None,
        url: str | None = None,
        response: BaseHTTPResponse | None = None,
        error: Exception | None = None,
        _pool: ConnectionPool | None = None,
        _stacktrace: TracebackType | None = None,
    ) -> Self:
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.BaseHTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or method is None or not self._is_method_retryable(method):
                raise reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            response_redirect_location = response.get_redirect_location()
            if response_redirect_location:
                redirect_location = response_redirect_location
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
            reason = error or ResponseError(cause)
>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/status (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001EC12C77D90>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\urllib3\util\retry.py:519: MaxRetryError

During handling of the above exception, another exception occurred:

    def test_status_endpoint():
        """╥хёЄ status endpoint"""
>       response = requests.get("http://127.0.0.1:8000/api/v1/status", timeout=30)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\integration\test_server_integration.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\requests\api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:703: in send
    r = adapter.send(request, **kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <requests.adapters.HTTPAdapter object at 0x000001EC12C767D0>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/status (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001EC12C77D90>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:519: ConnectionError
______________________________ test_openapi_docs ______________________________

self = <urllib3.connection.HTTPConnection object at 0x000001EC12D4CE10>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
>           sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:85: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('127.0.0.1', 8000), timeout = 30, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address: tuple[str, int],
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        source_address: tuple[str, int] | None = None,
        socket_options: _TYPE_SOCKET_OPTIONS | None = None,
    ) -> socket.socket:
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            raise LocationParseError(f"'{host}', label empty or too long") from None
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not _DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:73: ConnectionRefusedError

The above exception was the direct cause of the following exception:

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001EC12D4EF10>
method = 'GET', url = '/docs', body = None
headers = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate, br', 'Accept': '*/*', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=30, read=30, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None, preload_content = False
decode_content = False, response_kw = {}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/docs', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(  # type: ignore[override]
        self,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | bool | int | None = None,
        redirect: bool = True,
        assert_same_host: bool = True,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        pool_timeout: int | None = None,
        release_conn: bool | None = None,
        chunked: bool = False,
        body_pos: _TYPE_BODY_POSITION | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        **response_kw: typing.Any,
    ) -> BaseHTTPResponse:
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method
           such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param bool preload_content:
            If True, the response's body will be preloaded into memory.
    
        :param bool decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of ``preload_content``
            which defaults to ``True``.
    
        :param bool chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
        """
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = preload_content
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = to_str(_encode_target(url))
        else:
            url = to_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()  # type: ignore[attr-defined]
            headers.update(self.proxy_headers)  # type: ignore[union-attr]
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]
    
            # Is this a closed/new connection that requires CONNECT tunnelling?
            if self.proxy is not None and http_tunnel_required and conn.is_closed:
                try:
                    self._prepare_proxy(conn)
                except (BaseSSLError, OSError, SocketTimeout) as e:
                    self._raise_timeout(
                        err=e, url=self.proxy.url, timeout_value=conn.timeout
                    )
                    raise
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Make the request on the HTTPConnection object
>           response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
                retries=retries,
                response_conn=response_conn,
                preload_content=preload_content,
                decode_content=decode_content,
                **response_kw,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:493: in _make_request
    conn.request(
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:494: in request
    self.endheaders()
C:\Program Files\Python311\Lib\http\client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
C:\Program Files\Python311\Lib\http\client.py:1037: in _send_output
    self.send(msg)
C:\Program Files\Python311\Lib\http\client.py:975: in send
    self.connect()
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:325: in connect
    self.sock = self._new_conn()
                ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <urllib3.connection.HTTPConnection object at 0x000001EC12D4CE10>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
            sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )
        except socket.gaierror as e:
            raise NameResolutionError(self.host, self, e) from e
        except SocketTimeout as e:
            raise ConnectTimeoutError(
                self,
                f"Connection to {self.host} timed out. (connect timeout={self.timeout})",
            ) from e
    
        except OSError as e:
>           raise NewConnectionError(
                self, f"Failed to establish a new connection: {e}"
            ) from e
E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x000001EC12D4CE10>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:213: NewConnectionError

The above exception was the direct cause of the following exception:

self = <requests.adapters.HTTPAdapter object at 0x000001EC12D4DF90>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
>           resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:486: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:841: in urlopen
    retries = retries.increment(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'GET', url = '/docs', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001EC12D4CE10>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001EC12D4EF10>
_stacktrace = <traceback object at 0x000001EC12D4CD00>

    def increment(
        self,
        method: str | None = None,
        url: str | None = None,
        response: BaseHTTPResponse | None = None,
        error: Exception | None = None,
        _pool: ConnectionPool | None = None,
        _stacktrace: TracebackType | None = None,
    ) -> Self:
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.BaseHTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or method is None or not self._is_method_retryable(method):
                raise reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            response_redirect_location = response.get_redirect_location()
            if response_redirect_location:
                redirect_location = response_redirect_location
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
            reason = error or ResponseError(cause)
>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /docs (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001EC12D4CE10>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\urllib3\util\retry.py:519: MaxRetryError

During handling of the above exception, another exception occurred:

    def test_openapi_docs():
        """╥хёЄ OpenAPI фюъєьхэЄрЎшш"""
>       response = requests.get("http://127.0.0.1:8000/docs", timeout=30)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\integration\test_server_integration.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\requests\api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:703: in send
    r = adapter.send(request, **kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <requests.adapters.HTTPAdapter object at 0x000001EC12D4DF90>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /docs (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001EC12D4CE10>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:519: ConnectionError
_____ TestVisitConfirmationAPI.test_confirm_visit_telegram_invalid_token ______

self = <test_visit_confirmation_api.TestVisitConfirmationAPI object at 0x000001EC10496A50>
client = <starlette.testclient.TestClient object at 0x000001EC126CD150>

    def test_confirm_visit_telegram_invalid_token(self, client):
        """╥хёЄ яюфЄтхЁцфхэш  ё эхфхщёЄтшЄхы№э√ь Єюъхэюь"""
        response = client.post("/api/v1/telegram/visits/confirm", json={
            "token": "invalid-token-123",
            "telegram_user_id": "123456789"
        })
    
>       assert response.status_code == 404
E       assert 400 == 404
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\integration\test_visit_confirmation_api.py:72: AssertionError
________________________ test_audit_log_create_patient ________________________

client = <starlette.testclient.TestClient object at 0x000001EC12320F10>
db = <sqlalchemy.orm.session.Session object at 0x000001EC12321390>
admin_user = <app.models.user.User object at 0x000001EC12C90310>

    def test_audit_log_create_patient(client: TestClient, db: Session, admin_user: User):
        """╥хёЄ: ёючфрэшх ярЎшхэЄр фюыцэю ыюушЁютрЄ№ё """
        # ╧юыєўрхь Єюъхэ
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       token = response.json()["access_token"]
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'access_token'

tests\test_audit_logs.py:29: KeyError
---------------------------- Captured stdout call -----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
________________________ test_audit_log_update_patient ________________________

client = <starlette.testclient.TestClient object at 0x000001EC12248E90>
db = <sqlalchemy.orm.session.Session object at 0x000001EC1042DC10>
admin_user = <app.models.user.User object at 0x000001EC1322E450>
test_patient = <app.models.patient.Patient object at 0x000001EC1264E410>

    def test_audit_log_update_patient(client: TestClient, db: Session, admin_user: User, test_patient: Patient):
        """╥хёЄ: юсэютыхэшх ярЎшхэЄр фюыцэю ыюушЁютрЄ№ё """
        # ╧юыєўрхь Єюъхэ
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       token = response.json()["access_token"]
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'access_token'

tests\test_audit_logs.py:73: KeyError
---------------------------- Captured stdout call -----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
________________________ test_audit_log_delete_patient ________________________

client = <starlette.testclient.TestClient object at 0x000001EC12523F10>
db = <sqlalchemy.orm.session.Session object at 0x000001EC12522590>
admin_user = <app.models.user.User object at 0x000001EC12CEA190>
test_patient = <app.models.patient.Patient object at 0x000001EC127019D0>

    def test_audit_log_delete_patient(client: TestClient, db: Session, admin_user: User, test_patient: Patient):
        """╥хёЄ: єфрыхэшх ярЎшхэЄр фюыцэю ыюушЁютрЄ№ё """
        # ╧юыєўрхь Єюъхэ
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       token = response.json()["access_token"]
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'access_token'

tests\test_audit_logs.py:111: KeyError
---------------------------- Captured stdout call -----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
_____________________ test_audit_log_create_payment_init ______________________

client = <starlette.testclient.TestClient object at 0x000001EC12C94810>
db = <sqlalchemy.orm.session.Session object at 0x000001EC12CB0390>
admin_user = <app.models.user.User object at 0x000001EC1252C7D0>
test_patient = <app.models.patient.Patient object at 0x000001EC12FD9490>

    def test_audit_log_create_payment_init(client: TestClient, db: Session, admin_user: User, test_patient: Patient):
        """╥хёЄ: шэшЎшрышчрЎш  яырЄхцр ўхЁхч /payments/init фюыцэр ыюушЁютрЄ№ё """
        # ╦юушэ рфьшэр
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       token = response.json()["access_token"]
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'access_token'

tests\test_audit_logs.py:143: KeyError
---------------------------- Captured stdout call -----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
__________________________ test_audit_log_request_id __________________________

client = <starlette.testclient.TestClient object at 0x000001EC12869090>
db = <sqlalchemy.orm.session.Session object at 0x000001EC12868D90>
admin_user = <app.models.user.User object at 0x000001EC12323610>

    def test_audit_log_request_id(client: TestClient, db: Session, admin_user: User):
        """╥хёЄ: ърцф√щ чряЁюё фюыцхэ шьхЄ№ єэшъры№э√щ request_id"""
        # ╧юыєўрхь Єюъхэ
        response = client.post(
            "/api/v1/authentication/login",
            json={"username": admin_user.username, "password": "admin123"},
        )
>       token = response.json()["access_token"]
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       KeyError: 'access_token'

tests\test_audit_logs.py:237: KeyError
---------------------------- Captured stdout call -----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001EC680B1C50>
DEBUG: login_user result: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
DEBUG: Authentication failed, raising HTTPException
DEBUG: Result details: {'success': False, 'message': '─ы  Ёюыш Admin ЄЁхсєхЄё  эрёЄЁющър фтєїЇръЄюЁэющ рєЄхэЄшЇшърЎшш (2FA). ╧юцрыєщёЄр, эрёЄЁющЄх 2FA яхЁхф тїюфюь.', 'user': None, 'tokens': None, 'requires_2fa': False, 'requires_2fa_setup': True, 'two_factor_method': None}
____________ TestFileSecurity.test_file_hash_is_computed_on_upload ____________

self = <tests.test_file_security.TestFileSecurity object at 0x000001EC10416A10>
client = <starlette.testclient.TestClient object at 0x000001EC125956D0>
db_session = <sqlalchemy.orm.session.Session object at 0x000001EC131683D0>

    def test_file_hash_is_computed_on_upload(
        self, client: TestClient, db_session: Session
    ):
        """\u2705 CERTIFICATION: SHA256 \u0445\u0435\u0448 \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u0442\u0441\u044f \u043f\u0440\u0438 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0435 \u0444\u0430\u0439\u043b\u0430"""
        # ╤ючфрхь яюы№чютрЄхы  ё Ёюы№■, ъюЄюЁр  ьюцхЄ чруЁєцрЄ№ Їрщы√ (Doctor)
        from app.core.security import get_password_hash
        from app.models.user import User
    
        doctor_user = db_session.query(User).filter(User.username == "doctor_file_test").first()
        if not doctor_user:
            doctor_user = User(
                username="doctor_file_test",
                email="doctor_file@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                is_superuser=False,
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╧юыєўрхь Єюъхэ
        login_response = client.post(
            "/api/v1/auth/minimal-login",
            json={"username": doctor_user.username, "password": "doctor123"},
        )
        assert login_response.status_code == 200
        token = login_response.json()["access_token"]
    
        # ╟руЁєцрхь ЄхёЄют√щ Їрщы
        file_content = b"Test file content for hashing"
        file_obj = BytesIO(file_content)
        file_obj.name = "test.txt"
    
        response = client.post(
            "/api/v1/files/upload",
            files={"file": ("test.txt", file_obj, "text/plain")},
            data={
                "file_type": "document",
                "permission": "private",
            },
            headers={"Authorization": f"Bearer {token}"},
        )
    
>       assert response.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\test_file_security.py:66: AssertionError
---------------------------- Captured stdout call -----------------------------
DEBUG: Minimal login called with username=doctor_file_test
DEBUG: User found: ID=19, Username=doctor_file_test, IsActive=1
DEBUG: Verifying password...
DEBUG: Password verification result: True
DEBUG: Token created successfully, expires in 28800 seconds
DEBUG: Successful authentication for user doctor_file_test
DEBUG: Checking roles for user 19 (doctor_file_test)
DEBUG: User Role: 'Doctor', Normalized: 'doctor'
DEBUG: Required Roles: ('Admin', 'Doctor', 'Nurse', 'Receptionist'), Normalized: ['admin', 'doctor', 'nurse', 'receptionist']
---------------------------- Captured stderr call -----------------------------
WARNING:app.utils.file_validator:[File Validator] Unknown file type for test.txt
------------------------------ Captured log call ------------------------------
WARNING  app.utils.file_validator:file_validator.py:257 [File Validator] Unknown file type for test.txt
__________ TestFileSecurity.test_file_versioning_on_content_replace ___________

self = <tests.test_file_security.TestFileSecurity object at 0x000001EC10417890>
client = <starlette.testclient.TestClient object at 0x000001EC12FB02D0>
db_session = <sqlalchemy.orm.session.Session object at 0x000001EC12FB0510>

    def test_file_versioning_on_content_replace(
        self, client: TestClient, db_session: Session
    ):
        """\u2705 CERTIFICATION: \u0412\u0435\u0440\u0441\u0438\u044f \u0441\u043e\u0437\u0434\u0430\u0435\u0442\u0441\u044f \u043f\u0440\u0438 \u0437\u0430\u043c\u0435\u043d\u0435 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0433\u043e \u0444\u0430\u0439\u043b\u0430"""
        # ╤ючфрхь яюы№чютрЄхы  ё Ёюы№■ Doctor
        from app.core.security import get_password_hash
        from app.models.user import User
    
        doctor_user = db_session.query(User).filter(User.username == "doctor_file_test2").first()
        if not doctor_user:
            doctor_user = User(
                username="doctor_file_test2",
                email="doctor_file2@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                is_superuser=False,
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╧юыєўрхь Єюъхэ
        login_response = client.post(
            "/api/v1/auth/minimal-login",
            json={"username": doctor_user.username, "password": "doctor123"},
        )
        assert login_response.status_code == 200
        token = login_response.json()["access_token"]
    
        # ╪ру 1: ╟руЁєцрхь шёїюфэ√щ Їрщы
        file_content_1 = b"Original file content"
        file_obj_1 = BytesIO(file_content_1)
        file_obj_1.name = "original.txt"
    
        upload_response = client.post(
            "/api/v1/files/upload",
            files={"file": ("original.txt", file_obj_1, "text/plain")},
            data={
                "file_type": "document",
                "permission": "private",
            },
            headers={"Authorization": f"Bearer {token}"},
        )
>       assert upload_response.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\test_file_security.py:121: AssertionError
---------------------------- Captured stdout call -----------------------------
DEBUG: Minimal login called with username=doctor_file_test2
DEBUG: User found: ID=20, Username=doctor_file_test2, IsActive=1
DEBUG: Verifying password...
DEBUG: Password verification result: True
DEBUG: Token created successfully, expires in 28800 seconds
DEBUG: Successful authentication for user doctor_file_test2
DEBUG: Checking roles for user 20 (doctor_file_test2)
DEBUG: User Role: 'Doctor', Normalized: 'doctor'
DEBUG: Required Roles: ('Admin', 'Doctor', 'Nurse', 'Receptionist'), Normalized: ['admin', 'doctor', 'nurse', 'receptionist']
---------------------------- Captured stderr call -----------------------------
WARNING:app.utils.file_validator:[File Validator] Unknown file type for original.txt
------------------------------ Captured log call ------------------------------
WARNING  app.utils.file_validator:file_validator.py:257 [File Validator] Unknown file type for original.txt
_________________ TestFileSecurity.test_file_hash_consistency _________________

self = <tests.test_file_security.TestFileSecurity object at 0x000001EC104179D0>
client = <starlette.testclient.TestClient object at 0x000001EC126D8D50>
db_session = <sqlalchemy.orm.session.Session object at 0x000001EC12840590>

    def test_file_hash_consistency(
        self, client: TestClient, db_session: Session
    ):
        """\u2705 CERTIFICATION: \u041e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u044b\u0435 \u0444\u0430\u0439\u043b\u044b \u0438\u043c\u0435\u044e\u0442 \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u044b\u0439 \u0445\u0435\u0448"""
        # ╤ючфрхь яюы№чютрЄхы  ё Ёюы№■ Doctor
        from app.core.security import get_password_hash
        from app.models.user import User
    
        doctor_user = db_session.query(User).filter(User.username == "doctor_file_test3").first()
        if not doctor_user:
            doctor_user = User(
                username="doctor_file_test3",
                email="doctor_file3@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                is_superuser=False,
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╧юыєўрхь Єюъхэ
        login_response = client.post(
            "/api/v1/auth/minimal-login",
            json={"username": doctor_user.username, "password": "doctor123"},
        )
        assert login_response.status_code == 200
        token = login_response.json()["access_token"]
    
        file_content = b"Identical content"
    
        # ╟руЁєцрхь яхЁт√щ Їрщы
        file_obj_1 = BytesIO(file_content)
        file_obj_1.name = "file1.txt"
        response_1 = client.post(
            "/api/v1/files/upload",
            files={"file": ("file1.txt", file_obj_1, "text/plain")},
            data={"file_type": "document", "permission": "private"},
            headers={"Authorization": f"Bearer {token}"},
        )
>       assert response_1.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\test_file_security.py:221: AssertionError
---------------------------- Captured stdout call -----------------------------
DEBUG: Minimal login called with username=doctor_file_test3
DEBUG: User found: ID=21, Username=doctor_file_test3, IsActive=1
DEBUG: Verifying password...
DEBUG: Password verification result: True
DEBUG: Token created successfully, expires in 28800 seconds
DEBUG: Successful authentication for user doctor_file_test3
DEBUG: Checking roles for user 21 (doctor_file_test3)
DEBUG: User Role: 'Doctor', Normalized: 'doctor'
DEBUG: Required Roles: ('Admin', 'Doctor', 'Nurse', 'Receptionist'), Normalized: ['admin', 'doctor', 'nurse', 'receptionist']
---------------------------- Captured stderr call -----------------------------
WARNING:app.utils.file_validator:[File Validator] Unknown file type for file1.txt
------------------------------ Captured log call ------------------------------
WARNING  app.utils.file_validator:file_validator.py:257 [File Validator] Unknown file type for file1.txt
______________ TestFileSecurity.test_file_version_hash_required _______________

self = <tests.test_file_security.TestFileSecurity object at 0x000001EC10414690>
client = <starlette.testclient.TestClient object at 0x000001EC12CB1550>
db_session = <sqlalchemy.orm.session.Session object at 0x000001EC126C5910>

    def test_file_version_hash_required(
        self, client: TestClient, db_session: Session
    ):
        """\u2705 CERTIFICATION: \u0412\u0435\u0440\u0441\u0438\u044f \u0444\u0430\u0439\u043b\u0430 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 file_hash"""
        # ╤ючфрхь яюы№чютрЄхы  ё Ёюы№■ Doctor
        from app.core.security import get_password_hash
        from app.models.user import User
    
        doctor_user = db_session.query(User).filter(User.username == "doctor_file_test4").first()
        if not doctor_user:
            doctor_user = User(
                username="doctor_file_test4",
                email="doctor_file4@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                is_superuser=False,
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╧юыєўрхь Єюъхэ
        login_response = client.post(
            "/api/v1/auth/minimal-login",
            json={"username": doctor_user.username, "password": "doctor123"},
        )
        assert login_response.status_code == 200
        token = login_response.json()["access_token"]
    
        # ╟руЁєцрхь Їрщы
        file_content = b"Version test"
        file_obj = BytesIO(file_content)
        file_obj.name = "version_test.txt"
    
        upload_response = client.post(
            "/api/v1/files/upload",
            files={"file": ("version_test.txt", file_obj, "text/plain")},
            data={"file_type": "document", "permission": "private"},
            headers={"Authorization": f"Bearer {token}"},
        )
>       assert upload_response.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\test_file_security.py:280: AssertionError
---------------------------- Captured stdout call -----------------------------
DEBUG: Minimal login called with username=doctor_file_test4
DEBUG: User found: ID=22, Username=doctor_file_test4, IsActive=1
DEBUG: Verifying password...
DEBUG: Password verification result: True
DEBUG: Token created successfully, expires in 28800 seconds
DEBUG: Successful authentication for user doctor_file_test4
DEBUG: Checking roles for user 22 (doctor_file_test4)
DEBUG: User Role: 'Doctor', Normalized: 'doctor'
DEBUG: Required Roles: ('Admin', 'Doctor', 'Nurse', 'Receptionist'), Normalized: ['admin', 'doctor', 'nurse', 'receptionist']
---------------------------- Captured stderr call -----------------------------
WARNING:app.utils.file_validator:[File Validator] Unknown file type for version_test.txt
------------------------------ Captured log call ------------------------------
WARNING  app.utils.file_validator:file_validator.py:257 [File Validator] Unknown file type for version_test.txt
_______________ TestRateLimiting.test_rate_limit_login_endpoint _______________

self = <tests.test_security_middleware.TestRateLimiting object at 0x000001EC102DBBD0>
app_with_security = <fastapi.applications.FastAPI object at 0x000001EC12E0B550>

    def test_rate_limit_login_endpoint(self, app_with_security):
        """╥хёЄ: яЁхт√°хэшх ышьшЄр эр login endpoint"""
        client = TestClient(app_with_security)
        # ─хырхь 6 чряЁюёют (ышьшЄ: 5 чр 5 ьшэєЄ)
        for i in range(5):
            response = client.post("/api/v1/authentication/login")
            assert response.status_code in [200, 400, 401]  # ╠юцхЄ с√Є№ ю°шсър трышфрЎшш
    
        # 6-щ чряЁюё фюыцхэ с√Є№ чрсыюъшЁютрэ
        response = client.post("/api/v1/authentication/login")
>       assert response.status_code == status.HTTP_429_TOO_MANY_REQUESTS
E       assert 200 == 429
E        +  where 200 = <Response [200 OK]>.status_code
E        +  and   429 = status.HTTP_429_TOO_MANY_REQUESTS

tests\test_security_middleware.py:64: AssertionError
_________________ TestRateLimiting.test_rate_limit_2fa_verify _________________

self = <tests.test_security_middleware.TestRateLimiting object at 0x000001EC102DA410>
app_with_security = <fastapi.applications.FastAPI object at 0x000001EC12701BD0>

    def test_rate_limit_2fa_verify(self, app_with_security):
        """╥хёЄ: яЁхт√°хэшх ышьшЄр эр 2FA verify endpoint"""
        client = TestClient(app_with_security)
        # ─хырхь 11 чряЁюёют (ышьшЄ: 10 чр 5 ьшэєЄ)
        for i in range(10):
            response = client.post("/api/v1/2fa/verify")
            assert response.status_code in [200, 400, 401]
    
        # 11-щ чряЁюё фюыцхэ с√Є№ чрсыюъшЁютрэ
        response = client.post("/api/v1/2fa/verify")
>       assert response.status_code == status.HTTP_429_TOO_MANY_REQUESTS
E       assert 200 == 429
E        +  where 200 = <Response [200 OK]>.status_code
E        +  and   429 = status.HTTP_429_TOO_MANY_REQUESTS

tests\test_security_middleware.py:77: AssertionError
_______________ TestRateLimiting.test_rate_limit_password_reset _______________

self = <tests.test_security_middleware.TestRateLimiting object at 0x000001EC102D9F90>
app_with_security = <fastapi.applications.FastAPI object at 0x000001EC12FB14D0>

    def test_rate_limit_password_reset(self, app_with_security):
        """╥хёЄ: яЁхт√°хэшх ышьшЄр эр password reset endpoint"""
        client = TestClient(app_with_security)
        # ─хырхь 4 чряЁюёр (ышьшЄ: 3 чр ўрё)
        for i in range(3):
            response = client.post("/api/v1/authentication/password-reset")
            assert response.status_code in [200, 400]
    
        # 4-щ чряЁюё фюыцхэ с√Є№ чрсыюъшЁютрэ
        response = client.post("/api/v1/authentication/password-reset")
>       assert response.status_code == status.HTTP_429_TOO_MANY_REQUESTS
E       assert 200 == 429
E        +  where 200 = <Response [200 OK]>.status_code
E        +  and   429 = status.HTTP_429_TOO_MANY_REQUESTS

tests\test_security_middleware.py:89: AssertionError
__________________ TestRateLimiting.test_rate_limit_headers ___________________

self = <tests.test_security_middleware.TestRateLimiting object at 0x000001EC102D9E90>
app_with_security = <fastapi.applications.FastAPI object at 0x000001EC129D6550>

    def test_rate_limit_headers(self, app_with_security):
        """╥хёЄ: яЁютхЁър чруюыютъют rate limit"""
        client = TestClient(app_with_security)
        response = client.post("/api/v1/authentication/login")
        # ╟руюыютъш фюсрты ■Єё  Єюы№ъю фы  єёях°э√ї чряЁюёют (status < 400)
        if response.status_code < 400:
>           assert "X-RateLimit-Limit" in response.headers
E           AssertionError: assert 'X-RateLimit-Limit' in Headers({'content-length': '30', 'content-type': 'application/json'})
E            +  where Headers({'content-length': '30', 'content-type': 'application/json'}) = <Response [200 OK]>.headers

tests\test_security_middleware.py:97: AssertionError
___________ TestBruteForceProtection.test_brute_force_login_blocked ___________

self = <tests.test_security_middleware.TestBruteForceProtection object at 0x000001EC101E3F90>
client = <starlette.testclient.TestClient object at 0x000001EC12D27B10>

    def test_brute_force_login_blocked(self, client: TestClient):
        """╥хёЄ: сыюъшЁютър IP яюёых ьэюцхёЄтхээ√ї эхєфрўэ√ї яюя√Єюъ login"""
        # ╤шьєышЁєхь эхєфрўэ√х яюя√Єъш (4xx/5xx юЄтхЄ√)
        # ─ы  ¤Єюую эєцэю, ўЄюс√ endpoint тючтЁр∙ры ю°шсъє
    
        # ╤ючфрхь юЄфхы№э√щ endpoint, ъюЄюЁ√щ тёхуфр тючтЁр∙рхЄ ю°шсъє
        app = FastAPI()
    
        @app.post("/api/v1/authentication/login")
        async def failing_login():
            from fastapi import HTTPException
            raise HTTPException(status_code=401, detail="Invalid credentials")
    
        app.add_middleware(SecurityMiddleware)
        test_client = TestClient(app)
    
        # ─хырхь 5 эхєфрўэ√ї яюя√Єюъ (ышьшЄ: 5)
        for i in range(5):
            response = test_client.post("/api/v1/authentication/login")
            assert response.status_code == 401
    
        # 6-  яюя√Єър фюыцэр с√Є№ чрсыюъшЁютрэр
        response = test_client.post("/api/v1/authentication/login")
>       assert response.status_code == status.HTTP_429_TOO_MANY_REQUESTS
E       assert 401 == 429
E        +  where 401 = <Response [401 Unauthorized]>.status_code
E        +  and   429 = status.HTTP_429_TOO_MANY_REQUESTS

tests\test_security_middleware.py:138: AssertionError
____________ TestBruteForceProtection.test_brute_force_2fa_blocked ____________

self = <tests.test_security_middleware.TestBruteForceProtection object at 0x000001EC101E1990>
client = <starlette.testclient.TestClient object at 0x000001EC12CB1550>

    def test_brute_force_2fa_blocked(self, client: TestClient):
        """╥хёЄ: сыюъшЁютър IP яюёых ьэюцхёЄтхээ√ї эхєфрўэ√ї яюя√Єюъ 2FA"""
        app = FastAPI()
    
        @app.post("/api/v1/2fa/verify")
        async def failing_2fa():
            from fastapi import HTTPException
            raise HTTPException(status_code=400, detail="Invalid OTP")
    
        app.add_middleware(SecurityMiddleware)
        test_client = TestClient(app)
    
        # ─хырхь 5 эхєфрўэ√ї яюя√Єюъ
        for i in range(5):
            response = test_client.post("/api/v1/2fa/verify")
            assert response.status_code == 400
    
        # 6-  яюя√Єър фюыцэр с√Є№ чрсыюъшЁютрэр
        response = test_client.post("/api/v1/2fa/verify")
>       assert response.status_code == status.HTTP_429_TOO_MANY_REQUESTS
E       assert 400 == 429
E        +  where 400 = <Response [400 Bad Request]>.status_code
E        +  and   429 = status.HTTP_429_TOO_MANY_REQUESTS

tests\test_security_middleware.py:160: AssertionError
____ TestSecurityMiddlewareIntegration.test_rate_limit_reset_after_window _____

self = <tests.test_security_middleware.TestSecurityMiddlewareIntegration object at 0x000001EC10306450>
client = <starlette.testclient.TestClient object at 0x000001EC12CDB010>

    def test_rate_limit_reset_after_window(self, client: TestClient):
        """╥хёЄ: rate limit ёсЁрё√трхЄё  яюёых юъэр тЁхьхэш"""
        # ▌ЄюЄ ЄхёЄ ёыюцэю т√яюыэшЄ№ схч ьюъшЁютрэш  тЁхьхэш
        # ═ю ьюцэю яЁютхЁшЄ№, ўЄю ёўхЄўшъш юўш∙р■Єё 
        middleware = SecurityMiddleware(None)
    
        # ╤шьєышЁєхь ёЄрЁ√х чряшёш (ёЄрЁ°х юъэр)
        import time
        old_timestamp = time.time() - 2000  # 2000 ёхъєэф эрчрф (сюы№°х юъэр т 1 ўрё)
        middleware.request_counts["test:127.0.0.1"] = [old_timestamp]
    
        # ┬√ч√трхь cleanup
        middleware._cleanup_old_records()
    
        # ╧ЁютхЁ хь, ўЄю ёЄрЁ√х чряшёш єфрыхэ√
        # ╚ёяюы№чєхь юс√ўэ√щ dict тьхёЄю defaultdict фы  яЁютхЁъш
        if "test:127.0.0.1" in middleware.request_counts:
>           assert len(middleware.request_counts["test:127.0.0.1"]) == 0
E           assert 1 == 0
E            +  where 1 = len([1765739312.0094926])

tests\test_security_middleware.py:232: AssertionError
______________ TestMigrationService.test_backup_queue_data_empty ______________

self = <test_migration_service.TestMigrationService object at 0x000001EC104F9190>
db_session = <sqlalchemy.orm.session.Session object at 0x000001EC12680750>

    def test_backup_queue_data_empty(self, db_session):
        """╥хёЄ ёючфрэш  ЁхчхЁтэющ ъюяшш яєёЄ√ї фрээ√ї"""
        service = MigrationService(db_session)
    
        with patch('os.makedirs'), patch('builtins.open', create=True) as mock_open:
            mock_file = MagicMock()
            mock_open.return_value.__enter__.return_value = mock_file
    
            result = service.backup_queue_data(date.today())
    
            assert result["success"] is True
>           assert result["queues_count"] == 0
E           assert 4 == 0

tests\unit\test_migration_service.py:126: AssertionError
______________ TestMigrationService.test_cleanup_old_data_empty _______________

self = <test_migration_service.TestMigrationService object at 0x000001EC104E5A50>
db_session = <sqlalchemy.orm.session.Session object at 0x000001EC126E4E90>

    def test_cleanup_old_data_empty(self, db_session):
        """╥хёЄ юўшёЄъш ёЄрЁ√ї фрээ√ї т яєёЄющ ┴─"""
        service = MigrationService(db_session)
    
        result = service.cleanup_old_data(days_to_keep=30)
    
        assert result["success"] is True
>       assert result["deleted_queues"] == 0
E       assert 6 == 0

tests\unit\test_migration_service.py:220: AssertionError
============================== warnings summary ===============================
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1093
  C:\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1093: PydanticDeprecatedSince20: Using extra keyword arguments on `Field` is deprecated and will be removed. Use `json_schema_extra` instead. (Extra keys: 'env'). Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warn(

..\..\Program Files\Python311\Lib\site-packages\pydantic\_internal\_config.py:323: 51 warnings
  C:\Program Files\Python311\Lib\site-packages\pydantic\_internal\_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1068
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1068
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1068
  C:\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1068: PydanticDeprecatedSince20: `max_items` is deprecated and will be removed, use `max_length` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warn('`max_items` is deprecated and will be removed, use `max_length` instead', DeprecationWarning)

..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1062
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1062
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1062
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1062
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1062
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1062
  C:\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1062: PydanticDeprecatedSince20: `min_items` is deprecated and will be removed, use `min_length` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warn('`min_items` is deprecated and will be removed, use `min_length` instead', DeprecationWarning)

tests\integration\test_e2e_doctor_visit.py:155
  C:\final\backend\tests\integration\test_e2e_doctor_visit.py:155: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests\integration\test_e2e_doctor_visit.py:315
  C:\final\backend\tests\integration\test_e2e_doctor_visit.py:315: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests\integration\test_e2e_doctor_visit.py:353
  C:\final\backend\tests\integration\test_e2e_doctor_visit.py:353: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests\integration\test_e2e_patient_flow.py:140
  C:\final\backend\tests\integration\test_e2e_patient_flow.py:140: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests\integration\test_e2e_patient_flow.py:305
  C:\final\backend\tests\integration\test_e2e_patient_flow.py:305: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests\integration\test_e2e_payment_flow.py:92
  C:\final\backend\tests\integration\test_e2e_payment_flow.py:92: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests\integration\test_e2e_payment_flow.py:212
  C:\final\backend\tests\integration\test_e2e_payment_flow.py:212: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests\integration\test_e2e_payment_flow.py:247
  C:\final\backend\tests\integration\test_e2e_payment_flow.py:247: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
tests/integration/test_rbac_matrix.py::TestPositiveRBAC::test_admin_can_create_patient
tests/integration/test_rbac_matrix.py::TestPositiveRBAC::test_registrar_can_create_patient
  C:\final\backend\app\crud\base.py:30: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    data: Dict[str, Any] = obj_in.dict(exclude_unset=True)

tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
tests/integration/test_rbac_matrix.py::TestPositiveRBAC::test_doctor_can_read_patient
  C:\final\backend\app\crud\base.py:21: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    return db.query(self.model).get(id)

tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
  C:\final\backend\app\api\v1\endpoints\appointment_flow.py:389: PydanticDeprecatedSince20: The `from_orm` method is deprecated; set `model_config['from_attributes']=True` and use `model_validate` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    emr_dict = EMRSchema.from_orm(new_emr).dict()

tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
  C:\final\backend\app\api\v1\endpoints\appointment_flow.py:389: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    emr_dict = EMRSchema.from_orm(new_emr).dict()

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED tests/integration/test_api_integration.py::TestAPIIntegration::test_health_endpoint
FAILED tests/integration/test_api_integration.py::TestAPIIntegration::test_status_endpoint
FAILED tests/integration/test_api_integration.py::TestAPIIntegration::test_api_responsiveness
FAILED tests/integration/test_e2e_patient_flow.py::TestPatientAuthFlow::test_unauthorized_access_rejected
FAILED tests/integration/test_e2e_patient_flow.py::TestPatientAuthFlow::test_invalid_token_rejected
FAILED tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_empty_services_list_error
FAILED tests/integration/test_server_integration.py::test_health_endpoint - r...
FAILED tests/integration/test_server_integration.py::test_status_endpoint - r...
FAILED tests/integration/test_server_integration.py::test_openapi_docs - requ...
FAILED tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_telegram_invalid_token
FAILED tests/test_audit_logs.py::test_audit_log_create_patient - KeyError: 'a...
FAILED tests/test_audit_logs.py::test_audit_log_update_patient - KeyError: 'a...
FAILED tests/test_audit_logs.py::test_audit_log_delete_patient - KeyError: 'a...
FAILED tests/test_audit_logs.py::test_audit_log_create_payment_init - KeyErro...
FAILED tests/test_audit_logs.py::test_audit_log_request_id - KeyError: 'acces...
FAILED tests/test_file_security.py::TestFileSecurity::test_file_hash_is_computed_on_upload
FAILED tests/test_file_security.py::TestFileSecurity::test_file_versioning_on_content_replace
FAILED tests/test_file_security.py::TestFileSecurity::test_file_hash_consistency
FAILED tests/test_file_security.py::TestFileSecurity::test_file_version_hash_required
FAILED tests/test_security_middleware.py::TestRateLimiting::test_rate_limit_login_endpoint
FAILED tests/test_security_middleware.py::TestRateLimiting::test_rate_limit_2fa_verify
FAILED tests/test_security_middleware.py::TestRateLimiting::test_rate_limit_password_reset
FAILED tests/test_security_middleware.py::TestRateLimiting::test_rate_limit_headers
FAILED tests/test_security_middleware.py::TestBruteForceProtection::test_brute_force_login_blocked
FAILED tests/test_security_middleware.py::TestBruteForceProtection::test_brute_force_2fa_blocked
FAILED tests/test_security_middleware.py::TestSecurityMiddlewareIntegration::test_rate_limit_reset_after_window
FAILED tests/unit/test_migration_service.py::TestMigrationService::test_backup_queue_data_empty
FAILED tests/unit/test_migration_service.py::TestMigrationService::test_cleanup_old_data_empty
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorVisitFlow::test_doctor_can_view_queue
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorVisitFlow::test_doctor_can_call_next_patient
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorVisitFlow::test_doctor_can_start_visit
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorVisitFlow::test_doctor_can_fill_emr
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorVisitFlow::test_doctor_can_use_emr_template
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorVisitFlow::test_doctor_can_add_diagnosis_with_ai_suggestion
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorVisitFlow::test_doctor_can_generate_prescription_pdf
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorVisitFlow::test_doctor_can_complete_visit
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorQueueManagement::test_doctor_can_skip_patient
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorQueueManagement::test_doctor_can_get_patient_history
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorSecurity::test_doctor_cannot_access_admin_routes
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorSecurity::test_doctor_cannot_view_other_doctor_queue
ERROR tests/integration/test_e2e_migration_flow.py::TestE2EMigrationFlow::test_complete_migration_flow
ERROR tests/integration/test_e2e_migration_flow.py::TestE2EMigrationFlow::test_migration_with_old_data_cleanup
ERROR tests/integration/test_e2e_migration_flow.py::TestE2EMigrationFlow::test_error_recovery_in_migration_flow
ERROR tests/integration/test_e2e_migration_flow.py::TestE2EMigrationFlow::test_concurrent_migration_operations
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_can_view_appointments
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_can_view_single_appointment
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_can_cancel_future_appointment
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_cannot_cancel_soon_appointment
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_can_reschedule_appointment
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_can_get_available_slots
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_can_view_results
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_cannot_view_others_appointments
ERROR tests/integration/test_e2e_payment_flow.py::TestPaymentFlow::test_create_payment_for_visit
ERROR tests/integration/test_e2e_payment_flow.py::TestPaymentFlow::test_get_pending_payments_list
ERROR tests/integration/test_e2e_payment_flow.py::TestPaymentFlow::test_get_payment_status
ERROR tests/integration/test_e2e_payment_flow.py::TestPaymentFlow::test_payment_receipt_generation
ERROR tests/integration/test_e2e_payment_flow.py::TestPaymentProviders::test_click_payment_init
ERROR tests/integration/test_e2e_payment_flow.py::TestPaymentProviders::test_payme_payment_init
ERROR tests/integration/test_e2e_payment_flow.py::TestPaymentSecurity::test_invalid_amount_rejected
ERROR tests/integration/test_e2e_visit_flow.py::TestE2EVisitFlow::test_complete_visit_flow_today
ERROR tests/integration/test_e2e_visit_flow.py::TestE2EVisitFlow::test_complete_visit_flow_future_date
ERROR tests/integration/test_e2e_visit_flow.py::TestE2EVisitFlow::test_morning_assignment_flow
ERROR tests/integration/test_e2e_visit_flow.py::TestE2EVisitFlow::test_registrar_confirmation_flow
ERROR tests/integration/test_e2e_visit_flow.py::TestE2EVisitFlow::test_multiple_services_queue_assignment
ERROR tests/integration/test_e2e_visit_flow.py::TestE2EVisitFlow::test_error_handling_in_flow
ERROR tests/integration/test_e2e_visit_flow.py::TestE2EVisitFlow::test_notification_integration
ERROR tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_check_migration_health_success
ERROR tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_check_data_integrity_success
ERROR tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_check_data_integrity_with_data
ERROR tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_get_migration_stats_success
ERROR tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_get_migration_stats_with_data
ERROR tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_migrate_legacy_data_success
ERROR tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_backup_queue_data_success
ERROR tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_backup_queue_data_specific_date
ERROR tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_backup_queue_data_invalid_date
ERROR tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_restore_queue_data_success
ERROR tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_restore_queue_data_file_not_found
ERROR tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_cleanup_old_data_success
ERROR tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_cleanup_old_data_with_old_data
ERROR tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_cleanup_old_data_invalid_days
ERROR tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_cleanup_old_data_max_days
ERROR tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_api_error_handling
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_create_single_queue_entry_success
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_create_multiple_queue_entries_different_specialists
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_source_preservation
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_duplicate_detection
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_service_grouping_by_specialist
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_auto_create_daily_queue
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_patient_not_found_error
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_service_not_found_error
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_specialist_not_found_error
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_invalid_source_error
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_admin_access_allowed
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_registrar_access_allowed
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_doctor_access_denied
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_unauthenticated_access_denied
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_fair_queue_numbering
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_get_visit_info_success
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_get_visit_info_expired_token
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_telegram_success
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_telegram_wrong_channel
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_pwa_success
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_pwa_phone_mismatch
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_registrar_success
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_registrar_unauthorized
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_registrar_wrong_role
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_creates_queue_entry_today
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_no_queue_entry_future_date
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_updates_status
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_rate_limiting
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_security_validation
ERROR tests/unit/test_confirmation_security.py::TestConfirmationSecurityService::test_validate_confirmation_request_valid_token
ERROR tests/unit/test_confirmation_security.py::TestConfirmationSecurityService::test_validate_confirmation_request_expired_token
ERROR tests/unit/test_confirmation_security.py::TestConfirmationSecurityService::test_validate_confirmation_request_wrong_status
ERROR tests/unit/test_confirmation_security.py::TestConfirmationSecurityService::test_validate_confirmation_request_suspicious_user_agent
ERROR tests/unit/test_confirmation_security.py::TestConfirmationSecurityService::test_record_confirmation_attempt_success
ERROR tests/unit/test_confirmation_security.py::TestConfirmationSecurityService::test_record_confirmation_attempt_failure
ERROR tests/unit/test_confirmation_security.py::TestConfirmationSecurityService::test_logging_security_events
ERROR tests/unit/test_migration_service.py::TestMigrationService::test_check_data_integrity_with_data
ERROR tests/unit/test_migration_service.py::TestMigrationService::test_backup_queue_data_with_data
=========== 28 failed, 141 passed, 80 warnings, 92 errors in 40.66s ===========
