============================= test session starts =============================
platform win32 -- Python 3.11.1, pytest-8.4.1, pluggy-1.6.0
rootdir: C:\final\backend
configfile: pytest.ini
plugins: anyio-4.10.0, asyncio-1.1.0
asyncio: mode=Mode.STRICT, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 261 items

tests\integration\test_api_integration.py FFF                            [  1%]
tests\integration\test_e2e_clinic.py .                                   [  1%]
tests\integration\test_e2e_doctor_visit.py EEEEEEEEEEEE                  [  6%]
tests\integration\test_e2e_migration_flow.py FFFFF                       [  8%]
tests\integration\test_e2e_patient_flow.py EEEEEEEEFF                    [ 11%]
tests\integration\test_e2e_payment_flow.py E..EE...F                     [ 15%]
tests\integration\test_e2e_visit_flow.py EFFFFFF                         [ 18%]
tests\integration\test_migration_management_api.py ....E.E.....F.....F   [ 25%]
tests\integration\test_online_queue_scenarios.py ......                  [ 27%]
tests\integration\test_queue_batch_api.py EEEEEEEEEEEEEEFE               [ 33%]
tests\integration\test_rbac_matrix.py ...................                [ 40%]
tests\integration\test_server_integration.py FFF                         [ 42%]
tests\integration\test_visit_confirmation_api.py E.EEFEEEEEEEEEEE        [ 48%]
tests\test_2fa_enforcement.py FF...                                      [ 50%]
tests\test_api_responses.py ....................                         [ 57%]
tests\test_audit_logs.py .............                                   [ 62%]
tests\test_file_security.py FF.FF                                        [ 64%]
tests\test_payment_model.py .                                            [ 65%]
tests\test_security_middleware.py FFFF.FF....F                           [ 69%]
tests\test_settings.py ........                                          [ 72%]
tests\test_validators.py ................................                [ 85%]
tests\unit\test_confirmation_security.py E.EEE...EE..E..                 [ 90%]
tests\unit\test_migration_service.py ....F..FEFE...F.....                [ 98%]
tests\unit\test_simple.py ....                                           [100%]

=================================== ERRORS ====================================
______ ERROR at setup of TestDoctorVisitFlow.test_doctor_can_view_queue _______

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E83C4BD0>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
            doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                full_name="╥хёЄ ─юъЄюЁют",
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╤ючфрхь яЁюЇшы№ тЁрўр
        doctor = db_session.query(Doctor).filter(Doctor.user_id == doctor_user.id).first()
        if not doctor:
>           doctor = Doctor(
                user_id=doctor_user.id,
                specialty="╥хЁряш ",
                license_number="DOC_E2E_001",
                experience_years=5,
                is_active=True,
            )

tests\integration\test_e2e_doctor_visit.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6E9A93010>
kwargs = {'experience_years': 5, 'is_active': True, 'license_number': 'DOC_E2E_001', 'specialty': '╥хЁряш ', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___ ERROR at setup of TestDoctorVisitFlow.test_doctor_can_call_next_patient ___

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9A93790>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
            doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                full_name="╥хёЄ ─юъЄюЁют",
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╤ючфрхь яЁюЇшы№ тЁрўр
        doctor = db_session.query(Doctor).filter(Doctor.user_id == doctor_user.id).first()
        if not doctor:
>           doctor = Doctor(
                user_id=doctor_user.id,
                specialty="╥хЁряш ",
                license_number="DOC_E2E_001",
                experience_years=5,
                is_active=True,
            )

tests\integration\test_e2e_doctor_visit.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6E812F490>
kwargs = {'experience_years': 5, 'is_active': True, 'license_number': 'DOC_E2E_001', 'specialty': '╥хЁряш ', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
______ ERROR at setup of TestDoctorVisitFlow.test_doctor_can_start_visit ______

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9BB3050>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
            doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                full_name="╥хёЄ ─юъЄюЁют",
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╤ючфрхь яЁюЇшы№ тЁрўр
        doctor = db_session.query(Doctor).filter(Doctor.user_id == doctor_user.id).first()
        if not doctor:
>           doctor = Doctor(
                user_id=doctor_user.id,
                specialty="╥хЁряш ",
                license_number="DOC_E2E_001",
                experience_years=5,
                is_active=True,
            )

tests\integration\test_e2e_doctor_visit.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6E9A27C90>
kwargs = {'experience_years': 5, 'is_active': True, 'license_number': 'DOC_E2E_001', 'specialty': '╥хЁряш ', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______ ERROR at setup of TestDoctorVisitFlow.test_doctor_can_fill_emr ________

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E996D3D0>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
            doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                full_name="╥хёЄ ─юъЄюЁют",
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╤ючфрхь яЁюЇшы№ тЁрўр
        doctor = db_session.query(Doctor).filter(Doctor.user_id == doctor_user.id).first()
        if not doctor:
>           doctor = Doctor(
                user_id=doctor_user.id,
                specialty="╥хЁряш ",
                license_number="DOC_E2E_001",
                experience_years=5,
                is_active=True,
            )

tests\integration\test_e2e_doctor_visit.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6E9CA6210>
kwargs = {'experience_years': 5, 'is_active': True, 'license_number': 'DOC_E2E_001', 'specialty': '╥хЁряш ', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___ ERROR at setup of TestDoctorVisitFlow.test_doctor_can_use_emr_template ____

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E99F2A90>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
            doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                full_name="╥хёЄ ─юъЄюЁют",
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╤ючфрхь яЁюЇшы№ тЁрўр
        doctor = db_session.query(Doctor).filter(Doctor.user_id == doctor_user.id).first()
        if not doctor:
>           doctor = Doctor(
                user_id=doctor_user.id,
                specialty="╥хЁряш ",
                license_number="DOC_E2E_001",
                experience_years=5,
                is_active=True,
            )

tests\integration\test_e2e_doctor_visit.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6E9BF1B10>
kwargs = {'experience_years': 5, 'is_active': True, 'license_number': 'DOC_E2E_001', 'specialty': '╥хЁряш ', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestDoctorVisitFlow.test_doctor_can_add_diagnosis_with_ai_suggestion _

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9A2C450>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
            doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                full_name="╥хёЄ ─юъЄюЁют",
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╤ючфрхь яЁюЇшы№ тЁрўр
        doctor = db_session.query(Doctor).filter(Doctor.user_id == doctor_user.id).first()
        if not doctor:
>           doctor = Doctor(
                user_id=doctor_user.id,
                specialty="╥хЁряш ",
                license_number="DOC_E2E_001",
                experience_years=5,
                is_active=True,
            )

tests\integration\test_e2e_doctor_visit.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6E9CA6ED0>
kwargs = {'experience_years': 5, 'is_active': True, 'license_number': 'DOC_E2E_001', 'specialty': '╥хЁряш ', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestDoctorVisitFlow.test_doctor_can_generate_prescription_pdf _

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9C15450>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
            doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                full_name="╥хёЄ ─юъЄюЁют",
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╤ючфрхь яЁюЇшы№ тЁрўр
        doctor = db_session.query(Doctor).filter(Doctor.user_id == doctor_user.id).first()
        if not doctor:
>           doctor = Doctor(
                user_id=doctor_user.id,
                specialty="╥хЁряш ",
                license_number="DOC_E2E_001",
                experience_years=5,
                is_active=True,
            )

tests\integration\test_e2e_doctor_visit.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6E9C16D90>
kwargs = {'experience_years': 5, 'is_active': True, 'license_number': 'DOC_E2E_001', 'specialty': '╥хЁряш ', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
____ ERROR at setup of TestDoctorVisitFlow.test_doctor_can_complete_visit _____

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E993E110>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
            doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                full_name="╥хёЄ ─юъЄюЁют",
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╤ючфрхь яЁюЇшы№ тЁрўр
        doctor = db_session.query(Doctor).filter(Doctor.user_id == doctor_user.id).first()
        if not doctor:
>           doctor = Doctor(
                user_id=doctor_user.id,
                specialty="╥хЁряш ",
                license_number="DOC_E2E_001",
                experience_years=5,
                is_active=True,
            )

tests\integration\test_e2e_doctor_visit.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6E7EFBF50>
kwargs = {'experience_years': 5, 'is_active': True, 'license_number': 'DOC_E2E_001', 'specialty': '╥хЁряш ', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
__ ERROR at setup of TestDoctorQueueManagement.test_doctor_can_skip_patient ___

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9AC5B90>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
            doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                full_name="╥хёЄ ─юъЄюЁют",
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╤ючфрхь яЁюЇшы№ тЁрўр
        doctor = db_session.query(Doctor).filter(Doctor.user_id == doctor_user.id).first()
        if not doctor:
>           doctor = Doctor(
                user_id=doctor_user.id,
                specialty="╥хЁряш ",
                license_number="DOC_E2E_001",
                experience_years=5,
                is_active=True,
            )

tests\integration\test_e2e_doctor_visit.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6E9A93FD0>
kwargs = {'experience_years': 5, 'is_active': True, 'license_number': 'DOC_E2E_001', 'specialty': '╥хЁряш ', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestDoctorQueueManagement.test_doctor_can_get_patient_history _

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E802BB90>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
            doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                full_name="╥хёЄ ─юъЄюЁют",
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╤ючфрхь яЁюЇшы№ тЁрўр
        doctor = db_session.query(Doctor).filter(Doctor.user_id == doctor_user.id).first()
        if not doctor:
>           doctor = Doctor(
                user_id=doctor_user.id,
                specialty="╥хЁряш ",
                license_number="DOC_E2E_001",
                experience_years=5,
                is_active=True,
            )

tests\integration\test_e2e_doctor_visit.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6E9B78990>
kwargs = {'experience_years': 5, 'is_active': True, 'license_number': 'DOC_E2E_001', 'specialty': '╥хЁряш ', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestDoctorSecurity.test_doctor_cannot_access_admin_routes _

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9932990>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
            doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                full_name="╥хёЄ ─юъЄюЁют",
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╤ючфрхь яЁюЇшы№ тЁрўр
        doctor = db_session.query(Doctor).filter(Doctor.user_id == doctor_user.id).first()
        if not doctor:
>           doctor = Doctor(
                user_id=doctor_user.id,
                specialty="╥хЁряш ",
                license_number="DOC_E2E_001",
                experience_years=5,
                is_active=True,
            )

tests\integration\test_e2e_doctor_visit.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6E9976E10>
kwargs = {'experience_years': 5, 'is_active': True, 'license_number': 'DOC_E2E_001', 'specialty': '╥хЁряш ', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestDoctorSecurity.test_doctor_cannot_view_other_doctor_queue _

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9AF6550>

    @pytest.fixture
    def doctor_with_queue(db_session):
        """╤ючфрхЄ тЁрўр ё юўхЁхф№■ ярЎшхэЄют"""
        # ╤ючфрхь тЁрўр-яюы№чютрЄхы 
        doctor_user = db_session.query(User).filter(User.username == "e2e_doctor").first()
        if not doctor_user:
            doctor_user = User(
                username="e2e_doctor",
                email="e2e_doctor@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                full_name="╥хёЄ ─юъЄюЁют",
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╤ючфрхь яЁюЇшы№ тЁрўр
        doctor = db_session.query(Doctor).filter(Doctor.user_id == doctor_user.id).first()
        if not doctor:
>           doctor = Doctor(
                user_id=doctor_user.id,
                specialty="╥хЁряш ",
                license_number="DOC_E2E_001",
                experience_years=5,
                is_active=True,
            )

tests\integration\test_e2e_doctor_visit.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6E9CE7610>
kwargs = {'experience_years': 5, 'is_active': True, 'license_number': 'DOC_E2E_001', 'specialty': '╥хЁряш ', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
____ ERROR at setup of TestPatientFlow.test_patient_can_view_appointments _____

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9A7C310>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x000001B6E9C9CBD0>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestPatientFlow.test_patient_can_view_single_appointment __

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9A278D0>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x000001B6E9C8EC90>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestPatientFlow.test_patient_can_cancel_future_appointment _

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E7BFC650>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x000001B6E9E690D0>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestPatientFlow.test_patient_cannot_cancel_soon_appointment _

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9B887D0>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x000001B6E9BC7950>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
__ ERROR at setup of TestPatientFlow.test_patient_can_reschedule_appointment __

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9A7F7D0>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x000001B6E8123E50>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___ ERROR at setup of TestPatientFlow.test_patient_can_get_available_slots ____

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9B0B8D0>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x000001B6E9BF14D0>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______ ERROR at setup of TestPatientFlow.test_patient_can_view_results _______

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9B0AF90>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x000001B6E9CA5990>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestPatientFlow.test_patient_cannot_view_others_appointments _

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E818F410>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x000001B6E812F990>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______ ERROR at setup of TestPaymentFlow.test_create_payment_for_visit _______

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E83C5390>

    @pytest.fixture
    def payment_test_data(db_session):
        """╤ючфрхЄ ЄхёЄют√х фрээ√х фы  яюЄюър юяырЄ√"""
        # ╧рЎшхэЄ
        patient = db_session.query(Patient).filter(Patient.phone == "+998901234999").first()
        if not patient:
>           patient = Patient(
                first_name="╬яырЄр",
                last_name="╥хёЄют",
                middle_name="╥хёЄютшў",
                phone="+998901234999",
                email="payment_test@test.com",
                birth_date=date(1995, 3, 20),
            )

tests\integration\test_e2e_payment_flow.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x000001B6E83C6310>
kwargs = {'birth_date': datetime.date(1995, 3, 20), 'email': 'payment_test@test.com', 'first_name': '╬яырЄр', 'last_name': '╥хёЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxMywidHlwZSI6ImFjY2VzcyJ9.iuEuX4p7CtppF2vGsL02wvwY8HDn__tDb836GAG8y_w', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiJkYTEyNGM0Ni0yYzMxLTQ0ZGQtYmY4OS03OTUyYzEzZWYwZDEiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzUxM30.dnmUVy4RaijLOSQgg6-iHXZQjvHF2qeNzCdZNC4gVOU', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
__________ ERROR at setup of TestPaymentFlow.test_get_payment_status __________

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9BF1890>

    @pytest.fixture
    def payment_test_data(db_session):
        """╤ючфрхЄ ЄхёЄют√х фрээ√х фы  яюЄюър юяырЄ√"""
        # ╧рЎшхэЄ
        patient = db_session.query(Patient).filter(Patient.phone == "+998901234999").first()
        if not patient:
>           patient = Patient(
                first_name="╬яырЄр",
                last_name="╥хёЄют",
                middle_name="╥хёЄютшў",
                phone="+998901234999",
                email="payment_test@test.com",
                birth_date=date(1995, 3, 20),
            )

tests\integration\test_e2e_payment_flow.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x000001B6E8029610>
kwargs = {'birth_date': datetime.date(1995, 3, 20), 'email': 'payment_test@test.com', 'first_name': '╬яырЄр', 'last_name': '╥хёЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxNCwidHlwZSI6ImFjY2VzcyJ9.gNXMFLq-2eMMprXTm6P2QIz8u3OrNuIIFBeQYkuOi4Y', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiJiZjY2ODU2MC0xYmI3LTQxMDUtOTJmYS01MTkyNDExYWY5NjEiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzUxNH0.ZUWPjOpMh-6Q-bBRRODZkpTfvDuxLOtvys85OdNnibc', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
______ ERROR at setup of TestPaymentFlow.test_payment_receipt_generation ______

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E99D2390>

    @pytest.fixture
    def payment_test_data(db_session):
        """╤ючфрхЄ ЄхёЄют√х фрээ√х фы  яюЄюър юяырЄ√"""
        # ╧рЎшхэЄ
        patient = db_session.query(Patient).filter(Patient.phone == "+998901234999").first()
        if not patient:
>           patient = Patient(
                first_name="╬яырЄр",
                last_name="╥хёЄют",
                middle_name="╥хёЄютшў",
                phone="+998901234999",
                email="payment_test@test.com",
                birth_date=date(1995, 3, 20),
            )

tests\integration\test_e2e_payment_flow.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x000001B6E9B0AB10>
kwargs = {'birth_date': datetime.date(1995, 3, 20), 'email': 'payment_test@test.com', 'first_name': '╬яырЄр', 'last_name': '╥хёЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxNCwidHlwZSI6ImFjY2VzcyJ9.gNXMFLq-2eMMprXTm6P2QIz8u3OrNuIIFBeQYkuOi4Y', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiIzMGVkMWE2MC1mYWI4LTQzNmUtODA5ZS1iMTZiNWY1Y2MyN2YiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzUxNH0.XuXOK-265pqzJ1k7ANDZoKEkCyoHfmK_hgfDaoWN4GA', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
______ ERROR at setup of TestE2EVisitFlow.test_complete_visit_flow_today ______

fixturedef = <FixtureDef argname='test_service' scope='function' baseid='tests'>
request = <SubRequest 'test_service' for <Function test_complete_visit_flow_today>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:249: in test_service
    service = Service(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.service.Service object at 0x000001B6EA6579D0>
kwargs = {'allow_doctor_price_override': False, 'code': 'TEST_CONS', 'description': '╥хёЄютр  ъюэёєы№ЄрЎш  ърЁфшюыюур', 'duration_minutes': 30, ...}
cls_ = <class 'app.models.service.Service'>, k = 'description'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'description' is an invalid keyword argument for Service

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxNSwidHlwZSI6ImFjY2VzcyJ9.8Sfk97Kir6NVN_122JHkQ6ZfifyV4jsBb-FvW4ao7-k', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiIzODlmYTNkMC0xY2RiLTQ1OGQtOGNkMC1kMGVmOTJiN2EwYmEiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzUxNX0.GCQcM3Duyi6WP3hFD0JB9wEcWyebZcnLpD-hVsqgGds', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
_ ERROR at setup of TestMigrationManagementAPI.test_check_data_integrity_with_data _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_check_data_integrity_with_data>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6E9A27F10>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxNywidHlwZSI6ImFjY2VzcyJ9.2Kx_JzY3hgJeIbZ7z6RW2pGvkVxYxzsuxxG07ICNGYc', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiIzOTllNmI1OC1kNTRjLTQ5NjgtODYwMi0yMTY3MmY5YWFiNDIiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzUxN30.Ei-90BqdwGiVNPlBUl3_zTj5Q0wYkLNjsNnWvJViWQs', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
_ ERROR at setup of TestMigrationManagementAPI.test_get_migration_stats_with_data _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_get_migration_stats_with_data>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6EA64F850>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxNywidHlwZSI6ImFjY2VzcyJ9.2Kx_JzY3hgJeIbZ7z6RW2pGvkVxYxzsuxxG07ICNGYc', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiIyZTA5Yzg1MC1jMDMzLTRkOTItODRjZS1lOTA1NGU4Yzg4MjIiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzUxN30.MNLOvwXM8e8j3et_w4Y-xdIN5wWBUd3XkXRHj5FSrhg', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
_ ERROR at setup of TestQueueBatchAPI.test_create_single_queue_entry_success __

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9E6A450>

    @pytest.fixture(scope="function")
    def test_services(db_session):
        """╤ючфрхЄ ЄхёЄют√х єёыєуш"""
        services = []
    
        # ╙ёыєур 1: ╩юэёєы№ЄрЎш  ърЁфшюыюур
>       service1 = Service(
            code="CARDIO_CONS",
            name="╩юэёєы№ЄрЎш  ърЁфшюыюур",
            price=150000.00,
            duration_minutes=30,
            is_active=True,
            requires_doctor=True,
            queue_tag="cardiology_common",
            is_consultation=True
        )

tests\integration\test_queue_batch_api.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.service.Service object at 0x000001B6E9FAC6D0>
kwargs = {'code': 'CARDIO_CONS', 'duration_minutes': 30, 'is_active': True, 'is_consultation': True, ...}
cls_ = <class 'app.models.service.Service'>, k = 'is_active'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'is_active' is an invalid keyword argument for Service

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NDMzMTksInR5cGUiOiJhY2Nlc3MifQ.Jg2SXZoQFbxi9rTshSNT1xFvkI8_JDBCn8AdRhQoEhU', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiMDhkZDBmYzktODA3NC00MDdmLTg0NTQtOThjMjBjMWFlOGIxIiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzMzM1MTl9.yac0NwUMC-SANLPLcuFUqcCTBSE-GgYNzcztKdxyIKk', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
_ ERROR at setup of TestQueueBatchAPI.test_create_multiple_queue_entries_different_specialists _

self = <sqlalchemy.engine.base.Connection object at 0x000001B6EA9B9350>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA9DE990>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6EA9CB9C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA9DE990>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6EA908E90>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6EA9CB9C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA9DE990>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NDMzMTksInR5cGUiOiJhY2Nlc3MifQ.Jg2SXZoQFbxi9rTshSNT1xFvkI8_JDBCn8AdRhQoEhU', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiMDFkNDU1N2EtYWRkYi00NWY4LTg4OTktYTVjMWI2Y2QwNGU3IiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzMzM1MTl9.5XkP-59OaK81wOyOlKPr-BIe8HBOTHsezf1vw8LbQag', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
________ ERROR at setup of TestQueueBatchAPI.test_source_preservation _________

self = <sqlalchemy.engine.base.Connection object at 0x000001B6EA50BDD0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6E9BDE150>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6E81B96C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6E9BDE150>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9B7A210>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6E81B96C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6E9BDE150>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NDMzMjAsInR5cGUiOiJhY2Nlc3MifQ.zAc8-cTFqEmNSYnF506P2gxZSZlYXMq3H8RKJsH-7yo', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiODBmMzUyYzktMTA2YS00ZWY5LWE0YTItZjkxZGU1NDIzYmQ0IiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzMzM1MjB9.tiSdtZNSQesDHQ7S7yzMUT6qCVuMwhHfER3nOyWaOF8', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
________ ERROR at setup of TestQueueBatchAPI.test_duplicate_detection _________

self = <sqlalchemy.engine.base.Connection object at 0x000001B6EA045410>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA902290>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6EACDBDC0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA902290>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9CA7210>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6EACDBDC0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA902290>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NDMzMjAsInR5cGUiOiJhY2Nlc3MifQ.zAc8-cTFqEmNSYnF506P2gxZSZlYXMq3H8RKJsH-7yo', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiMjc4ZWFhZjAtMzQzOS00Y2M4LTg5ZTMtOTc4ODhiOWM1ZjEwIiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzMzM1MjB9.nTwypKGK9Fe6GQdCQVNVXo9v0n0URVdNCTgeIJnO8hc', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
___ ERROR at setup of TestQueueBatchAPI.test_service_grouping_by_specialist ___

self = <sqlalchemy.engine.base.Connection object at 0x000001B6E9E7C250>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA06B790>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6EA0BF340>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA06B790>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9F2A2D0>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6EA0BF340>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA06B790>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NDMzMjAsInR5cGUiOiJhY2Nlc3MifQ.zAc8-cTFqEmNSYnF506P2gxZSZlYXMq3H8RKJsH-7yo', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiNjZmZmNlZDYtNzM3My00ZTA5LWI2OTgtZDY5NWNlYjcyODI1IiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzMzM1MjB9.QII77ozBCy6mLbKpIokl3tTnXLhI6w-rN2jL4YcHH_4', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
______ ERROR at setup of TestQueueBatchAPI.test_auto_create_daily_queue _______

self = <sqlalchemy.engine.base.Connection object at 0x000001B6E9E8CCD0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6E9DDBB50>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6E7B8D5C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6E9DDBB50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9C31B50>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6E7B8D5C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6E9DDBB50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NDMzMjEsInR5cGUiOiJhY2Nlc3MifQ.NTvqnY1BQjrapSOqSUoIBaBCWkQD8nhjRYWC1x54fmw', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiNGVmNjRkYzctYTFmNi00MDk1LTliMTYtMzUzZGQ5OWI1MDVjIiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzMzM1MjF9.LLMZ0HklOh6WSw_lgPFA2bOR7OBo0q0BJoRuuV77Hfw', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
______ ERROR at setup of TestQueueBatchAPI.test_patient_not_found_error _______

self = <sqlalchemy.engine.base.Connection object at 0x000001B6EAC71910>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA569190>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6EA31BF40>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA569190>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9C33750>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6EA31BF40>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA569190>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NDMzMjEsInR5cGUiOiJhY2Nlc3MifQ.NTvqnY1BQjrapSOqSUoIBaBCWkQD8nhjRYWC1x54fmw', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiNDRmYmZhM2EtNDQ2YS00YzllLTk5M2ItMDY0YmZkOTQxOTI4IiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzMzM1MjF9.8AVylBFZR6lb-beaq9Hagx3owste9IN2cnA3XUsyEQw', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
______ ERROR at setup of TestQueueBatchAPI.test_service_not_found_error _______

self = <sqlalchemy.engine.base.Connection object at 0x000001B6EA06B190>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA625110>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6EAECD740>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA625110>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E995D850>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6EAECD740>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA625110>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NDMzMjIsInR5cGUiOiJhY2Nlc3MifQ.Y9wb4u3gyR9Dn_ziFOeb6Qpgy2fz8LfqxTletIKx5s8', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiYjNlMGM4MTctOWZjYy00MTIyLWIwY2ItZWZhMjdmOGQyMDI0IiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzMzM1MjJ9.gwAegftzQg6YBPrOQ2LmRmmUGX0hWddwtQjvOU8mNsQ', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
_____ ERROR at setup of TestQueueBatchAPI.test_specialist_not_found_error _____

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9ADB450>

    @pytest.fixture(scope="function")
    def test_services(db_session):
        """╤ючфрхЄ ЄхёЄют√х єёыєуш"""
        services = []
    
        # ╙ёыєур 1: ╩юэёєы№ЄрЎш  ърЁфшюыюур
>       service1 = Service(
            code="CARDIO_CONS",
            name="╩юэёєы№ЄрЎш  ърЁфшюыюур",
            price=150000.00,
            duration_minutes=30,
            is_active=True,
            requires_doctor=True,
            queue_tag="cardiology_common",
            is_consultation=True
        )

tests\integration\test_queue_batch_api.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.service.Service object at 0x000001B6EAA8C050>
kwargs = {'code': 'CARDIO_CONS', 'duration_minutes': 30, 'is_active': True, 'is_consultation': True, ...}
cls_ = <class 'app.models.service.Service'>, k = 'is_active'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'is_active' is an invalid keyword argument for Service

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NDMzMjIsInR5cGUiOiJhY2Nlc3MifQ.Y9wb4u3gyR9Dn_ziFOeb6Qpgy2fz8LfqxTletIKx5s8', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiNDc4YzQyMDUtYzcxMC00MTNmLThmNjQtMDlkMTRkOTg0ZWY1IiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzMzM1MjJ9.GntJRERGV9JsE00QdQjuFZ2_Kl08PpkkBauo22CuvqI', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
________ ERROR at setup of TestQueueBatchAPI.test_invalid_source_error ________

self = <sqlalchemy.engine.base.Connection object at 0x000001B6E9DDAD90>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA5472D0>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6EAECE240>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA5472D0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9CA4E50>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6EAECE240>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA5472D0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NDMzMjMsInR5cGUiOiJhY2Nlc3MifQ.PKdXUg24vj9B2A_83vBqzMwP-w1IJl0j7-IENx8zFio', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiODFmYTkwYjktNzExMC00YjQwLTk5ODYtYTA3Yjc0YThmNTU1IiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzMzM1MjN9.zinGwaJRGBdzU6KtnaGOGbV116IM83SiYi_CmTxAxEI', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
________ ERROR at setup of TestQueueBatchAPI.test_admin_access_allowed ________

self = <sqlalchemy.engine.base.Connection object at 0x000001B6EA6A9BD0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA5654D0>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6E9CF7040>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA5654D0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6EA32C250>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6E9CF7040>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA5654D0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMyMywidHlwZSI6ImFjY2VzcyJ9.B9ICnM3PNZGlGD1PqozuaWWMXi1xxnNTze-BbacSVaQ', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiIzZWNmMTgzZC04ODRkLTQ0OWQtODZjMC03ZDZmZDJiYTQzNWQiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzUyM30.wau9WUCF8OV9XfILhNRmffJGhkLXP0e93wouuKQMyRs', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
______ ERROR at setup of TestQueueBatchAPI.test_registrar_access_allowed ______

self = <sqlalchemy.engine.base.Connection object at 0x000001B6EA3F65D0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA482150>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6EA1BE040>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA482150>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9F2A6D0>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6EA1BE040>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA482150>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NDMzMjQsInR5cGUiOiJhY2Nlc3MifQ.aVbp_FJnrmZUEvYf9PHFvx3RMRKh-E2bE3de-AAbllw', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiNzVkZThmZDQtYmI3My00YmYwLTgwMjctYzdmMzVjODgxYjUxIiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzMzM1MjR9.qSmLFiOXKPINpp1oFCicxUCQWDOOaEOjTZ3bQS6gbqs', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
________ ERROR at setup of TestQueueBatchAPI.test_doctor_access_denied ________

self = <sqlalchemy.engine.base.Connection object at 0x000001B6EA121B50>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA2C8DD0>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6EA4407C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA2C8DD0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6EA5525D0>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6EA4407C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EA2C8DD0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_cardio
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 5, 'username': 'test_cardio', 'full_name': 'Test Cardiologist', 'email': 'cardio@test.com', 'role': 'cardio', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1IiwidXNlcm5hbWUiOiJ0ZXN0X2NhcmRpbyIsInJvbGUiOiJjYXJkaW8iLCJpc19hY3RpdmUiOnRydWUsImlzX3N1cGVydXNlciI6ZmFsc2UsImV4cCI6MTc2NTc0MzMyNCwidHlwZSI6ImFjY2VzcyJ9.d4N3dMHbfwzKdGlL4Dr4hXwA_z0n1QIVempUngbk4bQ', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo1LCJqdGkiOiI4ZjA4NzZjYi00NDA4LTRkZTItOTIyYS04ODgyNTlhNGRkMjYiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzUyNH0.MZU-KkzbtOIiiobXOkmxP_MvWA43F4AAKWQ5PZK7y4g', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
___ ERROR at setup of TestQueueBatchAPI.test_unauthenticated_access_denied ____

self = <sqlalchemy.engine.base.Connection object at 0x000001B6EA51F1D0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6E9B78D50>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6EA272DC0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6E9B78D50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9F8D290>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6EA272DC0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6E9B78D50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
________ ERROR at setup of TestQueueBatchAPI.test_fair_queue_numbering ________

self = <sqlalchemy.engine.base.Connection object at 0x000001B6E9DDA7D0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EAA58FD0>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6EA05A5C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EAA58FD0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9C8ED90>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000001B6E8029B90>
cursor = <sqlite3.Cursor object at 0x000001B6EA05A5C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000001B6EAA58FD0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NDMzMjUsInR5cGUiOiJhY2Nlc3MifQ.yFDHchBBRVW5iM2MBf-MuOZU0ssijj6Fdm3W4ttsxQU', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiNmZhYzdlNTEtYzIwYS00MTgzLTk2OTktMWQzNThkZTA0ZWU1IiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzMzM1MjV9.JrEbQpfmtsLfF3OEGEo7u9zuXbRTBmCOoRkMj8MXTgU', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
___ ERROR at setup of TestVisitConfirmationAPI.test_get_visit_info_success ____

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_get_visit_info_success>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6EA673550>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_get_visit_info_expired_token _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_get_visit_info_expired_token>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6EA46A110>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_telegram_success _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_telegram_success>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6EA2CA1D0>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_telegram_wrong_channel _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_telegram_wrong_channel>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6EA511950>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
__ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_pwa_success __

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_pwa_success>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6EAA6B010>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_pwa_phone_mismatch _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_pwa_phone_mismatch>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6EA5171D0>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_registrar_success _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_registrar_success>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6EA5A11D0>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_registrar_unauthorized _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_registrar_unauthorized>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6E9DB7190>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_registrar_wrong_role _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_registrar_wrong_role>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6E9A36750>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_creates_queue_entry_today _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_creates_queue_entry_today>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6EA123310>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_no_queue_entry_future_date _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_no_queue_entry_future_date>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6EA481DD0>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_updates_status _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_updates_status>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6E9F2A6D0>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_rate_limiting _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_rate_limiting>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6EA469210>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestVisitConfirmationAPI.test_confirm_visit_security_validation _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_confirm_visit_security_validation>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6E9D45110>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestConfirmationSecurityService.test_validate_confirmation_request_valid_token _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_validate_confirmation_request_valid_token>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6EA6E4E10>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestConfirmationSecurityService.test_validate_confirmation_request_expired_token _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_validate_confirmation_request_expired_token>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6EA7EC190>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestConfirmationSecurityService.test_validate_confirmation_request_wrong_status _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_validate_confirmation_request_wrong_status>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6EA544C10>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestConfirmationSecurityService.test_validate_confirmation_request_suspicious_user_agent _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_validate_confirmation_request_suspicious_user_agent>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6E99D9D10>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestConfirmationSecurityService.test_record_confirmation_attempt_success _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_record_confirmation_attempt_success>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6EA179F10>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestConfirmationSecurityService.test_record_confirmation_attempt_failure _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_record_confirmation_attempt_failure>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6EAA3A510>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestConfirmationSecurityService.test_logging_security_events _

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_logging_security_events>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6E9D12750>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestMigrationService.test_check_data_integrity_with_data __

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_check_data_integrity_with_data>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6EA771190>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___ ERROR at setup of TestMigrationService.test_backup_queue_data_with_data ___

fixturedef = <FixtureDef argname='test_doctor' scope='function' baseid='tests'>
request = <SubRequest 'test_doctor' for <Function test_backup_queue_data_with_data>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:232: in test_doctor
    doctor = Doctor(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.clinic.Doctor object at 0x000001B6E9D3EC90>
kwargs = {'bio': '╥хёЄют√щ ърЁфшюыюу', 'experience_years': 10, 'is_active': True, 'license_number': 'TEST123', ...}
cls_ = <class 'app.models.clinic.Doctor'>, k = 'license_number'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'license_number' is an invalid keyword argument for Doctor

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
================================== FAILURES ===================================
___________________ TestAPIIntegration.test_health_endpoint ___________________

self = <urllib3.connection.HTTPConnection object at 0x000001B6E7C86E50>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
>           sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:85: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('127.0.0.1', 8000), timeout = 30, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address: tuple[str, int],
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        source_address: tuple[str, int] | None = None,
        socket_options: _TYPE_SOCKET_OPTIONS | None = None,
    ) -> socket.socket:
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            raise LocationParseError(f"'{host}', label empty or too long") from None
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not _DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:73: ConnectionRefusedError

The above exception was the direct cause of the following exception:

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001B6E787A410>
method = 'GET', url = '/api/v1/health', body = None
headers = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate, br', 'Accept': '*/*', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=30, read=30, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None, preload_content = False
decode_content = False, response_kw = {}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v1/health', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(  # type: ignore[override]
        self,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | bool | int | None = None,
        redirect: bool = True,
        assert_same_host: bool = True,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        pool_timeout: int | None = None,
        release_conn: bool | None = None,
        chunked: bool = False,
        body_pos: _TYPE_BODY_POSITION | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        **response_kw: typing.Any,
    ) -> BaseHTTPResponse:
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method
           such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param bool preload_content:
            If True, the response's body will be preloaded into memory.
    
        :param bool decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of ``preload_content``
            which defaults to ``True``.
    
        :param bool chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
        """
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = preload_content
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = to_str(_encode_target(url))
        else:
            url = to_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()  # type: ignore[attr-defined]
            headers.update(self.proxy_headers)  # type: ignore[union-attr]
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]
    
            # Is this a closed/new connection that requires CONNECT tunnelling?
            if self.proxy is not None and http_tunnel_required and conn.is_closed:
                try:
                    self._prepare_proxy(conn)
                except (BaseSSLError, OSError, SocketTimeout) as e:
                    self._raise_timeout(
                        err=e, url=self.proxy.url, timeout_value=conn.timeout
                    )
                    raise
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Make the request on the HTTPConnection object
>           response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
                retries=retries,
                response_conn=response_conn,
                preload_content=preload_content,
                decode_content=decode_content,
                **response_kw,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:493: in _make_request
    conn.request(
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:494: in request
    self.endheaders()
C:\Program Files\Python311\Lib\http\client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
C:\Program Files\Python311\Lib\http\client.py:1037: in _send_output
    self.send(msg)
C:\Program Files\Python311\Lib\http\client.py:975: in send
    self.connect()
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:325: in connect
    self.sock = self._new_conn()
                ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <urllib3.connection.HTTPConnection object at 0x000001B6E7C86E50>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
            sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )
        except socket.gaierror as e:
            raise NameResolutionError(self.host, self, e) from e
        except SocketTimeout as e:
            raise ConnectTimeoutError(
                self,
                f"Connection to {self.host} timed out. (connect timeout={self.timeout})",
            ) from e
    
        except OSError as e:
>           raise NewConnectionError(
                self, f"Failed to establish a new connection: {e}"
            ) from e
E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x000001B6E7C86E50>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:213: NewConnectionError

The above exception was the direct cause of the following exception:

self = <requests.adapters.HTTPAdapter object at 0x000001B6E7A194D0>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
>           resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:486: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:841: in urlopen
    retries = retries.increment(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'GET', url = '/api/v1/health', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001B6E7C86E50>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001B6E787A410>
_stacktrace = <traceback object at 0x000001B6E7C87500>

    def increment(
        self,
        method: str | None = None,
        url: str | None = None,
        response: BaseHTTPResponse | None = None,
        error: Exception | None = None,
        _pool: ConnectionPool | None = None,
        _stacktrace: TracebackType | None = None,
    ) -> Self:
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.BaseHTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or method is None or not self._is_method_retryable(method):
                raise reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            response_redirect_location = response.get_redirect_location()
            if response_redirect_location:
                redirect_location = response_redirect_location
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
            reason = error or ResponseError(cause)
>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/health (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001B6E7C86E50>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\urllib3\util\retry.py:519: MaxRetryError

During handling of the above exception, another exception occurred:

self = <test_api_integration.TestAPIIntegration object at 0x000001B6E37DE050>

    def test_health_endpoint(self):
        """╥хёЄ health endpoint"""
>       response = requests.get(f"{self.base_url}/api/v1/health", timeout=self.timeout)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\integration\test_api_integration.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\requests\api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:703: in send
    r = adapter.send(request, **kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <requests.adapters.HTTPAdapter object at 0x000001B6E7A194D0>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/health (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001B6E7C86E50>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:519: ConnectionError
___________________ TestAPIIntegration.test_status_endpoint ___________________

self = <urllib3.connection.HTTPConnection object at 0x000001B6E8417890>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
>           sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:85: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('127.0.0.1', 8000), timeout = 30, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address: tuple[str, int],
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        source_address: tuple[str, int] | None = None,
        socket_options: _TYPE_SOCKET_OPTIONS | None = None,
    ) -> socket.socket:
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            raise LocationParseError(f"'{host}', label empty or too long") from None
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not _DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:73: ConnectionRefusedError

The above exception was the direct cause of the following exception:

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001B6E84176D0>
method = 'GET', url = '/api/v1/status', body = None
headers = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate, br', 'Accept': '*/*', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=30, read=30, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None, preload_content = False
decode_content = False, response_kw = {}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v1/status', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(  # type: ignore[override]
        self,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | bool | int | None = None,
        redirect: bool = True,
        assert_same_host: bool = True,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        pool_timeout: int | None = None,
        release_conn: bool | None = None,
        chunked: bool = False,
        body_pos: _TYPE_BODY_POSITION | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        **response_kw: typing.Any,
    ) -> BaseHTTPResponse:
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method
           such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param bool preload_content:
            If True, the response's body will be preloaded into memory.
    
        :param bool decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of ``preload_content``
            which defaults to ``True``.
    
        :param bool chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
        """
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = preload_content
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = to_str(_encode_target(url))
        else:
            url = to_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()  # type: ignore[attr-defined]
            headers.update(self.proxy_headers)  # type: ignore[union-attr]
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]
    
            # Is this a closed/new connection that requires CONNECT tunnelling?
            if self.proxy is not None and http_tunnel_required and conn.is_closed:
                try:
                    self._prepare_proxy(conn)
                except (BaseSSLError, OSError, SocketTimeout) as e:
                    self._raise_timeout(
                        err=e, url=self.proxy.url, timeout_value=conn.timeout
                    )
                    raise
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Make the request on the HTTPConnection object
>           response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
                retries=retries,
                response_conn=response_conn,
                preload_content=preload_content,
                decode_content=decode_content,
                **response_kw,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:493: in _make_request
    conn.request(
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:494: in request
    self.endheaders()
C:\Program Files\Python311\Lib\http\client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
C:\Program Files\Python311\Lib\http\client.py:1037: in _send_output
    self.send(msg)
C:\Program Files\Python311\Lib\http\client.py:975: in send
    self.connect()
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:325: in connect
    self.sock = self._new_conn()
                ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <urllib3.connection.HTTPConnection object at 0x000001B6E8417890>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
            sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )
        except socket.gaierror as e:
            raise NameResolutionError(self.host, self, e) from e
        except SocketTimeout as e:
            raise ConnectTimeoutError(
                self,
                f"Connection to {self.host} timed out. (connect timeout={self.timeout})",
            ) from e
    
        except OSError as e:
>           raise NewConnectionError(
                self, f"Failed to establish a new connection: {e}"
            ) from e
E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x000001B6E8417890>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:213: NewConnectionError

The above exception was the direct cause of the following exception:

self = <requests.adapters.HTTPAdapter object at 0x000001B6E8415F10>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
>           resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:486: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:841: in urlopen
    retries = retries.increment(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'GET', url = '/api/v1/status', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001B6E8417890>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001B6E84176D0>
_stacktrace = <traceback object at 0x000001B6E8417840>

    def increment(
        self,
        method: str | None = None,
        url: str | None = None,
        response: BaseHTTPResponse | None = None,
        error: Exception | None = None,
        _pool: ConnectionPool | None = None,
        _stacktrace: TracebackType | None = None,
    ) -> Self:
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.BaseHTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or method is None or not self._is_method_retryable(method):
                raise reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            response_redirect_location = response.get_redirect_location()
            if response_redirect_location:
                redirect_location = response_redirect_location
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
            reason = error or ResponseError(cause)
>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/status (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001B6E8417890>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\urllib3\util\retry.py:519: MaxRetryError

During handling of the above exception, another exception occurred:

self = <test_api_integration.TestAPIIntegration object at 0x000001B6E7AB99D0>

    def test_status_endpoint(self):
        """╥хёЄ status endpoint"""
>       response = requests.get(f"{self.base_url}/api/v1/status", timeout=self.timeout)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\integration\test_api_integration.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\requests\api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:703: in send
    r = adapter.send(request, **kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <requests.adapters.HTTPAdapter object at 0x000001B6E8415F10>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/status (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001B6E8417890>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:519: ConnectionError
_________________ TestAPIIntegration.test_api_responsiveness __________________

self = <urllib3.connection.HTTPConnection object at 0x000001B6E842B8D0>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
>           sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:85: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('127.0.0.1', 8000), timeout = 30, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address: tuple[str, int],
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        source_address: tuple[str, int] | None = None,
        socket_options: _TYPE_SOCKET_OPTIONS | None = None,
    ) -> socket.socket:
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            raise LocationParseError(f"'{host}', label empty or too long") from None
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not _DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:73: ConnectionRefusedError

The above exception was the direct cause of the following exception:

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001B6E842B310>
method = 'GET', url = '/api/v1/health', body = None
headers = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate, br', 'Accept': '*/*', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=30, read=30, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None, preload_content = False
decode_content = False, response_kw = {}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v1/health', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(  # type: ignore[override]
        self,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | bool | int | None = None,
        redirect: bool = True,
        assert_same_host: bool = True,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        pool_timeout: int | None = None,
        release_conn: bool | None = None,
        chunked: bool = False,
        body_pos: _TYPE_BODY_POSITION | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        **response_kw: typing.Any,
    ) -> BaseHTTPResponse:
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method
           such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param bool preload_content:
            If True, the response's body will be preloaded into memory.
    
        :param bool decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of ``preload_content``
            which defaults to ``True``.
    
        :param bool chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
        """
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = preload_content
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = to_str(_encode_target(url))
        else:
            url = to_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()  # type: ignore[attr-defined]
            headers.update(self.proxy_headers)  # type: ignore[union-attr]
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]
    
            # Is this a closed/new connection that requires CONNECT tunnelling?
            if self.proxy is not None and http_tunnel_required and conn.is_closed:
                try:
                    self._prepare_proxy(conn)
                except (BaseSSLError, OSError, SocketTimeout) as e:
                    self._raise_timeout(
                        err=e, url=self.proxy.url, timeout_value=conn.timeout
                    )
                    raise
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Make the request on the HTTPConnection object
>           response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
                retries=retries,
                response_conn=response_conn,
                preload_content=preload_content,
                decode_content=decode_content,
                **response_kw,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:493: in _make_request
    conn.request(
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:494: in request
    self.endheaders()
C:\Program Files\Python311\Lib\http\client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
C:\Program Files\Python311\Lib\http\client.py:1037: in _send_output
    self.send(msg)
C:\Program Files\Python311\Lib\http\client.py:975: in send
    self.connect()
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:325: in connect
    self.sock = self._new_conn()
                ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <urllib3.connection.HTTPConnection object at 0x000001B6E842B8D0>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
            sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )
        except socket.gaierror as e:
            raise NameResolutionError(self.host, self, e) from e
        except SocketTimeout as e:
            raise ConnectTimeoutError(
                self,
                f"Connection to {self.host} timed out. (connect timeout={self.timeout})",
            ) from e
    
        except OSError as e:
>           raise NewConnectionError(
                self, f"Failed to establish a new connection: {e}"
            ) from e
E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x000001B6E842B8D0>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:213: NewConnectionError

The above exception was the direct cause of the following exception:

self = <requests.adapters.HTTPAdapter object at 0x000001B6E842A1D0>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
>           resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:486: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:841: in urlopen
    retries = retries.increment(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'GET', url = '/api/v1/health', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001B6E842B8D0>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001B6E842B310>
_stacktrace = <traceback object at 0x000001B6E842B6C0>

    def increment(
        self,
        method: str | None = None,
        url: str | None = None,
        response: BaseHTTPResponse | None = None,
        error: Exception | None = None,
        _pool: ConnectionPool | None = None,
        _stacktrace: TracebackType | None = None,
    ) -> Self:
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.BaseHTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or method is None or not self._is_method_retryable(method):
                raise reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            response_redirect_location = response.get_redirect_location()
            if response_redirect_location:
                redirect_location = response_redirect_location
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
            reason = error or ResponseError(cause)
>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/health (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001B6E842B8D0>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\urllib3\util\retry.py:519: MaxRetryError

During handling of the above exception, another exception occurred:

self = <test_api_integration.TestAPIIntegration object at 0x000001B6E7ABA190>

    def test_api_responsiveness(self):
        """╥хёЄ юЄч√тўштюёЄш API"""
        start_time = time.time()
>       response = requests.get(f"{self.base_url}/api/v1/health", timeout=self.timeout)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\integration\test_api_integration.py:30: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\requests\api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:703: in send
    r = adapter.send(request, **kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <requests.adapters.HTTPAdapter object at 0x000001B6E842A1D0>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/health (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001B6E842B8D0>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:519: ConnectionError
______________ TestE2EMigrationFlow.test_complete_migration_flow ______________

self = <test_e2e_migration_flow.TestE2EMigrationFlow object at 0x000001B6E7BFC190>
client = <starlette.testclient.TestClient object at 0x000001B6E998EC10>
db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E8195890>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxMiwidHlwZSI6ImFjY2VzcyJ9.uGsLUebBQ6Ykw0zW8pdxS11pCZ0_kUsvjkItNIupIds'}
cardio_user = <app.models.user.User object at 0x000001B6E9A6CFD0>
test_patient = <app.models.patient.Patient object at 0x000001B6E9BB3790>

    def test_complete_migration_flow(self, client, db_session, auth_headers, cardio_user, test_patient):
        """
        ╧юыэ√щ E2E ЄхёЄ ьшуЁрЎшш:
        \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 \u2192 \u0420\u0435\u0437\u0435\u0440\u0432\u043d\u043e\u0435 \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u2192 \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0446\u0435\u043b\u043e\u0441\u0442\u043d\u043e\u0441\u0442\u0438 \u2192 \u041e\u0447\u0438\u0441\u0442\u043a\u0430
        """
        # ╪└├ 1: ╤ючфрхь ЄхёЄют√х фрээ√х юўхЁхфхщ
        test_date = date.today()
    
        # ╤ючфрхь фэхтэє■ юўхЁхф№
        daily_queue = DailyQueue(
            day=test_date,
            specialist_id=cardio_user.id,
            queue_tag="test_migration_queue",
            active=True,
            opened_at=datetime.utcnow()
        )
        db_session.add(daily_queue)
        db_session.commit()
    
        # ╤ючфрхь чряшёш т юўхЁхфш
        queue_entries = []
        for i in range(3):
            entry = OnlineQueueEntry(
                queue_id=daily_queue.id,
                number=i + 1,
                patient_id=test_patient.id if i == 0 else None,
                patient_name=f"╥хёЄют√щ ╧рЎшхэЄ {i + 1}",
                phone=f"+99890123456{i}",
                telegram_id=123456789 + i,
                source="test_migration",
                status="waiting" if i < 2 else "served"
            )
            queue_entries.append(entry)
            db_session.add(entry)
    
        db_session.commit()
    
        # ╪└├ 2: ╧ЁютхЁ хь ёюёЄю эшх ёшёЄхь√ ьшуЁрЎшщ
        health_response = client.get("/api/v1/admin/migration/health", headers=auth_headers)
        assert health_response.status_code == 200
    
        health_data = health_response.json()
>       assert health_data["healthy"] is True
E       assert False is True

tests\integration\test_e2e_migration_flow.py:63: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxMiwidHlwZSI6ImFjY2VzcyJ9.uGsLUebBQ6Ykw0zW8pdxS11pCZ0_kUsvjkItNIupIds', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiI4NjM3Y2RhMS0xNDVmLTQyNmItOGViMS1jMGZkMzAzYzI1MjMiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzUxMn0.z1MHYWXAy4BGiHrZNgBQZUpwFA-iJ3cuw3fSM0F-uCI', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
__________ TestE2EMigrationFlow.test_migration_with_old_data_cleanup __________

self = <test_e2e_migration_flow.TestE2EMigrationFlow object at 0x000001B6E7BFC850>
client = <starlette.testclient.TestClient object at 0x000001B6E9CA4B50>
db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9CA4F90>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxMiwidHlwZSI6ImFjY2VzcyJ9.uGsLUebBQ6Ykw0zW8pdxS11pCZ0_kUsvjkItNIupIds'}
cardio_user = <app.models.user.User object at 0x000001B6E9BC3AD0>

    def test_migration_with_old_data_cleanup(self, client, db_session, auth_headers, cardio_user):
        """
        E2E ЄхёЄ ё юўшёЄъющ ёЄрЁ√ї фрээ√ї:
        \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0441\u0442\u0430\u0440\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u2192 \u041e\u0447\u0438\u0441\u0442\u043a\u0430 \u2192 \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430
        """
        # ╪└├ 1: ╤ючфрхь ёЄрЁ√х фрээ√х (40 фэхщ эрчрф)
        old_date = date.today() - timedelta(days=40)
    
        old_queue = DailyQueue(
            day=old_date,
            specialist_id=cardio_user.id,
            queue_tag="old_test_queue",
            active=False
        )
        db_session.add(old_queue)
        db_session.commit()
    
        # ─юсрты хь чряшёш т ёЄрЁє■ юўхЁхф№
        for i in range(2):
            entry = OnlineQueueEntry(
                queue_id=old_queue.id,
                number=i + 1,
                patient_name=f"╤ЄрЁ√щ ╧рЎшхэЄ {i + 1}",
                phone=f"+99890111111{i}",
                source="old_test_data",
                status="served"
            )
            db_session.add(entry)
    
        db_session.commit()
    
        # ╪└├ 2: ╤ючфрхь эют√х фрээ√х (ёхуюфэ )
        new_queue = DailyQueue(
            day=date.today(),
            specialist_id=cardio_user.id,
            queue_tag="new_test_queue",
            active=True
        )
        db_session.add(new_queue)
        db_session.commit()
    
        new_entry = OnlineQueueEntry(
            queue_id=new_queue.id,
            number=1,
            patient_name="═ют√щ ╧рЎшхэЄ",
            phone="+998901234567",
            source="new_test_data",
            status="waiting"
        )
        db_session.add(new_entry)
        db_session.commit()
    
        # ╪└├ 3: ╧юыєўрхь ёЄрЄшёЄшъє фю юўшёЄъш
        stats_before = client.get("/api/v1/admin/migration/stats", headers=auth_headers)
        assert stats_before.status_code == 200
    
        stats_before_data = stats_before.json()
        queues_before = stats_before_data["queue_statistics"]["total_queues"]
        entries_before = stats_before_data["entry_statistics"]["total_entries"]
    
        # ╪└├ 4: ╟ряєёърхь юўшёЄъє ёЄрЁ√ї фрээ√ї (юёЄрты хь 30 фэхщ)
        cleanup_response = client.post(
            "/api/v1/admin/migration/cleanup-old-data?days_to_keep=30",
            headers=auth_headers
        )
    
        assert cleanup_response.status_code == 200
        cleanup_data = cleanup_response.json()
    
        assert cleanup_data["success"] is True
        assert cleanup_data["deleted_queues"] >= 1
        assert cleanup_data["deleted_entries"] >= 2
    
        cutoff_date = datetime.fromisoformat(cleanup_data["cutoff_date"]).date()
        expected_cutoff = date.today() - timedelta(days=30)
        assert cutoff_date == expected_cutoff
    
        # ╪└├ 5: ╧ЁютхЁ хь ўЄю ёЄрЁ√х фрээ√х єфрышышё№
        remaining_old_queues = db_session.query(DailyQueue).filter(
            DailyQueue.day < cutoff_date
        ).count()
        assert remaining_old_queues == 0
    
        # ╪└├ 6: ╧ЁютхЁ хь ўЄю эют√х фрээ√х юёЄрышё№
        remaining_new_queues = db_session.query(DailyQueue).filter(
            DailyQueue.day >= cutoff_date
        ).count()
        assert remaining_new_queues >= 1
    
        # ╪└├ 7: ╧юыєўрхь ёЄрЄшёЄшъє яюёых юўшёЄъш
        stats_after = client.get("/api/v1/admin/migration/stats", headers=auth_headers)
        assert stats_after.status_code == 200
    
        stats_after_data = stats_after.json()
        queues_after = stats_after_data["queue_statistics"]["total_queues"]
        entries_after = stats_after_data["entry_statistics"]["total_entries"]
    
        # ╧ЁютхЁ хь ўЄю ъюышўхёЄтю єьхэ№°шыюё№
        assert queues_after < queues_before
>       assert entries_after < entries_before
E       assert 6 < 6

tests\integration\test_e2e_migration_flow.py:276: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxMiwidHlwZSI6ImFjY2VzcyJ9.uGsLUebBQ6Ykw0zW8pdxS11pCZ0_kUsvjkItNIupIds', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiJkMWU5ZjM0MC01ZWM1LTQxMzMtOTcyNi05OTgwOTU3ZDQxZjIiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzUxMn0.TtUpU1j4ZHH3NUNDidj8QhOV3uHhDHkDThkflOTgyqM', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
_______ TestE2EMigrationFlow.test_migration_service_direct_integration ________

self = <test_e2e_migration_flow.TestE2EMigrationFlow object at 0x000001B6E7BFD050>
db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9C98650>
cardio_user = <app.models.user.User object at 0x000001B6E802AB90>
test_patient = <app.models.patient.Patient object at 0x000001B6E9CA6210>

    def test_migration_service_direct_integration(self, db_session, cardio_user, test_patient):
        """
        E2E ЄхёЄ яЁ ьюую шёяюы№чютрэш  MigrationService
        """
        # ╪└├ 1: ╤ючфрхь ёхЁтшё ьшуЁрЎшщ
        migration_service = MigrationService(db_session)
    
        # ╪└├ 2: ╤ючфрхь ЄхёЄют√х фрээ√х
        test_queue = DailyQueue(
            day=date.today(),
            specialist_id=cardio_user.id,
            queue_tag="direct_test_queue",
            active=True
        )
        db_session.add(test_queue)
        db_session.commit()
    
        test_entry = OnlineQueueEntry(
            queue_id=test_queue.id,
            number=1,
            patient_id=test_patient.id,
            patient_name=test_patient.short_name(),
            phone=test_patient.phone,
            source="direct_test",
            status="waiting"
        )
        db_session.add(test_entry)
        db_session.commit()
    
        # ╪└├ 3: ╧ЁютхЁ хь ЎхыюёЄэюёЄ№ фрээ√ї
        integrity_result = migration_service._check_data_integrity()
>       assert integrity_result["passed"] is True
E       assert False is True

tests\integration\test_e2e_migration_flow.py:316: AssertionError
_________ TestE2EMigrationFlow.test_error_recovery_in_migration_flow __________

self = <test_e2e_migration_flow.TestE2EMigrationFlow object at 0x000001B6E7BFC5D0>
client = <starlette.testclient.TestClient object at 0x000001B6E9C98990>
db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9B09BD0>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxMiwidHlwZSI6ImFjY2VzcyJ9.uGsLUebBQ6Ykw0zW8pdxS11pCZ0_kUsvjkItNIupIds'}

    def test_error_recovery_in_migration_flow(self, client, db_session, auth_headers):
        """
        E2E ЄхёЄ тюёёЄрэютыхэш  яюёых ю°шсюъ т яЁюЎхёёх ьшуЁрЎшш
        """
        # ╪└├ 1: ╧юя√Єър тюёёЄрэютыхэш  шч эхёє∙хёЄтє■∙хую Їрщыр
        restore_response = client.post(
            "/api/v1/admin/migration/restore-queue-data?backup_file=nonexistent.json",
            headers=auth_headers
        )
    
>       assert restore_response.status_code == 500
E       assert 200 == 500
E        +  where 200 = <Response [200 OK]>.status_code

tests\integration\test_e2e_migration_flow.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxMiwidHlwZSI6ImFjY2VzcyJ9.uGsLUebBQ6Ykw0zW8pdxS11pCZ0_kUsvjkItNIupIds', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiJjM2M5OTkwMS0zNTNjLTQ0OWQtOWFmNS0xNjI0ODMxM2ZlYzkiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzUxMn0.86oQFywMMcVuLPrMskLy-BFi5DuJOMJbaWID4-aysQU', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
---------------------------- Captured stderr call -----------------------------
ERROR:app.services.migration_service:╬°шсър тюёёЄрэютыхэш  фрээ√ї: [Errno 2] No such file or directory: 'nonexistent.json'
------------------------------ Captured log call ------------------------------
ERROR    app.services.migration_service:migration_service.py:499 ╬°шсър тюёёЄрэютыхэш  фрээ√ї: [Errno 2] No such file or directory: 'nonexistent.json'
__________ TestE2EMigrationFlow.test_concurrent_migration_operations __________

self = <test_e2e_migration_flow.TestE2EMigrationFlow object at 0x000001B6E7BF6A90>
client = <starlette.testclient.TestClient object at 0x000001B6E812F410>
db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E812E790>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxMiwidHlwZSI6ImFjY2VzcyJ9.uGsLUebBQ6Ykw0zW8pdxS11pCZ0_kUsvjkItNIupIds'}
cardio_user = <app.models.user.User object at 0x000001B6E9C9C6D0>

    def test_concurrent_migration_operations(self, client, db_session, auth_headers, cardio_user):
        """
        E2E ЄхёЄ ярЁрыыхы№э√ї юяхЁрЎшщ ьшуЁрЎшш
        """
        # ╪└├ 1: ╤ючфрхь фрээ√х фы  ЄхёЄшЁютрэш 
        test_queue = DailyQueue(
            day=date.today(),
            specialist_id=cardio_user.id,
            queue_tag="concurrent_test_queue",
            active=True
        )
        db_session.add(test_queue)
        db_session.commit()
    
        # ╪└├ 2: ╟ряєёърхь эхёъюы№ъю юяхЁрЎшщ ярЁрыыхы№эю
        # (┬ Ёхры№эюь ЄхёЄх ¤Єю с√ыю с√ ё threading, эю фы  яЁюёЄюЄ√ фхырхь яюёыхфютрЄхы№эю)
    
        # ╧ЁютхЁър ЎхыюёЄэюёЄш
        integrity_response = client.get("/api/v1/admin/migration/check-integrity", headers=auth_headers)
        assert integrity_response.status_code == 200
    
        # ╧юыєўхэшх ёЄрЄшёЄшъш
        stats_response = client.get("/api/v1/admin/migration/stats", headers=auth_headers)
        assert stats_response.status_code == 200
    
        # ╧ЁютхЁър чфюЁют№  ёшёЄхь√
        health_response = client.get("/api/v1/admin/migration/health", headers=auth_headers)
        assert health_response.status_code == 200
    
        # ╪└├ 3: ╧ЁютхЁ хь ўЄю тёх юяхЁрЎшш чртхЁ°шышё№ єёях°эю
>       assert integrity_response.json()["passed"] is True
E       assert False is True

tests\integration\test_e2e_migration_flow.py:425: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxMiwidHlwZSI6ImFjY2VzcyJ9.uGsLUebBQ6Ykw0zW8pdxS11pCZ0_kUsvjkItNIupIds', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiIxMWM1NGNkMC04MjY2LTQ3NGQtOTEzMC01ZjhkNWM5NTk1YzAiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzUxMn0.34uJQrXjUa8DY68hYfFr2rUbfB-8cBvtl9Y1dUzASDI', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
____________ TestPatientAuthFlow.test_unauthorized_access_rejected ____________

self = <test_e2e_patient_flow.TestPatientAuthFlow object at 0x000001B6E7B59E90>
client = <starlette.testclient.TestClient object at 0x000001B6E9B09AD0>

    def test_unauthorized_access_rejected(self, client: TestClient):
        """═хртЄюЁшчютрээ√щ фюёЄєя юЄъыюэ хЄё """
        response = client.get("/api/v1/patient/appointments")
>       assert response.status_code == 401
E       assert 404 == 401
E        +  where 404 = <Response [404 Not Found]>.status_code

tests\integration\test_e2e_patient_flow.py:312: AssertionError
_______________ TestPatientAuthFlow.test_invalid_token_rejected _______________

self = <test_e2e_patient_flow.TestPatientAuthFlow object at 0x000001B6E7B59290>
client = <starlette.testclient.TestClient object at 0x000001B6E9CA2410>

    def test_invalid_token_rejected(self, client: TestClient):
        """═хтрышфэ√щ Єюъхэ юЄъыюэ хЄё """
        response = client.get(
            "/api/v1/patient/appointments",
            headers={"Authorization": "Bearer invalid_token_here"},
        )
>       assert response.status_code in [401, 403]
E       assert 404 in [401, 403]
E        +  where 404 = <Response [404 Not Found]>.status_code

tests\integration\test_e2e_patient_flow.py:320: AssertionError
______________ TestPaymentSecurity.test_invalid_amount_rejected _______________
  + Exception Group Traceback (most recent call last):
  |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 76, in collapse_excgroups
  |     yield
  |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 177, in __call__
  |     async with anyio.create_task_group() as task_group:
  |   File "C:\Program Files\Python311\Lib\site-packages\anyio\_backends\_asyncio.py", line 772, in __aexit__
  |     raise BaseExceptionGroup(
  | ExceptionGroup: unhandled errors in a TaskGroup (1 sub-exception)
  +-+---------------- 1 ----------------
    | Traceback (most recent call last):
    |   File "C:\Program Files\Python311\Lib\site-packages\_pytest\runner.py", line 344, in from_call
    |     result: TResult | None = func()
    |                              ^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\_pytest\runner.py", line 246, in <lambda>
    |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_hooks.py", line 512, in __call__
    |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_manager.py", line 120, in _hookexec
    |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_callers.py", line 167, in _multicall
    |     raise exception
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |   File "C:\Program Files\Python311\Lib\site-packages\_pytest\logging.py", line 850, in pytest_runtest_call
    |     yield
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |   File "C:\Program Files\Python311\Lib\site-packages\_pytest\capture.py", line 900, in pytest_runtest_call
    |     return (yield)
    |             ^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |   File "C:\Program Files\Python311\Lib\site-packages\_pytest\skipping.py", line 263, in pytest_runtest_call
    |     return (yield)
    |             ^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_callers.py", line 121, in _multicall
    |     res = hook_impl.function(*args)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\_pytest\runner.py", line 178, in pytest_runtest_call
    |     item.runtest()
    |   File "C:\Program Files\Python311\Lib\site-packages\_pytest\python.py", line 1671, in runtest
    |     self.ihook.pytest_pyfunc_call(pyfuncitem=self)
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_hooks.py", line 512, in __call__
    |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_manager.py", line 120, in _hookexec
    |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_callers.py", line 167, in _multicall
    |     raise exception
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_callers.py", line 53, in run_old_style_hookwrapper
    |     return result.get_result()
    |            ^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_result.py", line 103, in get_result
    |     raise exc.with_traceback(tb)
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_callers.py", line 38, in run_old_style_hookwrapper
    |     res = yield
    |           ^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_callers.py", line 121, in _multicall
    |     res = hook_impl.function(*args)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\_pytest\python.py", line 157, in pytest_pyfunc_call
    |     result = testfunction(**testargs)
    |              ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\final\backend\tests\integration\test_e2e_payment_flow.py", line 258, in test_invalid_amount_rejected
    |     response = client.post(
    |                ^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py", line 538, in post
    |     return super().post(
    |            ^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 1157, in post
    |     return self.request(
    |            ^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py", line 437, in request
    |     return super().request(
    |            ^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 837, in request
    |     return self.send(request, auth=auth, follow_redirects=follow_redirects)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 926, in send
    |     response = self._send_handling_auth(
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 954, in _send_handling_auth
    |     response = self._send_handling_redirects(
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 991, in _send_handling_redirects
    |     response = self._send_single_request(request)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 1027, in _send_single_request
    |     response = transport.handle_request(request)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py", line 340, in handle_request
    |     raise exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py", line 337, in handle_request
    |     portal.call(self.app, scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\anyio\from_thread.py", line 291, in call
    |     return cast(T_Retval, self.start_task_soon(func, *args).result())
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\concurrent\futures\_base.py", line 456, in result
    |     return self.__get_result()
    |            ^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\concurrent\futures\_base.py", line 401, in __get_result
    |     raise self._exception
    |   File "C:\Program Files\Python311\Lib\site-packages\anyio\from_thread.py", line 222, in _call_func
    |     retval = await retval_or_awaitable
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\fastapi\applications.py", line 1054, in __call__
    |     await super().__call__(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\applications.py", line 112, in __call__
    |     await self.middleware_stack(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\errors.py", line 187, in __call__
    |     raise exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\errors.py", line 165, in __call__
    |     await self.app(scope, receive, _send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\cors.py", line 85, in __call__
    |     await self.app(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    |     with recv_stream, send_stream, collapse_excgroups():
    |   File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    |     self.gen.throw(typ, value, traceback)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    |     raise exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    |     response = await self.dispatch_func(request, call_next)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\final\backend\app\middleware\security_middleware.py", line 241, in dispatch
    |     return await call_next(request)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    |     raise app_exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    |     await self.app(scope, receive_or_disconnect, send_no_error)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    |     with recv_stream, send_stream, collapse_excgroups():
    |   File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    |     self.gen.throw(typ, value, traceback)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    |     raise exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    |     response = await self.dispatch_func(request, call_next)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\final\backend\app\middleware\audit_middleware.py", line 41, in dispatch
    |     response = await call_next(request)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    |     raise app_exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    |     await self.app(scope, receive_or_disconnect, send_no_error)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\exceptions.py", line 62, in __call__
    |     await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 53, in wrapped_app
    |     raise exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 42, in wrapped_app
    |     await app(scope, receive, sender)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 714, in __call__
    |     await self.middleware_stack(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 734, in app
    |     await route.handle(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 288, in handle
    |     await self.app(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 76, in app
    |     await wrap_app_handling_exceptions(app, request)(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 59, in wrapped_app
    |     response = await handler(conn, exc)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\final\backend\app\core\exception_handlers.py", line 221, in validation_exception_handler
    |     return JSONResponse(
    |            ^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 182, in __init__
    |     super().__init__(content, status_code, headers, media_type, background)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 45, in __init__
    |     self.body = self.render(content)
    |                 ^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 185, in render
    |     return json.dumps(
    |            ^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\__init__.py", line 238, in dumps
    |     **kw).encode(obj)
    |           ^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\encoder.py", line 200, in encode
    |     chunks = self.iterencode(o, _one_shot=True)
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\encoder.py", line 258, in iterencode
    |     return _iterencode(o, 0)
    |            ^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\encoder.py", line 180, in default
    |     raise TypeError(f'Object of type {o.__class__.__name__} '
    | TypeError: Object of type Decimal is not JSON serializable
    +------------------------------------

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\final\backend\tests\integration\test_e2e_payment_flow.py", line 258, in test_invalid_amount_rejected
    response = client.post(
               ^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py", line 538, in post
    return super().post(
           ^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 1157, in post
    return self.request(
           ^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py", line 437, in request
    return super().request(
           ^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 837, in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 926, in send
    response = self._send_handling_auth(
               ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 954, in _send_handling_auth
    response = self._send_handling_redirects(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 991, in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 1027, in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py", line 340, in handle_request
    raise exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py", line 337, in handle_request
    portal.call(self.app, scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\anyio\from_thread.py", line 291, in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\concurrent\futures\_base.py", line 456, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\concurrent\futures\_base.py", line 401, in __get_result
    raise self._exception
  File "C:\Program Files\Python311\Lib\site-packages\anyio\from_thread.py", line 222, in _call_func
    retval = await retval_or_awaitable
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\fastapi\applications.py", line 1054, in __call__
    await super().__call__(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\applications.py", line 112, in __call__
    await self.middleware_stack(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\errors.py", line 187, in __call__
    raise exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\errors.py", line 165, in __call__
    await self.app(scope, receive, _send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\cors.py", line 85, in __call__
    await self.app(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    with recv_stream, send_stream, collapse_excgroups():
  File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    self.gen.throw(typ, value, traceback)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    raise exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\final\backend\app\middleware\security_middleware.py", line 241, in dispatch
    return await call_next(request)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    raise app_exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    with recv_stream, send_stream, collapse_excgroups():
  File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    self.gen.throw(typ, value, traceback)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    raise exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\final\backend\app\middleware\audit_middleware.py", line 41, in dispatch
    response = await call_next(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    raise app_exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\exceptions.py", line 62, in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 714, in __call__
    await self.middleware_stack(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 734, in app
    await route.handle(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 288, in handle
    await self.app(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 76, in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 59, in wrapped_app
    response = await handler(conn, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\final\backend\app\core\exception_handlers.py", line 221, in validation_exception_handler
    return JSONResponse(
           ^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 182, in __init__
    super().__init__(content, status_code, headers, media_type, background)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 45, in __init__
    self.body = self.render(content)
                ^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 185, in render
    return json.dumps(
           ^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\__init__.py", line 238, in dumps
    **kw).encode(obj)
          ^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type Decimal is not JSON serializable

During handling of the above exception, another exception occurred:

self = <test_e2e_payment_flow.TestPaymentSecurity object at 0x000001B6E7BDC210>
client = <starlette.testclient.TestClient object at 0x000001B6E9C16590>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxNSwidHlwZSI6ImFjY2VzcyJ9.8Sfk97Kir6NVN_122JHkQ6ZfifyV4jsBb-FvW4ao7-k'}

    def test_invalid_amount_rejected(self, client: TestClient, auth_headers):
        """═хъюЁЁхъЄэр  ёєььр юЄъыюэ хЄё """
>       response = client.post(
            "/api/v1/payments/init",
            headers=auth_headers,
            json={
                "amount": -100,  # ╬ЄЁшЎрЄхы№эр  ёєььр
                "currency": "UZS",
                "provider": "click",
            },
        )

tests\integration\test_e2e_payment_flow.py:258: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py:538: in post
    return super().post(
C:\Program Files\Python311\Lib\site-packages\httpx\_client.py:1157: in post
    return self.request(
C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py:437: in request
    return super().request(
C:\Program Files\Python311\Lib\site-packages\httpx\_client.py:837: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\httpx\_client.py:926: in send
    response = self._send_handling_auth(
C:\Program Files\Python311\Lib\site-packages\httpx\_client.py:954: in _send_handling_auth
    response = self._send_handling_redirects(
C:\Program Files\Python311\Lib\site-packages\httpx\_client.py:991: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\httpx\_client.py:1027: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py:340: in handle_request
    raise exc
C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py:337: in handle_request
    portal.call(self.app, scope, receive, send)
C:\Program Files\Python311\Lib\site-packages\anyio\from_thread.py:291: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\concurrent\futures\_base.py:456: in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\concurrent\futures\_base.py:401: in __get_result
    raise self._exception
C:\Program Files\Python311\Lib\site-packages\anyio\from_thread.py:222: in _call_func
    retval = await retval_or_awaitable
             ^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\fastapi\applications.py:1054: in __call__
    await super().__call__(scope, receive, send)
C:\Program Files\Python311\Lib\site-packages\starlette\applications.py:112: in __call__
    await self.middleware_stack(scope, receive, send)
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\errors.py:187: in __call__
    raise exc
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\errors.py:165: in __call__
    await self.app(scope, receive, _send)
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\cors.py:85: in __call__
    await self.app(scope, receive, send)
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py:176: in __call__
    with recv_stream, send_stream, collapse_excgroups():
C:\Program Files\Python311\Lib\contextlib.py:155: in __exit__
    self.gen.throw(typ, value, traceback)
C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py:82: in collapse_excgroups
    raise exc
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py:178: in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
app\middleware\security_middleware.py:241: in dispatch
    return await call_next(request)
           ^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py:156: in call_next
    raise app_exc
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py:141: in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py:176: in __call__
    with recv_stream, send_stream, collapse_excgroups():
C:\Program Files\Python311\Lib\contextlib.py:155: in __exit__
    self.gen.throw(typ, value, traceback)
C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py:82: in collapse_excgroups
    raise exc
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py:178: in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
app\middleware\audit_middleware.py:41: in dispatch
    response = await call_next(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py:156: in call_next
    raise app_exc
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py:141: in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\exceptions.py:62: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
C:\Program Files\Python311\Lib\site-packages\starlette\routing.py:714: in __call__
    await self.middleware_stack(scope, receive, send)
C:\Program Files\Python311\Lib\site-packages\starlette\routing.py:734: in app
    await route.handle(scope, receive, send)
C:\Program Files\Python311\Lib\site-packages\starlette\routing.py:288: in handle
    await self.app(scope, receive, send)
C:\Program Files\Python311\Lib\site-packages\starlette\routing.py:76: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py:59: in wrapped_app
    response = await handler(conn, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^
app\core\exception_handlers.py:221: in validation_exception_handler
    return JSONResponse(
C:\Program Files\Python311\Lib\site-packages\starlette\responses.py:182: in __init__
    super().__init__(content, status_code, headers, media_type, background)
C:\Program Files\Python311\Lib\site-packages\starlette\responses.py:45: in __init__
    self.body = self.render(content)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\starlette\responses.py:185: in render
    return json.dumps(
C:\Program Files\Python311\Lib\json\__init__.py:238: in dumps
    **kw).encode(obj)
          ^^^^^^^^^^^
C:\Program Files\Python311\Lib\json\encoder.py:200: in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\json\encoder.py:258: in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <json.encoder.JSONEncoder object at 0x000001B6E9E6B290>, o = Decimal('0')

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return JSONEncoder.default(self, o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type Decimal is not JSON serializable

C:\Program Files\Python311\Lib\json\encoder.py:180: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxNSwidHlwZSI6ImFjY2VzcyJ9.8Sfk97Kir6NVN_122JHkQ6ZfifyV4jsBb-FvW4ao7-k', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiJkNmZiODhkOS0yOTgyLTQ2ZWUtOGEyYS05Yjg2ODA2ZjIzZTgiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzUxNX0.KTzeRQLbQ1f1fMLpBh3F2rjF4VdnYvsaq-5LpvkSXCs', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
---------------------------- Captured stderr call -----------------------------
WARNING:app.core.exception_handlers:RequestValidationError: [{'type': 'missing', 'loc': ('body', 'visit_id'), 'msg': 'Field required', 'input': {'amount': -100, 'currency': 'UZS', 'provider': 'click'}}, {'type': 'greater_than', 'loc': ('body', 'amount'), 'msg': 'Input should be greater than 0', 'input': -100, 'ctx': {'gt': Decimal('0')}}] (path: /api/v1/payments/init)
ERROR:app.core.exception_handlers:Unhandled exception: TypeError: Object of type Decimal is not JSON serializable (path: /api/v1/payments/init)
  + Exception Group Traceback (most recent call last):
  |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 76, in collapse_excgroups
  |     yield
  |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 177, in __call__
  |     async with anyio.create_task_group() as task_group:
  |   File "C:\Program Files\Python311\Lib\site-packages\anyio\_backends\_asyncio.py", line 772, in __aexit__
  |     raise BaseExceptionGroup(
  | ExceptionGroup: unhandled errors in a TaskGroup (1 sub-exception)
  +-+---------------- 1 ----------------
    | Traceback (most recent call last):
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\errors.py", line 165, in __call__
    |     await self.app(scope, receive, _send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\cors.py", line 85, in __call__
    |     await self.app(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    |     with recv_stream, send_stream, collapse_excgroups():
    |   File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    |     self.gen.throw(typ, value, traceback)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    |     raise exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    |     response = await self.dispatch_func(request, call_next)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\final\backend\app\middleware\security_middleware.py", line 241, in dispatch
    |     return await call_next(request)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    |     raise app_exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    |     await self.app(scope, receive_or_disconnect, send_no_error)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    |     with recv_stream, send_stream, collapse_excgroups():
    |   File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    |     self.gen.throw(typ, value, traceback)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    |     raise exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    |     response = await self.dispatch_func(request, call_next)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\final\backend\app\middleware\audit_middleware.py", line 41, in dispatch
    |     response = await call_next(request)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    |     raise app_exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    |     await self.app(scope, receive_or_disconnect, send_no_error)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\exceptions.py", line 62, in __call__
    |     await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 53, in wrapped_app
    |     raise exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 42, in wrapped_app
    |     await app(scope, receive, sender)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 714, in __call__
    |     await self.middleware_stack(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 734, in app
    |     await route.handle(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 288, in handle
    |     await self.app(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 76, in app
    |     await wrap_app_handling_exceptions(app, request)(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 59, in wrapped_app
    |     response = await handler(conn, exc)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\final\backend\app\core\exception_handlers.py", line 221, in validation_exception_handler
    |     return JSONResponse(
    |            ^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 182, in __init__
    |     super().__init__(content, status_code, headers, media_type, background)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 45, in __init__
    |     self.body = self.render(content)
    |                 ^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 185, in render
    |     return json.dumps(
    |            ^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\__init__.py", line 238, in dumps
    |     **kw).encode(obj)
    |           ^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\encoder.py", line 200, in encode
    |     chunks = self.iterencode(o, _one_shot=True)
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\encoder.py", line 258, in iterencode
    |     return _iterencode(o, 0)
    |            ^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\encoder.py", line 180, in default
    |     raise TypeError(f'Object of type {o.__class__.__name__} '
    | TypeError: Object of type Decimal is not JSON serializable
    +------------------------------------

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\errors.py", line 165, in __call__
    await self.app(scope, receive, _send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\cors.py", line 85, in __call__
    await self.app(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    with recv_stream, send_stream, collapse_excgroups():
  File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    self.gen.throw(typ, value, traceback)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    raise exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\final\backend\app\middleware\security_middleware.py", line 241, in dispatch
    return await call_next(request)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    raise app_exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    with recv_stream, send_stream, collapse_excgroups():
  File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    self.gen.throw(typ, value, traceback)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    raise exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\final\backend\app\middleware\audit_middleware.py", line 41, in dispatch
    response = await call_next(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    raise app_exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\exceptions.py", line 62, in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 714, in __call__
    await self.middleware_stack(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 734, in app
    await route.handle(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 288, in handle
    await self.app(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 76, in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 59, in wrapped_app
    response = await handler(conn, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\final\backend\app\core\exception_handlers.py", line 221, in validation_exception_handler
    return JSONResponse(
           ^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 182, in __init__
    super().__init__(content, status_code, headers, media_type, background)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 45, in __init__
    self.body = self.render(content)
                ^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 185, in render
    return json.dumps(
           ^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\__init__.py", line 238, in dumps
    **kw).encode(obj)
          ^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type Decimal is not JSON serializable
------------------------------ Captured log call ------------------------------
WARNING  app.core.exception_handlers:exception_handlers.py:216 RequestValidationError: [{'type': 'missing', 'loc': ('body', 'visit_id'), 'msg': 'Field required', 'input': {'amount': -100, 'currency': 'UZS', 'provider': 'click'}}, {'type': 'greater_than', 'loc': ('body', 'amount'), 'msg': 'Input should be greater than 0', 'input': -100, 'ctx': {'gt': Decimal('0')}}] (path: /api/v1/payments/init)
ERROR    app.core.exception_handlers:exception_handlers.py:237 Unhandled exception: TypeError: Object of type Decimal is not JSON serializable (path: /api/v1/payments/init)
  + Exception Group Traceback (most recent call last):
  |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 76, in collapse_excgroups
  |     yield
  |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 177, in __call__
  |     async with anyio.create_task_group() as task_group:
  |   File "C:\Program Files\Python311\Lib\site-packages\anyio\_backends\_asyncio.py", line 772, in __aexit__
  |     raise BaseExceptionGroup(
  | ExceptionGroup: unhandled errors in a TaskGroup (1 sub-exception)
  +-+---------------- 1 ----------------
    | Traceback (most recent call last):
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\errors.py", line 165, in __call__
    |     await self.app(scope, receive, _send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\cors.py", line 85, in __call__
    |     await self.app(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    |     with recv_stream, send_stream, collapse_excgroups():
    |   File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    |     self.gen.throw(typ, value, traceback)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    |     raise exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    |     response = await self.dispatch_func(request, call_next)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\final\backend\app\middleware\security_middleware.py", line 241, in dispatch
    |     return await call_next(request)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    |     raise app_exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    |     await self.app(scope, receive_or_disconnect, send_no_error)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    |     with recv_stream, send_stream, collapse_excgroups():
    |   File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    |     self.gen.throw(typ, value, traceback)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    |     raise exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    |     response = await self.dispatch_func(request, call_next)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\final\backend\app\middleware\audit_middleware.py", line 41, in dispatch
    |     response = await call_next(request)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    |     raise app_exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    |     await self.app(scope, receive_or_disconnect, send_no_error)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\exceptions.py", line 62, in __call__
    |     await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 53, in wrapped_app
    |     raise exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 42, in wrapped_app
    |     await app(scope, receive, sender)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 714, in __call__
    |     await self.middleware_stack(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 734, in app
    |     await route.handle(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 288, in handle
    |     await self.app(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 76, in app
    |     await wrap_app_handling_exceptions(app, request)(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 59, in wrapped_app
    |     response = await handler(conn, exc)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\final\backend\app\core\exception_handlers.py", line 221, in validation_exception_handler
    |     return JSONResponse(
    |            ^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 182, in __init__
    |     super().__init__(content, status_code, headers, media_type, background)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 45, in __init__
    |     self.body = self.render(content)
    |                 ^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 185, in render
    |     return json.dumps(
    |            ^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\__init__.py", line 238, in dumps
    |     **kw).encode(obj)
    |           ^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\encoder.py", line 200, in encode
    |     chunks = self.iterencode(o, _one_shot=True)
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\encoder.py", line 258, in iterencode
    |     return _iterencode(o, 0)
    |            ^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\encoder.py", line 180, in default
    |     raise TypeError(f'Object of type {o.__class__.__name__} '
    | TypeError: Object of type Decimal is not JSON serializable
    +------------------------------------

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\errors.py", line 165, in __call__
    await self.app(scope, receive, _send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\cors.py", line 85, in __call__
    await self.app(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    with recv_stream, send_stream, collapse_excgroups():
  File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    self.gen.throw(typ, value, traceback)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    raise exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\final\backend\app\middleware\security_middleware.py", line 241, in dispatch
    return await call_next(request)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    raise app_exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    with recv_stream, send_stream, collapse_excgroups():
  File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    self.gen.throw(typ, value, traceback)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    raise exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\final\backend\app\middleware\audit_middleware.py", line 41, in dispatch
    response = await call_next(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    raise app_exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\exceptions.py", line 62, in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 714, in __call__
    await self.middleware_stack(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 734, in app
    await route.handle(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 288, in handle
    await self.app(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 76, in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 59, in wrapped_app
    response = await handler(conn, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\final\backend\app\core\exception_handlers.py", line 221, in validation_exception_handler
    return JSONResponse(
           ^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 182, in __init__
    super().__init__(content, status_code, headers, media_type, background)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 45, in __init__
    self.body = self.render(content)
                ^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 185, in render
    return json.dumps(
           ^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\__init__.py", line 238, in dumps
    **kw).encode(obj)
          ^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type Decimal is not JSON serializable
____________ TestE2EVisitFlow.test_complete_visit_flow_future_date ____________

self = <test_e2e_visit_flow.TestE2EVisitFlow object at 0x000001B6E7BDE910>
client = <starlette.testclient.TestClient object at 0x000001B6EA950810>
db_session = <sqlalchemy.orm.session.Session object at 0x000001B6EA950610>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxNSwidHlwZSI6ImFjY2VzcyJ9.8Sfk97Kir6NVN_122JHkQ6ZfifyV4jsBb-FvW4ao7-k'}
test_patient = <app.models.patient.Patient object at 0x000001B6E7BEEBD0>

    def test_complete_visit_flow_future_date(self, client, db_session, auth_headers, test_patient):
        """
        E2E \u0442\u0435\u0441\u0442: \u0432\u0440\u0430\u0447 \u043d\u0430\u0437\u043d\u0430\u0447\u0438\u043b \u0432\u0438\u0437\u0438\u0442 \u043d\u0430 \u0437\u0430\u0432\u0442\u0440\u0430 \u2192 \u043f\u0430\u0446\u0438\u0435\u043d\u0442 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u043b \u2192 \u043d\u043e\u043c\u0435\u0440 \u041d\u0415 \u0432\u044b\u0434\u0430\u043d
        """
        # ╤ючфрхь єэшъры№эє■ єёыєує фы  ¤Єюую ЄхёЄр
        from app.models.service import Service
>       future_service = Service(
            code="FUTURE_TEST",
            name="┴єфє∙р  єёыєур",
            price=100000.00,
            queue_tag="cardiology_common",
            is_active=True
        )

tests\integration\test_e2e_visit_flow.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.service.Service object at 0x000001B6EA950650>
kwargs = {'code': 'FUTURE_TEST', 'is_active': True, 'name': '┴єфє∙р  єёыєур', 'price': 100000.0, ...}
cls_ = <class 'app.models.service.Service'>, k = 'is_active'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'is_active' is an invalid keyword argument for Service

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxNSwidHlwZSI6ImFjY2VzcyJ9.8Sfk97Kir6NVN_122JHkQ6ZfifyV4jsBb-FvW4ao7-k', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiJmYzAwMzZiOS1iYjdjLTQ2ZjUtODYwYS03NDg2ZjEzZjViNDQiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzUxNX0.7k9xSMc4nWkibw-blJ7M6Wtj00jIYSYG8uA9cQ5qQog', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
________________ TestE2EVisitFlow.test_morning_assignment_flow ________________

self = <test_e2e_visit_flow.TestE2EVisitFlow object at 0x000001B6E7BDEE10>
client = <starlette.testclient.TestClient object at 0x000001B6EA950CD0>
db_session = <sqlalchemy.orm.session.Session object at 0x000001B6EA9509D0>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxNiwidHlwZSI6ImFjY2VzcyJ9.9o1MhY4pU6Uyi6B9q2a-JePtIzRuFna4t5Mzk_XX3Xk'}
test_patient = <app.models.patient.Patient object at 0x000001B6E9BF4710>
admin_user = <app.models.user.User object at 0x000001B6E9F8C650>

    def test_morning_assignment_flow(self, client, db_session, auth_headers, test_patient, admin_user):
        """
        E2E \u0442\u0435\u0441\u0442 \u0443\u0442\u0440\u0435\u043d\u043d\u0435\u0433\u043e \u043f\u0440\u0438\u0441\u0432\u043e\u0435\u043d\u0438\u044f \u043d\u043e\u043c\u0435\u0440\u043e\u0432: \u0432\u0438\u0437\u0438\u0442 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d \u0432\u0447\u0435\u0440\u0430 \u2192 \u0443\u0442\u0440\u043e\u043c \u043d\u043e\u043c\u0435\u0440 \u0432\u044b\u0434\u0430\u043d
        """
        # ╤ючфрхь єэшъры№эє■ єёыєує фы  ¤Єюую ЄхёЄр
        from app.models.service import Service
>       morning_service = Service(
            code="MORNING_TEST",
            name="╙ЄЁхээ   єёыєур",
            price=75000.00,
            queue_tag="cardiology_common",
            is_active=True
        )

tests\integration\test_e2e_visit_flow.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.service.Service object at 0x000001B6EA950850>
kwargs = {'code': 'MORNING_TEST', 'is_active': True, 'name': '╙ЄЁхээ   єёыєур', 'price': 75000.0, ...}
cls_ = <class 'app.models.service.Service'>, k = 'is_active'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'is_active' is an invalid keyword argument for Service

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxNiwidHlwZSI6ImFjY2VzcyJ9.9o1MhY4pU6Uyi6B9q2a-JePtIzRuFna4t5Mzk_XX3Xk', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiJlMjczYzdhMy05MmY5LTQ5YzQtOWE2OS0xY2FlYTEyYWQ2YmIiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzUxNn0.3bDrJ-PQP-jwDB2W6Ol2LgqkFSXYXo8qKG1Gs0AeHgA', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
______________ TestE2EVisitFlow.test_registrar_confirmation_flow ______________

self = <test_e2e_visit_flow.TestE2EVisitFlow object at 0x000001B6E7BCBE90>
client = <starlette.testclient.TestClient object at 0x000001B6E9C5FAD0>
db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9CAA2D0>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxNiwidHlwZSI6ImFjY2VzcyJ9.9o1MhY4pU6Uyi6B9q2a-JePtIzRuFna4t5Mzk_XX3Xk'}
test_patient = <app.models.patient.Patient object at 0x000001B6EA50A110>
admin_user = <app.models.user.User object at 0x000001B6EA509850>

    def test_registrar_confirmation_flow(self, client, db_session, auth_headers, test_patient, admin_user):
        """
        E2E \u0442\u0435\u0441\u0442 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u043e\u043c: \u0432\u0438\u0437\u0438\u0442 \u0441\u043e\u0437\u0434\u0430\u043d \u2192 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u043b \u2192 \u043d\u043e\u043c\u0435\u0440 \u0432\u044b\u0434\u0430\u043d
        """
        # ╪└├ 1: ╤ючфрхь тшчшЄ юцшфр■∙шщ яюфЄтхЁцфхэш 
        visit = Visit(
            patient_id=test_patient.id,
            doctor_id=admin_user.id,
            visit_date=date.today(),
            visit_time="11:00",
            status="pending_confirmation",
            discount_mode="none",
            department="cardiology",
            confirmation_token="test-registrar-token",
            confirmation_channel="phone",
            confirmation_expires_at=datetime.utcnow() + timedelta(hours=24)
        )
        db_session.add(visit)
        db_session.commit()
    
        # ╪└├ 2: ╤ючфрхь фэхтэє■ юўхЁхф№
        daily_queue = DailyQueue(
            day=date.today(),
            specialist_id=visit.doctor_id,
            queue_tag="cardiology_common",
            active=True
        )
        db_session.add(daily_queue)
        db_session.commit()
    
        # ╪└├ 3: ╨хушёЄЁрЄюЁ яюфЄтхЁцфрхЄ тшчшЄ яю ЄхыхЇюэє
        confirm_response = client.post(
            f"/api/v1/registrar/visits/{visit.id}/confirm",
            json={
                "confirmation_notes": "╧юфЄтхЁцфхэю яю ЄхыхЇюэє +998901234567"
            },
            headers=auth_headers
        )
    
        assert confirm_response.status_code == 200
        confirm_data = confirm_response.json()
    
        assert confirm_data["success"] is True
        assert confirm_data["visit_id"] == visit.id
        assert confirm_data["status"] == "open"
    
        # ╪└├ 4: ╧ЁютхЁ хь ўЄю эюьхЁ т√фрэ
        assert "queue_numbers" in confirm_data
>       assert len(confirm_data["queue_numbers"]) > 0
E       assert 0 > 0
E        +  where 0 = len({})

tests\integration\test_e2e_visit_flow.py:322: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxNiwidHlwZSI6ImFjY2VzcyJ9.9o1MhY4pU6Uyi6B9q2a-JePtIzRuFna4t5Mzk_XX3Xk', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiJmN2Q2YmI4MS03NWM5LTQxMDItOWU4OS00MmMwMzA1MzAwMTQiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzUxNn0.UjYQl0sU1gu67DdLHm72Wr9h6F7yVt4Q0xhBLlKnl20', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
__________ TestE2EVisitFlow.test_multiple_services_queue_assignment ___________

self = <test_e2e_visit_flow.TestE2EVisitFlow object at 0x000001B6E7BC9690>
client = <starlette.testclient.TestClient object at 0x000001B6E9932A50>
db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9932890>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxNiwidHlwZSI6ImFjY2VzcyJ9.9o1MhY4pU6Uyi6B9q2a-JePtIzRuFna4t5Mzk_XX3Xk'}
test_patient = <app.models.patient.Patient object at 0x000001B6E9C54BD0>

    def test_multiple_services_queue_assignment(self, client, db_session, auth_headers, test_patient):
        """
        E2E ЄхёЄ ё эхёъюы№ъшьш єёыєурьш: Ёрчэ√х юўхЁхфш фы  Ёрчэ√ї єёыєу
        """
        # ╪└├ 1: ╤ючфрхь фюяюыэшЄхы№э√х єёыєуш ё єэшъры№э√ьш ъюфрьш
>       ecg_service = Service(
            code="ECG_MULTI_TEST",
            name="▌╩├ ьєы№Єш ЄхёЄ",
            price=50000.00,
            queue_tag="ecg",
            is_active=True
        )

tests\integration\test_e2e_visit_flow.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.service.Service object at 0x000001B6E9A6F4D0>
kwargs = {'code': 'ECG_MULTI_TEST', 'is_active': True, 'name': '▌╩├ ьєы№Єш ЄхёЄ', 'price': 50000.0, ...}
cls_ = <class 'app.models.service.Service'>, k = 'is_active'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'is_active' is an invalid keyword argument for Service

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxNiwidHlwZSI6ImFjY2VzcyJ9.9o1MhY4pU6Uyi6B9q2a-JePtIzRuFna4t5Mzk_XX3Xk', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiI1ZmUxZjNlNy1hZTU3LTQxZTAtYjE4OS03NzUwZWZjZGMxM2EiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzUxNn0.1wb1ah8afyy4psgjEXdwBEfif2g6s5C9GdYt_N01Whs', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
________________ TestE2EVisitFlow.test_error_handling_in_flow _________________

self = <test_e2e_visit_flow.TestE2EVisitFlow object at 0x000001B6E7BC83D0>
client = <starlette.testclient.TestClient object at 0x000001B6EA9506D0>
db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9EFA650>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxNiwidHlwZSI6ImFjY2VzcyJ9.9o1MhY4pU6Uyi6B9q2a-JePtIzRuFna4t5Mzk_XX3Xk'}
test_patient = <app.models.patient.Patient object at 0x000001B6EA9B9E90>

    def test_error_handling_in_flow(self, client, db_session, auth_headers, test_patient):
        """
        E2E ЄхёЄ юсЁрсюЄъш ю°шсюъ т яюыэюь ёЎхэрЁшш
        """
        # ╪└├ 1: ╧юя√Єър яюфЄтхЁфшЄ№ эхёє∙хёЄтє■∙шщ Єюъхэ
        confirm_response = client.post(
            "/api/v1/telegram/visits/confirm",
            json={
                "token": "nonexistent-token-123",
                "telegram_user_id": "123456789"
            }
        )
    
>       assert confirm_response.status_code == 404
E       assert 400 == 404
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\integration\test_e2e_visit_flow.py:448: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxNiwidHlwZSI6ImFjY2VzcyJ9.9o1MhY4pU6Uyi6B9q2a-JePtIzRuFna4t5Mzk_XX3Xk', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiI4Y2JlNjgyMi1hNmI4LTRmZDYtYjRmZS1jNzAxMWNlYWIwMTEiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzUxNn0.G3jfyrFVGse4EYvbxQkyUni0zj-iftVlTofltMx3FrM', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
_______________ TestE2EVisitFlow.test_notification_integration ________________

self = <test_e2e_visit_flow.TestE2EVisitFlow object at 0x000001B6E7BC8BD0>
mock_telegram = <AsyncMock name='send_confirmation_invitation' id='1885120668368'>
client = <starlette.testclient.TestClient object at 0x000001B6E9C98650>
db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9C9B050>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxNiwidHlwZSI6ImFjY2VzcyJ9.9o1MhY4pU6Uyi6B9q2a-JePtIzRuFna4t5Mzk_XX3Xk'}
test_patient = <app.models.patient.Patient object at 0x000001B6EA080A50>

    @patch('app.services.telegram.bot.ClinicTelegramBot.send_confirmation_invitation')
    def test_notification_integration(self, mock_telegram, client, db_session, auth_headers, test_patient):
        """
        E2E ЄхёЄ шэЄхуЁрЎшш ё ёшёЄхьющ єтхфюьыхэшщ
        """
        # ╤ючфрхь єэшъры№эє■ єёыєує фы  ¤Єюую ЄхёЄр
        from app.models.service import Service
>       notification_service = Service(
            code="NOTIFICATION_TEST",
            name="╙тхфюьшЄхы№эр  єёыєур",
            price=60000.00,
            queue_tag="cardiology_common",
            is_active=True
        )

tests\integration\test_e2e_visit_flow.py:508: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.service.Service object at 0x000001B6EA508050>
kwargs = {'code': 'NOTIFICATION_TEST', 'is_active': True, 'name': '╙тхфюьшЄхы№эр  єёыєур', 'price': 60000.0, ...}
cls_ = <class 'app.models.service.Service'>, k = 'is_active'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'is_active' is an invalid keyword argument for Service

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxNiwidHlwZSI6ImFjY2VzcyJ9.9o1MhY4pU6Uyi6B9q2a-JePtIzRuFna4t5Mzk_XX3Xk', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiIxNjg1YzUzNi1jYjk1LTQ5NTktOTBlMC1mMDAwZGE0NDliYzUiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzUxNn0.819djJpDRPR8yP6TNsFsd2OIqgPu07PPivppF8tfg5g', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
______ TestMigrationManagementAPI.test_restore_queue_data_file_not_found ______

self = <test_migration_management_api.TestMigrationManagementAPI object at 0x000001B6E7BC0F90>
client = <starlette.testclient.TestClient object at 0x000001B6EA655E90>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxOCwidHlwZSI6ImFjY2VzcyJ9.6a8JecCXyYat6PhXf2PJChWs1G6J3DGrEDs-O1POEqs'}

    def test_restore_queue_data_file_not_found(self, client, auth_headers):
        """╥хёЄ тюёёЄрэютыхэш  шч эхёє∙хёЄтє■∙хую Їрщыр"""
        response = client.post(
            "/api/v1/admin/migration/restore-queue-data?backup_file=nonexistent.json",
            headers=auth_headers
        )
    
>       assert response.status_code == 500
E       assert 200 == 500
E        +  where 200 = <Response [200 OK]>.status_code

tests\integration\test_migration_management_api.py:240: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxOCwidHlwZSI6ImFjY2VzcyJ9.6a8JecCXyYat6PhXf2PJChWs1G6J3DGrEDs-O1POEqs', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiI3Zjg5N2VmYy1hODBjLTRhNzYtYWYyNy0yNjhkYWFhZDJlYWEiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzUxOH0.OCgEyxirtzM8gavy1LmfYojQUf_zG_pFWq6NpzRivsU', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
---------------------------- Captured stderr call -----------------------------
ERROR:app.services.migration_service:╬°шсър тюёёЄрэютыхэш  фрээ√ї: [Errno 2] No such file or directory: 'nonexistent.json'
------------------------------ Captured log call ------------------------------
ERROR    app.services.migration_service:migration_service.py:499 ╬°шсър тюёёЄрэютыхэш  фрээ√ї: [Errno 2] No such file or directory: 'nonexistent.json'
_____________ TestMigrationManagementAPI.test_api_error_handling ______________

self = <test_migration_management_api.TestMigrationManagementAPI object at 0x000001B6E7BB3BD0>
client = <starlette.testclient.TestClient object at 0x000001B6E9BC1310>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxOCwidHlwZSI6ImFjY2VzcyJ9.6a8JecCXyYat6PhXf2PJChWs1G6J3DGrEDs-O1POEqs'}

    def test_api_error_handling(self, client, auth_headers):
        """╥хёЄ юсЁрсюЄъш ю°шсюъ т API"""
        # ╥хёЄ ё эхъюЁЁхъЄэ√ьш ярЁрьхЄЁрьш
        response = client.post(
            "/api/v1/admin/migration/cleanup-old-data?days_to_keep=invalid",
            headers=auth_headers
        )
    
        assert response.status_code == 422
    
        # ╥хёЄ тюёёЄрэютыхэш  ё эхъюЁЁхъЄэ√ь Їрщыюь
        response = client.post(
            "/api/v1/admin/migration/restore-queue-data?backup_file=",
            headers=auth_headers
        )
    
>       assert response.status_code == 422
E       assert 200 == 422
E        +  where 200 = <Response [200 OK]>.status_code

tests\integration\test_migration_management_api.py:338: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc0MzMxOCwidHlwZSI6ImFjY2VzcyJ9.6a8JecCXyYat6PhXf2PJChWs1G6J3DGrEDs-O1POEqs', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiI3ZTYxNTAyNy01NDQ1LTQ2ZmEtOGZkNC0wMTM4NDNhMGI2ODkiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODMzMzUxOH0.v6FLJih31AaXGl9q49G7Zd-qb_WflktdeqNOIgcuzO0', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
---------------------------- Captured stderr call -----------------------------
WARNING:app.core.exception_handlers:RequestValidationError: [{'type': 'int_parsing', 'loc': ('query', 'days_to_keep'), 'msg': 'Input should be a valid integer, unable to parse string as an integer', 'input': 'invalid'}] (path: /api/v1/admin/migration/cleanup-old-data)
ERROR:app.services.migration_service:╬°шсър тюёёЄрэютыхэш  фрээ√ї: [Errno 2] No such file or directory: ''
------------------------------ Captured log call ------------------------------
WARNING  app.core.exception_handlers:exception_handlers.py:216 RequestValidationError: [{'type': 'int_parsing', 'loc': ('query', 'days_to_keep'), 'msg': 'Input should be a valid integer, unable to parse string as an integer', 'input': 'invalid'}] (path: /api/v1/admin/migration/cleanup-old-data)
ERROR    app.services.migration_service:migration_service.py:499 ╬°шсър тюёёЄрэютыхэш  фрээ√ї: [Errno 2] No such file or directory: ''
______________ TestQueueBatchAPI.test_empty_services_list_error _______________

self = <test_queue_batch_api.TestQueueBatchAPI object at 0x000001B6E7B4F790>
client = <starlette.testclient.TestClient object at 0x000001B6EA948F90>
registrar_auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJ...CJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NDMzMjUsInR5cGUiOiJhY2Nlc3MifQ.yFDHchBBRVW5iM2MBf-MuOZU0ssijj6Fdm3W4ttsxQU'}
test_patient = <app.models.patient.Patient object at 0x000001B6E9CE4AD0>

    def test_empty_services_list_error(
        self, client, registrar_auth_headers, test_patient
    ):
        """╥хёЄ: ╬°шсър - яєёЄющ ёяшёюъ єёыєу"""
        response = client.post(
            "/api/v1/registrar-integration/queue/entries/batch",
            headers=registrar_auth_headers,
            json={
                "patient_id": test_patient.id,
                "source": "desk",
                "services": []  # ╧єёЄющ ёяшёюъ
            }
        )
    
>       assert response.status_code == 422  # Validation error
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 200 == 422
E        +  where 200 = <Response [200 OK]>.status_code

tests\integration\test_queue_batch_api.py:539: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NDMzMjUsInR5cGUiOiJhY2Nlc3MifQ.yFDHchBBRVW5iM2MBf-MuOZU0ssijj6Fdm3W4ttsxQU', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiMjMxOWQ2MDAtOGRhMy00MTBjLTgwZTgtNWVhZWE5MWU4ZmZiIiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzMzM1MjV9.9xVwlWDP8Zl5c9Yp5n1TzJtnT-3pmL_-jxPILIQGkDM', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
---------------------------- Captured stdout call -----------------------------
DEBUG: Checking roles for user 10 (test_registrar)
DEBUG: User Role: 'Registrar', Normalized: 'registrar'
DEBUG: Required Roles: ('Admin', 'Registrar'), Normalized: ['admin', 'registrar']
____________________________ test_health_endpoint _____________________________

self = <urllib3.connection.HTTPConnection object at 0x000001B6E9D22C10>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
>           sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:85: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('127.0.0.1', 8000), timeout = 30, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address: tuple[str, int],
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        source_address: tuple[str, int] | None = None,
        socket_options: _TYPE_SOCKET_OPTIONS | None = None,
    ) -> socket.socket:
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            raise LocationParseError(f"'{host}', label empty or too long") from None
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not _DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:73: ConnectionRefusedError

The above exception was the direct cause of the following exception:

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001B6E9D21710>
method = 'GET', url = '/api/v1/health', body = None
headers = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate, br', 'Accept': '*/*', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=30, read=30, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None, preload_content = False
decode_content = False, response_kw = {}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v1/health', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(  # type: ignore[override]
        self,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | bool | int | None = None,
        redirect: bool = True,
        assert_same_host: bool = True,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        pool_timeout: int | None = None,
        release_conn: bool | None = None,
        chunked: bool = False,
        body_pos: _TYPE_BODY_POSITION | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        **response_kw: typing.Any,
    ) -> BaseHTTPResponse:
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method
           such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param bool preload_content:
            If True, the response's body will be preloaded into memory.
    
        :param bool decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of ``preload_content``
            which defaults to ``True``.
    
        :param bool chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
        """
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = preload_content
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = to_str(_encode_target(url))
        else:
            url = to_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()  # type: ignore[attr-defined]
            headers.update(self.proxy_headers)  # type: ignore[union-attr]
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]
    
            # Is this a closed/new connection that requires CONNECT tunnelling?
            if self.proxy is not None and http_tunnel_required and conn.is_closed:
                try:
                    self._prepare_proxy(conn)
                except (BaseSSLError, OSError, SocketTimeout) as e:
                    self._raise_timeout(
                        err=e, url=self.proxy.url, timeout_value=conn.timeout
                    )
                    raise
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Make the request on the HTTPConnection object
>           response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
                retries=retries,
                response_conn=response_conn,
                preload_content=preload_content,
                decode_content=decode_content,
                **response_kw,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:493: in _make_request
    conn.request(
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:494: in request
    self.endheaders()
C:\Program Files\Python311\Lib\http\client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
C:\Program Files\Python311\Lib\http\client.py:1037: in _send_output
    self.send(msg)
C:\Program Files\Python311\Lib\http\client.py:975: in send
    self.connect()
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:325: in connect
    self.sock = self._new_conn()
                ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <urllib3.connection.HTTPConnection object at 0x000001B6E9D22C10>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
            sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )
        except socket.gaierror as e:
            raise NameResolutionError(self.host, self, e) from e
        except SocketTimeout as e:
            raise ConnectTimeoutError(
                self,
                f"Connection to {self.host} timed out. (connect timeout={self.timeout})",
            ) from e
    
        except OSError as e:
>           raise NewConnectionError(
                self, f"Failed to establish a new connection: {e}"
            ) from e
E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x000001B6E9D22C10>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:213: NewConnectionError

The above exception was the direct cause of the following exception:

self = <requests.adapters.HTTPAdapter object at 0x000001B6E9D218D0>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
>           resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:486: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:841: in urlopen
    retries = retries.increment(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'GET', url = '/api/v1/health', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001B6E9D22C10>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001B6E9D21710>
_stacktrace = <traceback object at 0x000001B6EA56A300>

    def increment(
        self,
        method: str | None = None,
        url: str | None = None,
        response: BaseHTTPResponse | None = None,
        error: Exception | None = None,
        _pool: ConnectionPool | None = None,
        _stacktrace: TracebackType | None = None,
    ) -> Self:
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.BaseHTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or method is None or not self._is_method_retryable(method):
                raise reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            response_redirect_location = response.get_redirect_location()
            if response_redirect_location:
                redirect_location = response_redirect_location
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
            reason = error or ResponseError(cause)
>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/health (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001B6E9D22C10>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\urllib3\util\retry.py:519: MaxRetryError

During handling of the above exception, another exception occurred:

    def test_health_endpoint():
        """╥хёЄ health endpoint"""
>       response = requests.get("http://127.0.0.1:8000/api/v1/health", timeout=30)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\integration\test_server_integration.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\requests\api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:703: in send
    r = adapter.send(request, **kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <requests.adapters.HTTPAdapter object at 0x000001B6E9D218D0>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/health (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001B6E9D22C10>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:519: ConnectionError
____________________________ test_status_endpoint _____________________________

self = <urllib3.connection.HTTPConnection object at 0x000001B6EA7D4BD0>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
>           sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:85: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('127.0.0.1', 8000), timeout = 30, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address: tuple[str, int],
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        source_address: tuple[str, int] | None = None,
        socket_options: _TYPE_SOCKET_OPTIONS | None = None,
    ) -> socket.socket:
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            raise LocationParseError(f"'{host}', label empty or too long") from None
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not _DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:73: ConnectionRefusedError

The above exception was the direct cause of the following exception:

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001B6EA7D4850>
method = 'GET', url = '/api/v1/status', body = None
headers = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate, br', 'Accept': '*/*', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=30, read=30, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None, preload_content = False
decode_content = False, response_kw = {}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v1/status', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(  # type: ignore[override]
        self,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | bool | int | None = None,
        redirect: bool = True,
        assert_same_host: bool = True,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        pool_timeout: int | None = None,
        release_conn: bool | None = None,
        chunked: bool = False,
        body_pos: _TYPE_BODY_POSITION | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        **response_kw: typing.Any,
    ) -> BaseHTTPResponse:
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method
           such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param bool preload_content:
            If True, the response's body will be preloaded into memory.
    
        :param bool decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of ``preload_content``
            which defaults to ``True``.
    
        :param bool chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
        """
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = preload_content
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = to_str(_encode_target(url))
        else:
            url = to_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()  # type: ignore[attr-defined]
            headers.update(self.proxy_headers)  # type: ignore[union-attr]
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]
    
            # Is this a closed/new connection that requires CONNECT tunnelling?
            if self.proxy is not None and http_tunnel_required and conn.is_closed:
                try:
                    self._prepare_proxy(conn)
                except (BaseSSLError, OSError, SocketTimeout) as e:
                    self._raise_timeout(
                        err=e, url=self.proxy.url, timeout_value=conn.timeout
                    )
                    raise
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Make the request on the HTTPConnection object
>           response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
                retries=retries,
                response_conn=response_conn,
                preload_content=preload_content,
                decode_content=decode_content,
                **response_kw,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:493: in _make_request
    conn.request(
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:494: in request
    self.endheaders()
C:\Program Files\Python311\Lib\http\client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
C:\Program Files\Python311\Lib\http\client.py:1037: in _send_output
    self.send(msg)
C:\Program Files\Python311\Lib\http\client.py:975: in send
    self.connect()
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:325: in connect
    self.sock = self._new_conn()
                ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <urllib3.connection.HTTPConnection object at 0x000001B6EA7D4BD0>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
            sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )
        except socket.gaierror as e:
            raise NameResolutionError(self.host, self, e) from e
        except SocketTimeout as e:
            raise ConnectTimeoutError(
                self,
                f"Connection to {self.host} timed out. (connect timeout={self.timeout})",
            ) from e
    
        except OSError as e:
>           raise NewConnectionError(
                self, f"Failed to establish a new connection: {e}"
            ) from e
E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x000001B6EA7D4BD0>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:213: NewConnectionError

The above exception was the direct cause of the following exception:

self = <requests.adapters.HTTPAdapter object at 0x000001B6EA7D7CD0>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
>           resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:486: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:841: in urlopen
    retries = retries.increment(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'GET', url = '/api/v1/status', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001B6EA7D4BD0>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001B6EA7D4850>
_stacktrace = <traceback object at 0x000001B6EA7D4D40>

    def increment(
        self,
        method: str | None = None,
        url: str | None = None,
        response: BaseHTTPResponse | None = None,
        error: Exception | None = None,
        _pool: ConnectionPool | None = None,
        _stacktrace: TracebackType | None = None,
    ) -> Self:
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.BaseHTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or method is None or not self._is_method_retryable(method):
                raise reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            response_redirect_location = response.get_redirect_location()
            if response_redirect_location:
                redirect_location = response_redirect_location
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
            reason = error or ResponseError(cause)
>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/status (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001B6EA7D4BD0>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\urllib3\util\retry.py:519: MaxRetryError

During handling of the above exception, another exception occurred:

    def test_status_endpoint():
        """╥хёЄ status endpoint"""
>       response = requests.get("http://127.0.0.1:8000/api/v1/status", timeout=30)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\integration\test_server_integration.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\requests\api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:703: in send
    r = adapter.send(request, **kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <requests.adapters.HTTPAdapter object at 0x000001B6EA7D7CD0>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/status (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001B6EA7D4BD0>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:519: ConnectionError
______________________________ test_openapi_docs ______________________________

self = <urllib3.connection.HTTPConnection object at 0x000001B6EA6A2E90>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
>           sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:85: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('127.0.0.1', 8000), timeout = 30, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address: tuple[str, int],
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        source_address: tuple[str, int] | None = None,
        socket_options: _TYPE_SOCKET_OPTIONS | None = None,
    ) -> socket.socket:
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            raise LocationParseError(f"'{host}', label empty or too long") from None
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not _DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:73: ConnectionRefusedError

The above exception was the direct cause of the following exception:

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001B6EA6A3B50>
method = 'GET', url = '/docs', body = None
headers = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate, br', 'Accept': '*/*', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=30, read=30, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None, preload_content = False
decode_content = False, response_kw = {}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/docs', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(  # type: ignore[override]
        self,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | bool | int | None = None,
        redirect: bool = True,
        assert_same_host: bool = True,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        pool_timeout: int | None = None,
        release_conn: bool | None = None,
        chunked: bool = False,
        body_pos: _TYPE_BODY_POSITION | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        **response_kw: typing.Any,
    ) -> BaseHTTPResponse:
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method
           such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param bool preload_content:
            If True, the response's body will be preloaded into memory.
    
        :param bool decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of ``preload_content``
            which defaults to ``True``.
    
        :param bool chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
        """
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = preload_content
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = to_str(_encode_target(url))
        else:
            url = to_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()  # type: ignore[attr-defined]
            headers.update(self.proxy_headers)  # type: ignore[union-attr]
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]
    
            # Is this a closed/new connection that requires CONNECT tunnelling?
            if self.proxy is not None and http_tunnel_required and conn.is_closed:
                try:
                    self._prepare_proxy(conn)
                except (BaseSSLError, OSError, SocketTimeout) as e:
                    self._raise_timeout(
                        err=e, url=self.proxy.url, timeout_value=conn.timeout
                    )
                    raise
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Make the request on the HTTPConnection object
>           response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
                retries=retries,
                response_conn=response_conn,
                preload_content=preload_content,
                decode_content=decode_content,
                **response_kw,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:493: in _make_request
    conn.request(
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:494: in request
    self.endheaders()
C:\Program Files\Python311\Lib\http\client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
C:\Program Files\Python311\Lib\http\client.py:1037: in _send_output
    self.send(msg)
C:\Program Files\Python311\Lib\http\client.py:975: in send
    self.connect()
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:325: in connect
    self.sock = self._new_conn()
                ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <urllib3.connection.HTTPConnection object at 0x000001B6EA6A2E90>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
            sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )
        except socket.gaierror as e:
            raise NameResolutionError(self.host, self, e) from e
        except SocketTimeout as e:
            raise ConnectTimeoutError(
                self,
                f"Connection to {self.host} timed out. (connect timeout={self.timeout})",
            ) from e
    
        except OSError as e:
>           raise NewConnectionError(
                self, f"Failed to establish a new connection: {e}"
            ) from e
E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x000001B6EA6A2E90>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:213: NewConnectionError

The above exception was the direct cause of the following exception:

self = <requests.adapters.HTTPAdapter object at 0x000001B6EA6A2910>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
>           resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:486: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:841: in urlopen
    retries = retries.increment(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'GET', url = '/docs', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001B6EA6A2E90>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x000001B6EA6A3B50>
_stacktrace = <traceback object at 0x000001B6EA6A3380>

    def increment(
        self,
        method: str | None = None,
        url: str | None = None,
        response: BaseHTTPResponse | None = None,
        error: Exception | None = None,
        _pool: ConnectionPool | None = None,
        _stacktrace: TracebackType | None = None,
    ) -> Self:
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.BaseHTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or method is None or not self._is_method_retryable(method):
                raise reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            response_redirect_location = response.get_redirect_location()
            if response_redirect_location:
                redirect_location = response_redirect_location
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
            reason = error or ResponseError(cause)
>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /docs (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001B6EA6A2E90>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\urllib3\util\retry.py:519: MaxRetryError

During handling of the above exception, another exception occurred:

    def test_openapi_docs():
        """╥хёЄ OpenAPI фюъєьхэЄрЎшш"""
>       response = requests.get("http://127.0.0.1:8000/docs", timeout=30)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\integration\test_server_integration.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\requests\api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:703: in send
    r = adapter.send(request, **kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <requests.adapters.HTTPAdapter object at 0x000001B6EA6A2910>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /docs (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x000001B6EA6A2E90>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:519: ConnectionError
_____ TestVisitConfirmationAPI.test_confirm_visit_telegram_invalid_token ______

self = <test_visit_confirmation_api.TestVisitConfirmationAPI object at 0x000001B6E7AC3090>
client = <starlette.testclient.TestClient object at 0x000001B6EA72E610>

    def test_confirm_visit_telegram_invalid_token(self, client):
        """╥хёЄ яюфЄтхЁцфхэш  ё эхфхщёЄтшЄхы№э√ь Єюъхэюь"""
        response = client.post("/api/v1/telegram/visits/confirm", json={
            "token": "invalid-token-123",
            "telegram_user_id": "123456789"
        })
    
>       assert response.status_code == 404
E       assert 400 == 404
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\integration\test_visit_confirmation_api.py:72: AssertionError
___________ Test2FAEnforcement.test_admin_cannot_login_without_2fa ____________

self = <tests.test_2fa_enforcement.Test2FAEnforcement object at 0x000001B6E7C08F90>
client = <starlette.testclient.TestClient object at 0x000001B6EA903190>
admin_user_without_2fa = <app.models.user.User object at 0x000001B6EA7D5B50>

    def test_admin_cannot_login_without_2fa(
        self, client: TestClient, admin_user_without_2fa: User
    ):
        """Admin ═┼ ьюцхЄ тющЄш схч эрёЄЁющъш 2FA"""
        response = client.post(
            "/api/v1/authentication/login",
            json={
                "username": admin_user_without_2fa.username,
                "password": "admin123",
            },
        )
    
        # ▌эфяюшэЄ тючтЁр∙рхЄ 401, ъюуфр success=False
>       assert response.status_code == 401, f"Expected 401, got {response.status_code}. Response: {response.text}"
E       AssertionError: Expected 401, got 200. Response: {"access_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxNiIsInVzZXJuYW1lIjoidGVzdF9hZG1pbl8yZmEiLCJyb2xlIjoiQWRtaW4iLCJpc19hY3RpdmUiOnRydWUsImlzX3N1cGVydXNlciI6ZmFsc2UsImV4cCI6MTc2NTc0MzMzNSwidHlwZSI6ImFjY2VzcyJ9.4nObOr8Of0mbrIaHQOvIcUMwtHwuixRfpkeU_t-SawE","refresh_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxNiwianRpIjoiYzc1YTM4MDYtYTc0MC00YmE5LWJlMDQtYTY1YjcyZmYwYjc1IiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzMzM1MzV9.oo0gI5HOG6L2YNdhW-z-IK9ZxveS47pBbLAVY3VXYMo","token_type":"bearer","expires_in":1800,"user":{"id":16,"username":"test_admin_2fa","full_name":"Test Admin 2FA","email":"admin2fa@test.com","role":"Admin","is_active":true,"is_superuser":false},"requires_2fa":false,"two_factor_method":null,"pending_2fa_token":null}
E       assert 200 == 401
E        +  where 200 = <Response [200 OK]>.status_code

tests\test_2fa_enforcement.py:159: AssertionError
---------------------------- Captured stdout call -----------------------------
DEBUG: Login endpoint called with username=test_admin_2fa
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 16, 'username': 'test_admin_2fa', 'full_name': 'Test Admin 2FA', 'email': 'admin2fa@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxNiIsInVzZXJuYW1lIjoidGVzdF9hZG1pbl8yZmEiLCJyb2xlIjoiQWRtaW4iLCJpc19hY3RpdmUiOnRydWUsImlzX3N1cGVydXNlciI6ZmFsc2UsImV4cCI6MTc2NTc0MzMzNSwidHlwZSI6ImFjY2VzcyJ9.4nObOr8Of0mbrIaHQOvIcUMwtHwuixRfpkeU_t-SawE', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxNiwianRpIjoiYzc1YTM4MDYtYTc0MC00YmE5LWJlMDQtYTY1YjcyZmYwYjc1IiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzMzM1MzV9.oo0gI5HOG6L2YNdhW-z-IK9ZxveS47pBbLAVY3VXYMo', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
__________ Test2FAEnforcement.test_cashier_cannot_login_without_2fa ___________

self = <tests.test_2fa_enforcement.Test2FAEnforcement object at 0x000001B6E7C08650>
client = <starlette.testclient.TestClient object at 0x000001B6EA7D73D0>
cashier_user_without_2fa = <app.models.user.User object at 0x000001B6E9D10810>

    def test_cashier_cannot_login_without_2fa(
        self, client: TestClient, cashier_user_without_2fa: User
    ):
        """Cashier ═┼ ьюцхЄ тющЄш схч эрёЄЁющъш 2FA"""
        response = client.post(
            "/api/v1/authentication/login",
            json={
                "username": cashier_user_without_2fa.username,
                "password": "cashier123",
            },
        )
    
        # ▌эфяюшэЄ тючтЁр∙рхЄ 401, ъюуфр success=False
>       assert response.status_code == 401, f"Expected 401, got {response.status_code}. Response: {response.text}"
E       AssertionError: Expected 401, got 200. Response: {"access_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxNyIsInVzZXJuYW1lIjoidGVzdF9jYXNoaWVyXzJmYSIsInJvbGUiOiJDYXNoaWVyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NDMzMzUsInR5cGUiOiJhY2Nlc3MifQ.zvhqq9iCNN2zfrY-0D1dRDiXMDIIdfAvZ_W5clTx3vQ","refresh_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxNywianRpIjoiM2E3MjhhYWMtMjM4Zi00NTMxLWI2NmQtYTMzMDk2ZTk4ZTc4IiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzMzM1MzV9.SgN9Ql_cl1-m7lzY8-w_3Yqngu9CUXGyxcsfGwBcOBY","token_type":"bearer","expires_in":1800,"user":{"id":17,"username":"test_cashier_2fa","full_name":"Test Cashier 2FA","email":"cashier2fa@test.com","role":"Cashier","is_active":true,"is_superuser":false},"requires_2fa":false,"two_factor_method":null,"pending_2fa_token":null}
E       assert 200 == 401
E        +  where 200 = <Response [200 OK]>.status_code

tests\test_2fa_enforcement.py:179: AssertionError
---------------------------- Captured stdout call -----------------------------
DEBUG: Login endpoint called with username=test_cashier_2fa
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x000001B6BF9B0D10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 17, 'username': 'test_cashier_2fa', 'full_name': 'Test Cashier 2FA', 'email': 'cashier2fa@test.com', 'role': 'Cashier', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxNyIsInVzZXJuYW1lIjoidGVzdF9jYXNoaWVyXzJmYSIsInJvbGUiOiJDYXNoaWVyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NDMzMzUsInR5cGUiOiJhY2Nlc3MifQ.zvhqq9iCNN2zfrY-0D1dRDiXMDIIdfAvZ_W5clTx3vQ', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxNywianRpIjoiM2E3MjhhYWMtMjM4Zi00NTMxLWI2NmQtYTMzMDk2ZTk4ZTc4IiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzMzM1MzV9.SgN9Ql_cl1-m7lzY8-w_3Yqngu9CUXGyxcsfGwBcOBY', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
____________ TestFileSecurity.test_file_hash_is_computed_on_upload ____________

self = <tests.test_file_security.TestFileSecurity object at 0x000001B6E7B989D0>
client = <starlette.testclient.TestClient object at 0x000001B6EA6E9310>
db_session = <sqlalchemy.orm.session.Session object at 0x000001B6EA63F2D0>

    def test_file_hash_is_computed_on_upload(
        self, client: TestClient, db_session: Session
    ):
        """\u2705 CERTIFICATION: SHA256 \u0445\u0435\u0448 \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u0442\u0441\u044f \u043f\u0440\u0438 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0435 \u0444\u0430\u0439\u043b\u0430"""
        # ╤ючфрхь яюы№чютрЄхы  ё Ёюы№■, ъюЄюЁр  ьюцхЄ чруЁєцрЄ№ Їрщы√ (Doctor)
        from app.core.security import get_password_hash
        from app.models.user import User
    
        doctor_user = db_session.query(User).filter(User.username == "doctor_file_test").first()
        if not doctor_user:
            doctor_user = User(
                username="doctor_file_test",
                email="doctor_file@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                is_superuser=False,
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╧юыєўрхь Єюъхэ
        login_response = client.post(
            "/api/v1/auth/minimal-login",
            json={"username": doctor_user.username, "password": "doctor123"},
        )
        assert login_response.status_code == 200
        token = login_response.json()["access_token"]
    
        # ╟руЁєцрхь ЄхёЄют√щ Їрщы
        file_content = b"Test file content for hashing"
        file_obj = BytesIO(file_content)
        file_obj.name = "test.txt"
    
        response = client.post(
            "/api/v1/files/upload",
            files={"file": ("test.txt", file_obj, "text/plain")},
            data={
                "file_type": "document",
                "permission": "private",
            },
            headers={"Authorization": f"Bearer {token}"},
        )
    
>       assert response.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\test_file_security.py:66: AssertionError
---------------------------- Captured stdout call -----------------------------
DEBUG: Minimal login called with username=doctor_file_test
DEBUG: User found: ID=20, Username=doctor_file_test, IsActive=1
DEBUG: Verifying password...
DEBUG: Password verification result: True
DEBUG: Token created successfully, expires in 28800 seconds
DEBUG: Successful authentication for user doctor_file_test
DEBUG: Checking roles for user 20 (doctor_file_test)
DEBUG: User Role: 'Doctor', Normalized: 'doctor'
DEBUG: Required Roles: ('Admin', 'Doctor', 'Nurse', 'Receptionist'), Normalized: ['admin', 'doctor', 'nurse', 'receptionist']
---------------------------- Captured stderr call -----------------------------
WARNING:app.utils.file_validator:[File Validator] Unknown file type for test.txt
------------------------------ Captured log call ------------------------------
WARNING  app.utils.file_validator:file_validator.py:257 [File Validator] Unknown file type for test.txt
__________ TestFileSecurity.test_file_versioning_on_content_replace ___________

self = <tests.test_file_security.TestFileSecurity object at 0x000001B6E7B98D90>
client = <starlette.testclient.TestClient object at 0x000001B6EA925590>
db_session = <sqlalchemy.orm.session.Session object at 0x000001B6EA926F50>

    def test_file_versioning_on_content_replace(
        self, client: TestClient, db_session: Session
    ):
        """\u2705 CERTIFICATION: \u0412\u0435\u0440\u0441\u0438\u044f \u0441\u043e\u0437\u0434\u0430\u0435\u0442\u0441\u044f \u043f\u0440\u0438 \u0437\u0430\u043c\u0435\u043d\u0435 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0433\u043e \u0444\u0430\u0439\u043b\u0430"""
        # ╤ючфрхь яюы№чютрЄхы  ё Ёюы№■ Doctor
        from app.core.security import get_password_hash
        from app.models.user import User
    
        doctor_user = db_session.query(User).filter(User.username == "doctor_file_test2").first()
        if not doctor_user:
            doctor_user = User(
                username="doctor_file_test2",
                email="doctor_file2@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                is_superuser=False,
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╧юыєўрхь Єюъхэ
        login_response = client.post(
            "/api/v1/auth/minimal-login",
            json={"username": doctor_user.username, "password": "doctor123"},
        )
        assert login_response.status_code == 200
        token = login_response.json()["access_token"]
    
        # ╪ру 1: ╟руЁєцрхь шёїюфэ√щ Їрщы
        file_content_1 = b"Original file content"
        file_obj_1 = BytesIO(file_content_1)
        file_obj_1.name = "original.txt"
    
        upload_response = client.post(
            "/api/v1/files/upload",
            files={"file": ("original.txt", file_obj_1, "text/plain")},
            data={
                "file_type": "document",
                "permission": "private",
            },
            headers={"Authorization": f"Bearer {token}"},
        )
>       assert upload_response.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\test_file_security.py:121: AssertionError
---------------------------- Captured stdout call -----------------------------
DEBUG: Minimal login called with username=doctor_file_test2
DEBUG: User found: ID=21, Username=doctor_file_test2, IsActive=1
DEBUG: Verifying password...
DEBUG: Password verification result: True
DEBUG: Token created successfully, expires in 28800 seconds
DEBUG: Successful authentication for user doctor_file_test2
DEBUG: Checking roles for user 21 (doctor_file_test2)
DEBUG: User Role: 'Doctor', Normalized: 'doctor'
DEBUG: Required Roles: ('Admin', 'Doctor', 'Nurse', 'Receptionist'), Normalized: ['admin', 'doctor', 'nurse', 'receptionist']
---------------------------- Captured stderr call -----------------------------
WARNING:app.utils.file_validator:[File Validator] Unknown file type for original.txt
------------------------------ Captured log call ------------------------------
WARNING  app.utils.file_validator:file_validator.py:257 [File Validator] Unknown file type for original.txt
_________________ TestFileSecurity.test_file_hash_consistency _________________

self = <tests.test_file_security.TestFileSecurity object at 0x000001B6E7B99910>
client = <starlette.testclient.TestClient object at 0x000001B6E9F61610>
db_session = <sqlalchemy.orm.session.Session object at 0x000001B6EA140550>

    def test_file_hash_consistency(
        self, client: TestClient, db_session: Session
    ):
        """\u2705 CERTIFICATION: \u041e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u044b\u0435 \u0444\u0430\u0439\u043b\u044b \u0438\u043c\u0435\u044e\u0442 \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u044b\u0439 \u0445\u0435\u0448"""
        # ╤ючфрхь яюы№чютрЄхы  ё Ёюы№■ Doctor
        from app.core.security import get_password_hash
        from app.models.user import User
    
        doctor_user = db_session.query(User).filter(User.username == "doctor_file_test3").first()
        if not doctor_user:
            doctor_user = User(
                username="doctor_file_test3",
                email="doctor_file3@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                is_superuser=False,
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╧юыєўрхь Єюъхэ
        login_response = client.post(
            "/api/v1/auth/minimal-login",
            json={"username": doctor_user.username, "password": "doctor123"},
        )
        assert login_response.status_code == 200
        token = login_response.json()["access_token"]
    
        file_content = b"Identical content"
    
        # ╟руЁєцрхь яхЁт√щ Їрщы
        file_obj_1 = BytesIO(file_content)
        file_obj_1.name = "file1.txt"
        response_1 = client.post(
            "/api/v1/files/upload",
            files={"file": ("file1.txt", file_obj_1, "text/plain")},
            data={"file_type": "document", "permission": "private"},
            headers={"Authorization": f"Bearer {token}"},
        )
>       assert response_1.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\test_file_security.py:221: AssertionError
---------------------------- Captured stdout call -----------------------------
DEBUG: Minimal login called with username=doctor_file_test3
DEBUG: User found: ID=22, Username=doctor_file_test3, IsActive=1
DEBUG: Verifying password...
DEBUG: Password verification result: True
DEBUG: Token created successfully, expires in 28800 seconds
DEBUG: Successful authentication for user doctor_file_test3
DEBUG: Checking roles for user 22 (doctor_file_test3)
DEBUG: User Role: 'Doctor', Normalized: 'doctor'
DEBUG: Required Roles: ('Admin', 'Doctor', 'Nurse', 'Receptionist'), Normalized: ['admin', 'doctor', 'nurse', 'receptionist']
---------------------------- Captured stderr call -----------------------------
WARNING:app.utils.file_validator:[File Validator] Unknown file type for file1.txt
------------------------------ Captured log call ------------------------------
WARNING  app.utils.file_validator:file_validator.py:257 [File Validator] Unknown file type for file1.txt
______________ TestFileSecurity.test_file_version_hash_required _______________

self = <tests.test_file_security.TestFileSecurity object at 0x000001B6E7B99F50>
client = <starlette.testclient.TestClient object at 0x000001B6EA0C3250>
db_session = <sqlalchemy.orm.session.Session object at 0x000001B6EA0C0B50>

    def test_file_version_hash_required(
        self, client: TestClient, db_session: Session
    ):
        """\u2705 CERTIFICATION: \u0412\u0435\u0440\u0441\u0438\u044f \u0444\u0430\u0439\u043b\u0430 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 file_hash"""
        # ╤ючфрхь яюы№чютрЄхы  ё Ёюы№■ Doctor
        from app.core.security import get_password_hash
        from app.models.user import User
    
        doctor_user = db_session.query(User).filter(User.username == "doctor_file_test4").first()
        if not doctor_user:
            doctor_user = User(
                username="doctor_file_test4",
                email="doctor_file4@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                is_superuser=False,
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╧юыєўрхь Єюъхэ
        login_response = client.post(
            "/api/v1/auth/minimal-login",
            json={"username": doctor_user.username, "password": "doctor123"},
        )
        assert login_response.status_code == 200
        token = login_response.json()["access_token"]
    
        # ╟руЁєцрхь Їрщы
        file_content = b"Version test"
        file_obj = BytesIO(file_content)
        file_obj.name = "version_test.txt"
    
        upload_response = client.post(
            "/api/v1/files/upload",
            files={"file": ("version_test.txt", file_obj, "text/plain")},
            data={"file_type": "document", "permission": "private"},
            headers={"Authorization": f"Bearer {token}"},
        )
>       assert upload_response.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\test_file_security.py:280: AssertionError
---------------------------- Captured stdout call -----------------------------
DEBUG: Minimal login called with username=doctor_file_test4
DEBUG: User found: ID=23, Username=doctor_file_test4, IsActive=1
DEBUG: Verifying password...
DEBUG: Password verification result: True
DEBUG: Token created successfully, expires in 28800 seconds
DEBUG: Successful authentication for user doctor_file_test4
DEBUG: Checking roles for user 23 (doctor_file_test4)
DEBUG: User Role: 'Doctor', Normalized: 'doctor'
DEBUG: Required Roles: ('Admin', 'Doctor', 'Nurse', 'Receptionist'), Normalized: ['admin', 'doctor', 'nurse', 'receptionist']
---------------------------- Captured stderr call -----------------------------
WARNING:app.utils.file_validator:[File Validator] Unknown file type for version_test.txt
------------------------------ Captured log call ------------------------------
WARNING  app.utils.file_validator:file_validator.py:257 [File Validator] Unknown file type for version_test.txt
_______________ TestRateLimiting.test_rate_limit_login_endpoint _______________

self = <tests.test_security_middleware.TestRateLimiting object at 0x000001B6E7C1CD90>
app_with_security = <fastapi.applications.FastAPI object at 0x000001B6EA6A9650>

    def test_rate_limit_login_endpoint(self, app_with_security):
        """╥хёЄ: яЁхт√°хэшх ышьшЄр эр login endpoint"""
        client = TestClient(app_with_security)
        # ─хырхь 6 чряЁюёют (ышьшЄ: 5 чр 5 ьшэєЄ)
        for i in range(5):
            response = client.post("/api/v1/authentication/login")
            assert response.status_code in [200, 400, 401]  # ╠юцхЄ с√Є№ ю°шсър трышфрЎшш
    
        # 6-щ чряЁюё фюыцхэ с√Є№ чрсыюъшЁютрэ
        response = client.post("/api/v1/authentication/login")
>       assert response.status_code == status.HTTP_429_TOO_MANY_REQUESTS
E       assert 200 == 429
E        +  where 200 = <Response [200 OK]>.status_code
E        +  and   429 = status.HTTP_429_TOO_MANY_REQUESTS

tests\test_security_middleware.py:64: AssertionError
_________________ TestRateLimiting.test_rate_limit_2fa_verify _________________

self = <tests.test_security_middleware.TestRateLimiting object at 0x000001B6E7C1D3D0>
app_with_security = <fastapi.applications.FastAPI object at 0x000001B6EA71E5D0>

    def test_rate_limit_2fa_verify(self, app_with_security):
        """╥хёЄ: яЁхт√°хэшх ышьшЄр эр 2FA verify endpoint"""
        client = TestClient(app_with_security)
        # ─хырхь 11 чряЁюёют (ышьшЄ: 10 чр 5 ьшэєЄ)
        for i in range(10):
            response = client.post("/api/v1/2fa/verify")
            assert response.status_code in [200, 400, 401]
    
        # 11-щ чряЁюё фюыцхэ с√Є№ чрсыюъшЁютрэ
        response = client.post("/api/v1/2fa/verify")
>       assert response.status_code == status.HTTP_429_TOO_MANY_REQUESTS
E       assert 200 == 429
E        +  where 200 = <Response [200 OK]>.status_code
E        +  and   429 = status.HTTP_429_TOO_MANY_REQUESTS

tests\test_security_middleware.py:77: AssertionError
_______________ TestRateLimiting.test_rate_limit_password_reset _______________

self = <tests.test_security_middleware.TestRateLimiting object at 0x000001B6E7C1DA10>
app_with_security = <fastapi.applications.FastAPI object at 0x000001B6EA3F7410>

    def test_rate_limit_password_reset(self, app_with_security):
        """╥хёЄ: яЁхт√°хэшх ышьшЄр эр password reset endpoint"""
        client = TestClient(app_with_security)
        # ─хырхь 4 чряЁюёр (ышьшЄ: 3 чр ўрё)
        for i in range(3):
            response = client.post("/api/v1/authentication/password-reset")
            assert response.status_code in [200, 400]
    
        # 4-щ чряЁюё фюыцхэ с√Є№ чрсыюъшЁютрэ
        response = client.post("/api/v1/authentication/password-reset")
>       assert response.status_code == status.HTTP_429_TOO_MANY_REQUESTS
E       assert 200 == 429
E        +  where 200 = <Response [200 OK]>.status_code
E        +  and   429 = status.HTTP_429_TOO_MANY_REQUESTS

tests\test_security_middleware.py:89: AssertionError
__________________ TestRateLimiting.test_rate_limit_headers ___________________

self = <tests.test_security_middleware.TestRateLimiting object at 0x000001B6E7C1E090>
app_with_security = <fastapi.applications.FastAPI object at 0x000001B6EA6B1E90>

    def test_rate_limit_headers(self, app_with_security):
        """╥хёЄ: яЁютхЁър чруюыютъют rate limit"""
        client = TestClient(app_with_security)
        response = client.post("/api/v1/authentication/login")
        # ╟руюыютъш фюсрты ■Єё  Єюы№ъю фы  єёях°э√ї чряЁюёют (status < 400)
        if response.status_code < 400:
>           assert "X-RateLimit-Limit" in response.headers
E           AssertionError: assert 'X-RateLimit-Limit' in Headers({'content-length': '30', 'content-type': 'application/json'})
E            +  where Headers({'content-length': '30', 'content-type': 'application/json'}) = <Response [200 OK]>.headers

tests\test_security_middleware.py:97: AssertionError
___________ TestBruteForceProtection.test_brute_force_login_blocked ___________

self = <tests.test_security_middleware.TestBruteForceProtection object at 0x000001B6E7C1E610>
client = <starlette.testclient.TestClient object at 0x000001B6EA724190>

    def test_brute_force_login_blocked(self, client: TestClient):
        """╥хёЄ: сыюъшЁютър IP яюёых ьэюцхёЄтхээ√ї эхєфрўэ√ї яюя√Єюъ login"""
        # ╤шьєышЁєхь эхєфрўэ√х яюя√Єъш (4xx/5xx юЄтхЄ√)
        # ─ы  ¤Єюую эєцэю, ўЄюс√ endpoint тючтЁр∙ры ю°шсъє
    
        # ╤ючфрхь юЄфхы№э√щ endpoint, ъюЄюЁ√щ тёхуфр тючтЁр∙рхЄ ю°шсъє
        app = FastAPI()
    
        @app.post("/api/v1/authentication/login")
        async def failing_login():
            from fastapi import HTTPException
            raise HTTPException(status_code=401, detail="Invalid credentials")
    
        app.add_middleware(SecurityMiddleware)
        test_client = TestClient(app)
    
        # ─хырхь 5 эхєфрўэ√ї яюя√Єюъ (ышьшЄ: 5)
        for i in range(5):
            response = test_client.post("/api/v1/authentication/login")
            assert response.status_code == 401
    
        # 6-  яюя√Єър фюыцэр с√Є№ чрсыюъшЁютрэр
        response = test_client.post("/api/v1/authentication/login")
>       assert response.status_code == status.HTTP_429_TOO_MANY_REQUESTS
E       assert 401 == 429
E        +  where 401 = <Response [401 Unauthorized]>.status_code
E        +  and   429 = status.HTTP_429_TOO_MANY_REQUESTS

tests\test_security_middleware.py:138: AssertionError
____________ TestBruteForceProtection.test_brute_force_2fa_blocked ____________

self = <tests.test_security_middleware.TestBruteForceProtection object at 0x000001B6E7C1EA50>
client = <starlette.testclient.TestClient object at 0x000001B6EA740E90>

    def test_brute_force_2fa_blocked(self, client: TestClient):
        """╥хёЄ: сыюъшЁютър IP яюёых ьэюцхёЄтхээ√ї эхєфрўэ√ї яюя√Єюъ 2FA"""
        app = FastAPI()
    
        @app.post("/api/v1/2fa/verify")
        async def failing_2fa():
            from fastapi import HTTPException
            raise HTTPException(status_code=400, detail="Invalid OTP")
    
        app.add_middleware(SecurityMiddleware)
        test_client = TestClient(app)
    
        # ─хырхь 5 эхєфрўэ√ї яюя√Єюъ
        for i in range(5):
            response = test_client.post("/api/v1/2fa/verify")
            assert response.status_code == 400
    
        # 6-  яюя√Єър фюыцэр с√Є№ чрсыюъшЁютрэр
        response = test_client.post("/api/v1/2fa/verify")
>       assert response.status_code == status.HTTP_429_TOO_MANY_REQUESTS
E       assert 400 == 429
E        +  where 400 = <Response [400 Bad Request]>.status_code
E        +  and   429 = status.HTTP_429_TOO_MANY_REQUESTS

tests\test_security_middleware.py:160: AssertionError
____ TestSecurityMiddlewareIntegration.test_rate_limit_reset_after_window _____

self = <tests.test_security_middleware.TestSecurityMiddlewareIntegration object at 0x000001B6E7C2C990>
client = <starlette.testclient.TestClient object at 0x000001B6EA7717D0>

    def test_rate_limit_reset_after_window(self, client: TestClient):
        """╥хёЄ: rate limit ёсЁрё√трхЄё  яюёых юъэр тЁхьхэш"""
        # ▌ЄюЄ ЄхёЄ ёыюцэю т√яюыэшЄ№ схч ьюъшЁютрэш  тЁхьхэш
        # ═ю ьюцэю яЁютхЁшЄ№, ўЄю ёўхЄўшъш юўш∙р■Єё 
        middleware = SecurityMiddleware(None)
    
        # ╤шьєышЁєхь ёЄрЁ√х чряшёш (ёЄрЁ°х юъэр)
        import time
        old_timestamp = time.time() - 2000  # 2000 ёхъєэф эрчрф (сюы№°х юъэр т 1 ўрё)
        middleware.request_counts["test:127.0.0.1"] = [old_timestamp]
    
        # ┬√ч√трхь cleanup
        middleware._cleanup_old_records()
    
        # ╧ЁютхЁ хь, ўЄю ёЄрЁ√х чряшёш єфрыхэ√
        # ╚ёяюы№чєхь юс√ўэ√щ dict тьхёЄю defaultdict фы  яЁютхЁъш
        if "test:127.0.0.1" in middleware.request_counts:
>           assert len(middleware.request_counts["test:127.0.0.1"]) == 0
E           assert 1 == 0
E            +  where 1 = len([1765739537.761409])

tests\test_security_middleware.py:232: AssertionError
________ TestMigrationService.test_get_or_create_daily_queue_existing _________

self = <test_migration_service.TestMigrationService object at 0x000001B6E7C77990>
db_session = <sqlalchemy.orm.session.Session object at 0x000001B6EAAB1790>
test_daily_queue = <app.models.online_queue.DailyQueue object at 0x000001B6EAAB1510>

    def test_get_or_create_daily_queue_existing(self, db_session, test_daily_queue):
        """╥хёЄ яюыєўхэш  ёє∙хёЄтє■∙хщ фэхтэющ юўхЁхфш"""
        service = MigrationService(db_session)
    
        queue = service._get_or_create_daily_queue(
            day=test_daily_queue.day,
            specialist_id=test_daily_queue.specialist_id,
            queue_tag=test_daily_queue.queue_tag
        )
    
>       assert queue.id == test_daily_queue.id
E       assert 7 == 10007
E        +  where 7 = <app.models.online_queue.DailyQueue object at 0x000001B6EA7CF690>.id
E        +  and   10007 = <app.models.online_queue.DailyQueue object at 0x000001B6EAAB1510>.id

tests\unit\test_migration_service.py:67: AssertionError
___________ TestMigrationService.test_check_data_integrity_empty_db ___________

self = <test_migration_service.TestMigrationService object at 0x000001B6E7C67E10>
db_session = <sqlalchemy.orm.session.Session object at 0x000001B6E9D0EF50>

    def test_check_data_integrity_empty_db(self, db_session):
        """╥хёЄ яЁютхЁъш ЎхыюёЄэюёЄш фрээ√ї т яєёЄющ ┴─"""
        service = MigrationService(db_session)
    
        result = service._check_data_integrity()
    
>       assert result["passed"] is True
E       assert False is True

tests\unit\test_migration_service.py:100: AssertionError
______________ TestMigrationService.test_backup_queue_data_empty ______________

self = <test_migration_service.TestMigrationService object at 0x000001B6E7C78950>
db_session = <sqlalchemy.orm.session.Session object at 0x000001B6EA148810>

    def test_backup_queue_data_empty(self, db_session):
        """╥хёЄ ёючфрэш  ЁхчхЁтэющ ъюяшш яєёЄ√ї фрээ√ї"""
        service = MigrationService(db_session)
    
        with patch('os.makedirs'), patch('builtins.open', create=True) as mock_open:
            mock_file = MagicMock()
            mock_open.return_value.__enter__.return_value = mock_file
    
            result = service.backup_queue_data(date.today())
    
            assert result["success"] is True
>           assert result["queues_count"] == 0
E           assert 12 == 0

tests\unit\test_migration_service.py:126: AssertionError
______________ TestMigrationService.test_cleanup_old_data_empty _______________

self = <test_migration_service.TestMigrationService object at 0x000001B6E7C79DD0>
db_session = <sqlalchemy.orm.session.Session object at 0x000001B6EA23E310>

    def test_cleanup_old_data_empty(self, db_session):
        """╥хёЄ юўшёЄъш ёЄрЁ√ї фрээ√ї т яєёЄющ ┴─"""
        service = MigrationService(db_session)
    
        result = service.cleanup_old_data(days_to_keep=30)
    
        assert result["success"] is True
>       assert result["deleted_queues"] == 0
E       assert 6 == 0

tests\unit\test_migration_service.py:220: AssertionError
============================== warnings summary ===============================
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1093
  C:\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1093: PydanticDeprecatedSince20: Using extra keyword arguments on `Field` is deprecated and will be removed. Use `json_schema_extra` instead. (Extra keys: 'env'). Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warn(

..\..\Program Files\Python311\Lib\site-packages\pydantic\_internal\_config.py:323: 51 warnings
  C:\Program Files\Python311\Lib\site-packages\pydantic\_internal\_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1068
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1068
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1068
  C:\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1068: PydanticDeprecatedSince20: `max_items` is deprecated and will be removed, use `max_length` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warn('`max_items` is deprecated and will be removed, use `max_length` instead', DeprecationWarning)

..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1062
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1062
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1062
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1062
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1062
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1062
  C:\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1062: PydanticDeprecatedSince20: `min_items` is deprecated and will be removed, use `min_length` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warn('`min_items` is deprecated and will be removed, use `min_length` instead', DeprecationWarning)

tests\integration\test_e2e_doctor_visit.py:154
  C:\final\backend\tests\integration\test_e2e_doctor_visit.py:154: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests\integration\test_e2e_doctor_visit.py:314
  C:\final\backend\tests\integration\test_e2e_doctor_visit.py:314: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests\integration\test_e2e_doctor_visit.py:352
  C:\final\backend\tests\integration\test_e2e_doctor_visit.py:352: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests\integration\test_e2e_patient_flow.py:140
  C:\final\backend\tests\integration\test_e2e_patient_flow.py:140: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests\integration\test_e2e_patient_flow.py:305
  C:\final\backend\tests\integration\test_e2e_patient_flow.py:305: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests\integration\test_e2e_payment_flow.py:92
  C:\final\backend\tests\integration\test_e2e_payment_flow.py:92: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests\integration\test_e2e_payment_flow.py:212
  C:\final\backend\tests\integration\test_e2e_payment_flow.py:212: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests\integration\test_e2e_payment_flow.py:247
  C:\final\backend\tests\integration\test_e2e_payment_flow.py:247: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
tests/integration/test_rbac_matrix.py::TestPositiveRBAC::test_admin_can_create_patient
tests/integration/test_rbac_matrix.py::TestPositiveRBAC::test_registrar_can_create_patient
tests/test_audit_logs.py::test_audit_log_create_patient
tests/test_audit_logs.py::test_audit_log_request_id
tests/test_audit_logs.py::test_audit_log_request_id
tests/test_audit_logs.py::test_audit_log_request_id
  C:\final\backend\app\crud\base.py:30: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    data: Dict[str, Any] = obj_in.dict(exclude_unset=True)

tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
tests/integration/test_rbac_matrix.py::TestPositiveRBAC::test_doctor_can_read_patient
tests/test_audit_logs.py::test_audit_log_update_patient
tests/test_audit_logs.py::test_audit_log_delete_patient
  C:\final\backend\app\crud\base.py:21: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    return db.query(self.model).get(id)

tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
  C:\final\backend\app\api\v1\endpoints\appointment_flow.py:389: PydanticDeprecatedSince20: The `from_orm` method is deprecated; set `model_config['from_attributes']=True` and use `model_validate` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    emr_dict = EMRSchema.from_orm(new_emr).dict()

tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
  C:\final\backend\app\api\v1\endpoints\appointment_flow.py:389: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    emr_dict = EMRSchema.from_orm(new_emr).dict()

tests/test_audit_logs.py::test_audit_log_update_patient
  C:\final\backend\app\crud\base.py:68: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    update_data = obj_in.dict(exclude_unset=True)

tests/test_audit_logs.py::test_audit_log_delete_patient
  C:\final\backend\app\crud\base.py:98: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    obj = db.query(self.model).get(id)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED tests/integration/test_api_integration.py::TestAPIIntegration::test_health_endpoint
FAILED tests/integration/test_api_integration.py::TestAPIIntegration::test_status_endpoint
FAILED tests/integration/test_api_integration.py::TestAPIIntegration::test_api_responsiveness
FAILED tests/integration/test_e2e_migration_flow.py::TestE2EMigrationFlow::test_complete_migration_flow
FAILED tests/integration/test_e2e_migration_flow.py::TestE2EMigrationFlow::test_migration_with_old_data_cleanup
FAILED tests/integration/test_e2e_migration_flow.py::TestE2EMigrationFlow::test_migration_service_direct_integration
FAILED tests/integration/test_e2e_migration_flow.py::TestE2EMigrationFlow::test_error_recovery_in_migration_flow
FAILED tests/integration/test_e2e_migration_flow.py::TestE2EMigrationFlow::test_concurrent_migration_operations
FAILED tests/integration/test_e2e_patient_flow.py::TestPatientAuthFlow::test_unauthorized_access_rejected
FAILED tests/integration/test_e2e_patient_flow.py::TestPatientAuthFlow::test_invalid_token_rejected
FAILED tests/integration/test_e2e_payment_flow.py::TestPaymentSecurity::test_invalid_amount_rejected
FAILED tests/integration/test_e2e_visit_flow.py::TestE2EVisitFlow::test_complete_visit_flow_future_date
FAILED tests/integration/test_e2e_visit_flow.py::TestE2EVisitFlow::test_morning_assignment_flow
FAILED tests/integration/test_e2e_visit_flow.py::TestE2EVisitFlow::test_registrar_confirmation_flow
FAILED tests/integration/test_e2e_visit_flow.py::TestE2EVisitFlow::test_multiple_services_queue_assignment
FAILED tests/integration/test_e2e_visit_flow.py::TestE2EVisitFlow::test_error_handling_in_flow
FAILED tests/integration/test_e2e_visit_flow.py::TestE2EVisitFlow::test_notification_integration
FAILED tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_restore_queue_data_file_not_found
FAILED tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_api_error_handling
FAILED tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_empty_services_list_error
FAILED tests/integration/test_server_integration.py::test_health_endpoint - r...
FAILED tests/integration/test_server_integration.py::test_status_endpoint - r...
FAILED tests/integration/test_server_integration.py::test_openapi_docs - requ...
FAILED tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_telegram_invalid_token
FAILED tests/test_2fa_enforcement.py::Test2FAEnforcement::test_admin_cannot_login_without_2fa
FAILED tests/test_2fa_enforcement.py::Test2FAEnforcement::test_cashier_cannot_login_without_2fa
FAILED tests/test_file_security.py::TestFileSecurity::test_file_hash_is_computed_on_upload
FAILED tests/test_file_security.py::TestFileSecurity::test_file_versioning_on_content_replace
FAILED tests/test_file_security.py::TestFileSecurity::test_file_hash_consistency
FAILED tests/test_file_security.py::TestFileSecurity::test_file_version_hash_required
FAILED tests/test_security_middleware.py::TestRateLimiting::test_rate_limit_login_endpoint
FAILED tests/test_security_middleware.py::TestRateLimiting::test_rate_limit_2fa_verify
FAILED tests/test_security_middleware.py::TestRateLimiting::test_rate_limit_password_reset
FAILED tests/test_security_middleware.py::TestRateLimiting::test_rate_limit_headers
FAILED tests/test_security_middleware.py::TestBruteForceProtection::test_brute_force_login_blocked
FAILED tests/test_security_middleware.py::TestBruteForceProtection::test_brute_force_2fa_blocked
FAILED tests/test_security_middleware.py::TestSecurityMiddlewareIntegration::test_rate_limit_reset_after_window
FAILED tests/unit/test_migration_service.py::TestMigrationService::test_get_or_create_daily_queue_existing
FAILED tests/unit/test_migration_service.py::TestMigrationService::test_check_data_integrity_empty_db
FAILED tests/unit/test_migration_service.py::TestMigrationService::test_backup_queue_data_empty
FAILED tests/unit/test_migration_service.py::TestMigrationService::test_cleanup_old_data_empty
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorVisitFlow::test_doctor_can_view_queue
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorVisitFlow::test_doctor_can_call_next_patient
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorVisitFlow::test_doctor_can_start_visit
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorVisitFlow::test_doctor_can_fill_emr
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorVisitFlow::test_doctor_can_use_emr_template
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorVisitFlow::test_doctor_can_add_diagnosis_with_ai_suggestion
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorVisitFlow::test_doctor_can_generate_prescription_pdf
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorVisitFlow::test_doctor_can_complete_visit
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorQueueManagement::test_doctor_can_skip_patient
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorQueueManagement::test_doctor_can_get_patient_history
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorSecurity::test_doctor_cannot_access_admin_routes
ERROR tests/integration/test_e2e_doctor_visit.py::TestDoctorSecurity::test_doctor_cannot_view_other_doctor_queue
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_can_view_appointments
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_can_view_single_appointment
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_can_cancel_future_appointment
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_cannot_cancel_soon_appointment
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_can_reschedule_appointment
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_can_get_available_slots
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_can_view_results
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_cannot_view_others_appointments
ERROR tests/integration/test_e2e_payment_flow.py::TestPaymentFlow::test_create_payment_for_visit
ERROR tests/integration/test_e2e_payment_flow.py::TestPaymentFlow::test_get_payment_status
ERROR tests/integration/test_e2e_payment_flow.py::TestPaymentFlow::test_payment_receipt_generation
ERROR tests/integration/test_e2e_visit_flow.py::TestE2EVisitFlow::test_complete_visit_flow_today
ERROR tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_check_data_integrity_with_data
ERROR tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_get_migration_stats_with_data
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_create_single_queue_entry_success
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_create_multiple_queue_entries_different_specialists
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_source_preservation
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_duplicate_detection
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_service_grouping_by_specialist
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_auto_create_daily_queue
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_patient_not_found_error
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_service_not_found_error
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_specialist_not_found_error
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_invalid_source_error
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_admin_access_allowed
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_registrar_access_allowed
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_doctor_access_denied
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_unauthenticated_access_denied
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_fair_queue_numbering
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_get_visit_info_success
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_get_visit_info_expired_token
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_telegram_success
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_telegram_wrong_channel
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_pwa_success
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_pwa_phone_mismatch
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_registrar_success
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_registrar_unauthorized
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_registrar_wrong_role
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_creates_queue_entry_today
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_no_queue_entry_future_date
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_updates_status
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_rate_limiting
ERROR tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_security_validation
ERROR tests/unit/test_confirmation_security.py::TestConfirmationSecurityService::test_validate_confirmation_request_valid_token
ERROR tests/unit/test_confirmation_security.py::TestConfirmationSecurityService::test_validate_confirmation_request_expired_token
ERROR tests/unit/test_confirmation_security.py::TestConfirmationSecurityService::test_validate_confirmation_request_wrong_status
ERROR tests/unit/test_confirmation_security.py::TestConfirmationSecurityService::test_validate_confirmation_request_suspicious_user_agent
ERROR tests/unit/test_confirmation_security.py::TestConfirmationSecurityService::test_record_confirmation_attempt_success
ERROR tests/unit/test_confirmation_security.py::TestConfirmationSecurityService::test_record_confirmation_attempt_failure
ERROR tests/unit/test_confirmation_security.py::TestConfirmationSecurityService::test_logging_security_events
ERROR tests/unit/test_migration_service.py::TestMigrationService::test_check_data_integrity_with_data
ERROR tests/unit/test_migration_service.py::TestMigrationService::test_backup_queue_data_with_data
=========== 41 failed, 156 passed, 88 warnings, 64 errors in 38.71s ===========
