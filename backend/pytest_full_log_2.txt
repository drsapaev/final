============================= test session starts =============================
platform win32 -- Python 3.11.1, pytest-8.4.1, pluggy-1.6.0
rootdir: C:\final\backend
configfile: pytest.ini
plugins: anyio-4.10.0, asyncio-1.1.0
asyncio: mode=Mode.STRICT, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 261 items

tests\integration\test_api_integration.py ...                            [  1%]
tests\integration\test_e2e_clinic.py .                                   [  1%]
tests\integration\test_e2e_doctor_visit.py ............                  [  6%]
tests\integration\test_e2e_migration_flow.py FFFFF                       [  8%]
tests\integration\test_e2e_patient_flow.py EEEEEEEEFF                    [ 11%]
tests\integration\test_e2e_payment_flow.py E..EE...F                     [ 15%]
tests\integration\test_e2e_visit_flow.py EFFFFFF                         [ 18%]
tests\integration\test_migration_management_api.py ....F.......F.....F   [ 25%]
tests\integration\test_online_queue_scenarios.py ......                  [ 27%]
tests\integration\test_queue_batch_api.py EEEEEEEEEEEEEEFE               [ 33%]
tests\integration\test_rbac_matrix.py ...................                [ 40%]
tests\integration\test_server_integration.py FFF                         [ 42%]
tests\integration\test_visit_confirmation_api.py F.FFFFFF...FFFF.        [ 48%]
tests\test_2fa_enforcement.py FF...                                      [ 50%]
tests\test_api_responses.py ....................                         [ 57%]
tests\test_audit_logs.py .............                                   [ 62%]
tests\test_file_security.py FF.FF                                        [ 64%]
tests\test_payment_model.py .                                            [ 65%]
tests\test_security_middleware.py FFFF.FF....F                           [ 69%]
tests\test_settings.py ........                                          [ 72%]
tests\test_validators.py ................................                [ 85%]
tests\unit\test_confirmation_security.py F.FFF..........                 [ 90%]
tests\unit\test_migration_service.py ....F..FFFF...F.....                [ 98%]
tests\unit\test_simple.py ....                                           [100%]

=================================== ERRORS ====================================
____ ERROR at setup of TestPatientFlow.test_patient_can_view_appointments _____

db_session = <sqlalchemy.orm.session.Session object at 0x0000020703625950>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x000002070368F210>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestPatientFlow.test_patient_can_view_single_appointment __

db_session = <sqlalchemy.orm.session.Session object at 0x00000207036658D0>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x00000207037EEC50>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestPatientFlow.test_patient_can_cancel_future_appointment _

db_session = <sqlalchemy.orm.session.Session object at 0x000002070362E350>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x0000020701972B90>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestPatientFlow.test_patient_cannot_cancel_soon_appointment _

db_session = <sqlalchemy.orm.session.Session object at 0x0000020703833210>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x0000020703320390>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
__ ERROR at setup of TestPatientFlow.test_patient_can_reschedule_appointment __

db_session = <sqlalchemy.orm.session.Session object at 0x0000020703627A90>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x00000207015E8C10>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
___ ERROR at setup of TestPatientFlow.test_patient_can_get_available_slots ____

db_session = <sqlalchemy.orm.session.Session object at 0x0000020703831DD0>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x0000020703833050>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______ ERROR at setup of TestPatientFlow.test_patient_can_view_results _______

db_session = <sqlalchemy.orm.session.Session object at 0x000002070179EDD0>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x000002070344A2D0>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_ ERROR at setup of TestPatientFlow.test_patient_cannot_view_others_appointments _

db_session = <sqlalchemy.orm.session.Session object at 0x00000207033DB150>

    @pytest.fixture
    def patient_user_with_data(db_session):
        """╤ючфрхЄ ярЎшхэЄр ё чряшё ьш ш Ёхчєы№ЄрЄрьш"""
        # ╤ючфрхь яюы№чютрЄхы -ярЎшхэЄр (phone эх эєцхэ т User)
        user = db_session.query(User).filter(User.username == "e2e_patient").first()
        if not user:
            user = User(
                username="e2e_patient",
                email="e2e_patient@test.com",
                full_name="╥хёЄ ╧рЎшхэЄют",
                hashed_password=get_password_hash("patient123"),
                role="Patient",
                is_active=True,
            )
            db_session.add(user)
            db_session.commit()
            db_session.refresh(user)
    
        # ╤ючфрхь чряшё№ ярЎшхэЄр
        patient = db_session.query(Patient).filter(Patient.phone == "+998901112233").first()
        if not patient:
>           patient = Patient(
                first_name="╥хёЄ",
                last_name="╧рЎшхэЄют",
                middle_name="╥хёЄютшў",
                phone="+998901112233",
                email="e2e_patient@test.com",
                birth_date=date(1990, 5, 15),
            )

tests\integration\test_e2e_patient_flow.py:52: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x0000020703414ED0>
kwargs = {'birth_date': datetime.date(1990, 5, 15), 'email': 'e2e_patient@test.com', 'first_name': '╥хёЄ', 'last_name': '╧рЎшхэЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
_______ ERROR at setup of TestPaymentFlow.test_create_payment_for_visit _______

db_session = <sqlalchemy.orm.session.Session object at 0x000002070368F3D0>

    @pytest.fixture
    def payment_test_data(db_session):
        """╤ючфрхЄ ЄхёЄют√х фрээ√х фы  яюЄюър юяырЄ√"""
        # ╧рЎшхэЄ
        patient = db_session.query(Patient).filter(Patient.phone == "+998901234999").first()
        if not patient:
>           patient = Patient(
                first_name="╬яырЄр",
                last_name="╥хёЄют",
                middle_name="╥хёЄютшў",
                phone="+998901234999",
                email="payment_test@test.com",
                birth_date=date(1995, 3, 20),
            )

tests\integration\test_e2e_payment_flow.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x000002070165C090>
kwargs = {'birth_date': datetime.date(1995, 3, 20), 'email': 'payment_test@test.com', 'first_name': '╬яырЄр', 'last_name': '╥хёЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg4OCwidHlwZSI6ImFjY2VzcyJ9.yhPXe6Mcrs8D6w9rd6x7XY6n6dB1yhn9Z-e9bTiRZ9Y', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiI4NzVkOWEyYy01YjVlLTQ1NTItYjZlMS02YzMwZjQ1YTk2NTAiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODM2NDA4OH0.XsC4OsiNR6l6jsGqaK_VSpuqn9RhtMV392LXapD05gw', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
__________ ERROR at setup of TestPaymentFlow.test_get_payment_status __________

db_session = <sqlalchemy.orm.session.Session object at 0x0000020703625450>

    @pytest.fixture
    def payment_test_data(db_session):
        """╤ючфрхЄ ЄхёЄют√х фрээ√х фы  яюЄюър юяырЄ√"""
        # ╧рЎшхэЄ
        patient = db_session.query(Patient).filter(Patient.phone == "+998901234999").first()
        if not patient:
>           patient = Patient(
                first_name="╬яырЄр",
                last_name="╥хёЄют",
                middle_name="╥хёЄютшў",
                phone="+998901234999",
                email="payment_test@test.com",
                birth_date=date(1995, 3, 20),
            )

tests\integration\test_e2e_payment_flow.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x00000207037EC410>
kwargs = {'birth_date': datetime.date(1995, 3, 20), 'email': 'payment_test@test.com', 'first_name': '╬яырЄр', 'last_name': '╥хёЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg4OCwidHlwZSI6ImFjY2VzcyJ9.yhPXe6Mcrs8D6w9rd6x7XY6n6dB1yhn9Z-e9bTiRZ9Y', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiJjMWIwN2JjMC0zODBkLTRjZDQtOTUwYi02NGEyN2U3NmRiOTgiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODM2NDA4OH0.XJbdyC6xsXHOLt1X9Utdsg56XZBma9xsj-1rywBrinY', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
______ ERROR at setup of TestPaymentFlow.test_payment_receipt_generation ______

db_session = <sqlalchemy.orm.session.Session object at 0x000002070172D3D0>

    @pytest.fixture
    def payment_test_data(db_session):
        """╤ючфрхЄ ЄхёЄют√х фрээ√х фы  яюЄюър юяырЄ√"""
        # ╧рЎшхэЄ
        patient = db_session.query(Patient).filter(Patient.phone == "+998901234999").first()
        if not patient:
>           patient = Patient(
                first_name="╬яырЄр",
                last_name="╥хёЄют",
                middle_name="╥хёЄютшў",
                phone="+998901234999",
                email="payment_test@test.com",
                birth_date=date(1995, 3, 20),
            )

tests\integration\test_e2e_payment_flow.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.patient.Patient object at 0x00000207032DE1D0>
kwargs = {'birth_date': datetime.date(1995, 3, 20), 'email': 'payment_test@test.com', 'first_name': '╬яырЄр', 'last_name': '╥хёЄют', ...}
cls_ = <class 'app.models.patient.Patient'>, k = 'email'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'email' is an invalid keyword argument for Patient

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg4OCwidHlwZSI6ImFjY2VzcyJ9.yhPXe6Mcrs8D6w9rd6x7XY6n6dB1yhn9Z-e9bTiRZ9Y', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiI3MzRkZjcyMS0xODdhLTRlOWQtOTNkOS00ZDY5NzRjZGQ4NzgiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODM2NDA4OH0.v3127qv-8jkFZcq5PoO5xnx_MOwiFD7rCPlb6aMGR14', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
______ ERROR at setup of TestE2EVisitFlow.test_complete_visit_flow_today ______

fixturedef = <FixtureDef argname='test_service' scope='function' baseid='tests'>
request = <SubRequest 'test_service' for <Function test_complete_visit_flow_today>>

    @pytest.hookimpl(wrapper=True)
    def pytest_fixture_setup(fixturedef: FixtureDef, request) -> object | None:
        asyncio_mode = _get_asyncio_mode(request.config)
        if not _is_asyncio_fixture_function(fixturedef.func):
            if asyncio_mode == Mode.STRICT:
                # Ignore async fixtures without explicit asyncio mark in strict mode
                # This applies to pytest_trio fixtures, for example
>               return (yield)
                        ^^^^^

C:\Program Files\Python311\Lib\site-packages\pytest_asyncio\plugin.py:681: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
tests\conftest.py:246: in test_service
    service = Service(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.service.Service object at 0x0000020704092B50>
kwargs = {'allow_doctor_price_override': False, 'code': 'TEST_CONS', 'description': '╥хёЄютр  ъюэёєы№ЄрЎш  ърЁфшюыюур', 'duration_minutes': 30, ...}
cls_ = <class 'app.models.service.Service'>, k = 'description'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'description' is an invalid keyword argument for Service

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg4OSwidHlwZSI6ImFjY2VzcyJ9.E0lFbh9uIcR4inRTv7PDsxGuQ6bJZbfPn7X9fBU-Kgk', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiI0MWZlNDU2NC1hZGQ4LTQwNmUtOGI2OC0wOGVlNmY1ZjJkOTQiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODM2NDA4OX0.ZkpheDbg6Pmzq2wpFke3E6_08odjQBTds3HumiJcwRg', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
_ ERROR at setup of TestQueueBatchAPI.test_create_single_queue_entry_success __

db_session = <sqlalchemy.orm.session.Session object at 0x00000207036CA150>

    @pytest.fixture(scope="function")
    def test_services(db_session):
        """╤ючфрхЄ ЄхёЄют√х єёыєуш"""
        services = []
    
        # ╙ёыєур 1: ╩юэёєы№ЄрЎш  ърЁфшюыюур
>       service1 = Service(
            code="CARDIO_CONS",
            name="╩юэёєы№ЄрЎш  ърЁфшюыюур",
            price=150000.00,
            duration_minutes=30,
            is_active=True,
            requires_doctor=True,
            queue_tag="cardiology_common",
            is_consultation=True
        )

tests\integration\test_queue_batch_api.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.service.Service object at 0x0000020702166390>
kwargs = {'code': 'CARDIO_CONS', 'duration_minutes': 30, 'is_active': True, 'is_consultation': True, ...}
cls_ = <class 'app.models.service.Service'>, k = 'is_active'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'is_active' is an invalid keyword argument for Service

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NzM4OTIsInR5cGUiOiJhY2Nlc3MifQ.ktstDDdGmaH8KJjSsHGLPfsea1U2fikJKVGUeZq5EPw', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiODJhYWJjOGItZjk2Yy00MzhhLTg5MzQtZmU4MTEyZTNmMTEyIiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzNjQwOTJ9.sbi4o1Y2IYtm6jwPMb7VSha-TXB-Lp281u6udsPOPkg', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
_ ERROR at setup of TestQueueBatchAPI.test_create_multiple_queue_entries_different_specialists _

self = <sqlalchemy.engine.base.Connection object at 0x0000020703975C10>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x00000207036D3310>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x0000020703B51340>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x00000207036D3310>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000002070362E350>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x0000020703B51340>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x00000207036D3310>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NzM4OTIsInR5cGUiOiJhY2Nlc3MifQ.ktstDDdGmaH8KJjSsHGLPfsea1U2fikJKVGUeZq5EPw', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiNjNhM2JiMGItYjBiZC00MjNiLWI0ZjgtNzIwZWE0NzQ3MjJkIiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzNjQwOTJ9.7-dQTUG_4PDN-RSY6uQId2cfZuTC4JDSHFSpcIOk2wI', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
________ ERROR at setup of TestQueueBatchAPI.test_source_preservation _________

self = <sqlalchemy.engine.base.Connection object at 0x0000020703901ED0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000002070377AB50>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x0000020704B79240>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000002070377AB50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000002070362D710>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x0000020704B79240>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000002070377AB50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NzM4OTMsInR5cGUiOiJhY2Nlc3MifQ.yQN3b17zlo4cyHdogSZqRS2oLm_TjGhiRzstwqpTXbo', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiNGY1NDE2YjEtNjczNy00NzIwLTk2OWEtZGRhZjBiNzJiZTgxIiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzNjQwOTN9.Y6cM011kj0J5QwVXZwVB8izxlebjLFsuoUGX5rVQzS8', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
________ ERROR at setup of TestQueueBatchAPI.test_duplicate_detection _________

self = <sqlalchemy.engine.base.Connection object at 0x00000207043345D0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000002070344AB50>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x0000020703E766C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000002070344AB50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000002070328AE50>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x0000020703E766C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000002070344AB50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NzM4OTMsInR5cGUiOiJhY2Nlc3MifQ.yQN3b17zlo4cyHdogSZqRS2oLm_TjGhiRzstwqpTXbo', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiY2I3YzQ2M2UtMjgyNC00NDMwLWFjZDYtMjFkODQ4YTI0YzZmIiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzNjQwOTN9.QxzaMCum2Li3ovNm38uF4XqctnW5bbHDeQzYc_ubOXU', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
___ ERROR at setup of TestQueueBatchAPI.test_service_grouping_by_specialist ___

self = <sqlalchemy.engine.base.Connection object at 0x0000020704089C10>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x00000207040BCA50>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x0000020704160EC0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x00000207040BCA50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x0000020701597610>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x0000020704160EC0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x00000207040BCA50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NzM4OTMsInR5cGUiOiJhY2Nlc3MifQ.yQN3b17zlo4cyHdogSZqRS2oLm_TjGhiRzstwqpTXbo', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiYThlNzgxNzUtMGU1ZC00NGRmLTk1MDMtNGM0YThlOWVmMGQ3IiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzNjQwOTN9.w-MWlbq29Bm6vy2AHaSJTj3PmNyoiVsnmbSGt6-iWek', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
______ ERROR at setup of TestQueueBatchAPI.test_auto_create_daily_queue _______

self = <sqlalchemy.engine.base.Connection object at 0x0000020701973810>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x0000020704557F50>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x0000020703E764C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x0000020704557F50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x00000207036D8650>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x0000020703E764C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x0000020704557F50>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NzM4OTQsInR5cGUiOiJhY2Nlc3MifQ.KAQeZBNF9EPqPh5iaoPlEB8ifyeOjpeIx4Hxcrqw5AU', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiMTk0OGJmM2ItNDIyMy00NzdiLThiYTMtNzE2ZmY1OTk4YzZlIiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzNjQwOTR9.QI6cSiO6w2azyodGgaFH4CsXmgO-lile_oCK8ojznoA', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
______ ERROR at setup of TestQueueBatchAPI.test_patient_not_found_error _______

self = <sqlalchemy.engine.base.Connection object at 0x0000020703F67910>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000002070443C9D0>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x00000207041CF940>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000002070443C9D0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x00000207033B2B10>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x00000207041CF940>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x000002070443C9D0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NzM4OTQsInR5cGUiOiJhY2Nlc3MifQ.KAQeZBNF9EPqPh5iaoPlEB8ifyeOjpeIx4Hxcrqw5AU', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiODg4ZmJiMjEtYzk0Yi00NDFhLWFhYjMtZDM4NzA4NWVmNzY2IiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzNjQwOTR9.01Z4vBp0p35JHugkhrM31OEeQ08uy0rJsq-vsbhq2oA', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
______ ERROR at setup of TestQueueBatchAPI.test_service_not_found_error _______

self = <sqlalchemy.engine.base.Connection object at 0x0000020703D59A90>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x00000207040A7010>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x0000020703B65440>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x00000207040A7010>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x0000020703E9AC90>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x0000020703B65440>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x00000207040A7010>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NzM4OTQsInR5cGUiOiJhY2Nlc3MifQ.KAQeZBNF9EPqPh5iaoPlEB8ifyeOjpeIx4Hxcrqw5AU', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiMjAzMTc2MjYtOWY2OS00MjMzLWFmMTktMjIxNmNhMjk2MWY5IiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzNjQwOTR9.oXy0taXRWa_9z4LR8vxwVKx_vkJAnuGAevSd0ZeDSZ0', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
_____ ERROR at setup of TestQueueBatchAPI.test_specialist_not_found_error _____

db_session = <sqlalchemy.orm.session.Session object at 0x000002070422FA50>

    @pytest.fixture(scope="function")
    def test_services(db_session):
        """╤ючфрхЄ ЄхёЄют√х єёыєуш"""
        services = []
    
        # ╙ёыєур 1: ╩юэёєы№ЄрЎш  ърЁфшюыюур
>       service1 = Service(
            code="CARDIO_CONS",
            name="╩юэёєы№ЄрЎш  ърЁфшюыюур",
            price=150000.00,
            duration_minutes=30,
            is_active=True,
            requires_doctor=True,
            queue_tag="cardiology_common",
            is_consultation=True
        )

tests\integration\test_queue_batch_api.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.service.Service object at 0x000002070406D290>
kwargs = {'code': 'CARDIO_CONS', 'duration_minutes': 30, 'is_active': True, 'is_consultation': True, ...}
cls_ = <class 'app.models.service.Service'>, k = 'is_active'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'is_active' is an invalid keyword argument for Service

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NzM4OTUsInR5cGUiOiJhY2Nlc3MifQ.AkK1O_PtPzG8Hgf6cvZ_7l0v6YQGAzy7ES9B1NBNB98', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiNDQxMmM2YWQtZTkzOC00NGY5LTkzZjUtOWM0MDgwM2E4YzE4IiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzNjQwOTV9.JlM1nARaJLK2mz3aUobLZB7yMxANrqrHPSIW2aivKO8', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
________ ERROR at setup of TestQueueBatchAPI.test_invalid_source_error ________

self = <sqlalchemy.engine.base.Connection object at 0x0000020703B04490>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x00000207036D3450>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x00000207037531C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x00000207036D3450>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000002070393D950>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x00000207037531C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x00000207036D3450>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NzM4OTUsInR5cGUiOiJhY2Nlc3MifQ.AkK1O_PtPzG8Hgf6cvZ_7l0v6YQGAzy7ES9B1NBNB98', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiYTk1OWM3OWUtZTRjNS00NDU4LWJmYjUtNmExZWE5YTA2MGI5IiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzNjQwOTV9.lMOsAnokXhef67rsG5DOyMbuggqaGI_Z2DOemUcRGXs', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
________ ERROR at setup of TestQueueBatchAPI.test_admin_access_allowed ________

self = <sqlalchemy.engine.base.Connection object at 0x00000207036E77D0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x0000020703921DD0>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x0000020704650FC0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x0000020703921DD0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000002070362E190>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x0000020704650FC0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x0000020703921DD0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg5NSwidHlwZSI6ImFjY2VzcyJ9.bKe_TGg5z-8XdT2nUts-S8jTTUJKGzmoZfPCttRbmvI', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiI0NDcwYzIxNC1mMGJjLTQzZDgtYjNmMi1kY2QxZGY3MDkzYjMiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODM2NDA5NX0.fyibVNez3muLAjtbAy5ziidH4aF3URIf1RNVbQ9BVtc', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
______ ERROR at setup of TestQueueBatchAPI.test_registrar_access_allowed ______

self = <sqlalchemy.engine.base.Connection object at 0x0000020704091BD0>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x0000020703CD6650>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x00000207038D8740>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x0000020703CD6650>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000002070421CFD0>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x00000207038D8740>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x0000020703CD6650>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NzM4OTYsInR5cGUiOiJhY2Nlc3MifQ.zfGOJUXG6-cYPjC2kRZh6xfpbh_OjBwdOGghUbdvx6k', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiYTAyZmI1ZWUtODljMC00MzMwLWI1ZWYtODJjMmY4ZGNhZDhhIiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzNjQwOTZ9.96OTosJj4-QX2kjNezM8NJYSgAGG0jK9KXOF82yMmW0', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
________ ERROR at setup of TestQueueBatchAPI.test_doctor_access_denied ________

self = <sqlalchemy.engine.base.Connection object at 0x00000207041C6890>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x0000020704040850>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x00000207041601C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x0000020704040850>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x00000207036D8150>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x00000207041601C0>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x0000020704040850>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_cardio
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 5, 'username': 'test_cardio', 'full_name': 'Test Cardiologist', 'email': 'cardio@test.com', 'role': 'cardio', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI1IiwidXNlcm5hbWUiOiJ0ZXN0X2NhcmRpbyIsInJvbGUiOiJjYXJkaW8iLCJpc19hY3RpdmUiOnRydWUsImlzX3N1cGVydXNlciI6ZmFsc2UsImV4cCI6MTc2NTc3Mzg5NiwidHlwZSI6ImFjY2VzcyJ9.ep5l3i3JZMkCDXqYICS3aKtvFU67YsLlMgDhAL2tXt0', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo1LCJqdGkiOiIzNTdkOGVlOC1lZWIyLTQ2MDUtYTg5My0yMzViMGRjZmM5MTQiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODM2NDA5Nn0.EuVjqVlSaHbfSyvlXxq5TOunLJOFKsNK09g4jMWfl4I', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
___ ERROR at setup of TestQueueBatchAPI.test_unauthenticated_access_denied ____

self = <sqlalchemy.engine.base.Connection object at 0x0000020704017550>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x0000020703B7E4D0>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x0000020703E76940>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x0000020703B7E4D0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x0000020703920E50>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x0000020703E76940>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x0000020703B7E4D0>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
________ ERROR at setup of TestQueueBatchAPI.test_fair_queue_numbering ________

self = <sqlalchemy.engine.base.Connection object at 0x0000020703C0E510>
dialect = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x0000020704058350>

    def _exec_insertmany_context(
        self,
        dialect: Dialect,
        context: ExecutionContext,
    ) -> CursorResult[Any]:
        """continue the _execute_context() method for an "insertmanyvalues"
        operation, which will invoke DBAPI
        cursor.execute() one or more times with individual log and
        event hook calls.
    
        """
    
        if dialect.bind_typing is BindTyping.SETINPUTSIZES:
            generic_setinputsizes = context._prepare_set_input_sizes()
        else:
            generic_setinputsizes = None
    
        cursor, str_statement, parameters = (
            context.cursor,
            context.statement,
            context.parameters,
        )
    
        effective_parameters = parameters
    
        engine_events = self._has_events or self.engine._has_events
        if self.dialect._has_events:
            do_execute_dispatch: Iterable[Any] = (
                self.dialect.dispatch.do_execute
            )
        else:
            do_execute_dispatch = ()
    
        if self._echo:
            stats = context._get_cache_stats() + " (insertmanyvalues)"
    
        preserve_rowcount = context.execution_options.get(
            "preserve_rowcount", False
        )
        rowcount = 0
    
        for imv_batch in dialect._deliver_insertmanyvalues_batches(
            self,
            cursor,
            str_statement,
            effective_parameters,
            generic_setinputsizes,
            context,
        ):
            if imv_batch.processed_setinputsizes:
                try:
                    dialect.do_set_input_sizes(
                        context.cursor,
                        imv_batch.processed_setinputsizes,
                        context,
                    )
                except BaseException as e:
                    self._handle_dbapi_exception(
                        e,
                        sql_util._long_statement(imv_batch.replaced_statement),
                        imv_batch.replaced_parameters,
                        None,
                        context,
                        is_sub_exec=True,
                    )
    
            sub_stmt = imv_batch.replaced_statement
            sub_params = imv_batch.replaced_parameters
    
            if engine_events:
                for fn in self.dispatch.before_cursor_execute:
                    sub_stmt, sub_params = fn(
                        self,
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                        True,
                    )
    
            if self._echo:
                self._log_info(sql_util._long_statement(sub_stmt))
    
                imv_stats = f""" {imv_batch.batchnum}/{
                            imv_batch.total_batches
                } ({
                    'ordered'
                    if imv_batch.rows_sorted else 'unordered'
                }{
                    '; batch not supported'
                    if imv_batch.is_downgraded
                    else ''
                })"""
    
                if imv_batch.batchnum == 1:
                    stats += imv_stats
                else:
                    stats = f"insertmanyvalues{imv_stats}"
    
                if not self.engine.hide_parameters:
                    self._log_info(
                        "[%s] %r",
                        stats,
                        sql_util._repr_params(
                            sub_params,
                            batches=10,
                            ismulti=False,
                        ),
                    )
                else:
                    self._log_info(
                        "[%s] [SQL parameters hidden due to "
                        "hide_parameters=True]",
                        stats,
                    )
    
            try:
                for fn in do_execute_dispatch:
                    if fn(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    ):
                        break
                else:
>                   dialect.do_execute(
                        cursor,
                        sub_stmt,
                        sub_params,
                        context,
                    )

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x0000020703E0DE40>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x0000020704058350>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlite3.IntegrityError: UNIQUE constraint failed: users.username

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError

The above exception was the direct cause of the following exception:

db_session = <sqlalchemy.orm.session.Session object at 0x000002070407A190>

    @pytest.fixture(scope="function")
    def test_specialists(db_session):
        """╤ючфрхЄ ЄхёЄют√ї ёяхЎшрышёЄют"""
        specialists = []
    
        # ╤яхЎшрышёЄ 1: ╩рЁфшюыюу
        cardio = User(
            username="cardio_specialist",
            email="cardio@clinic.com",
            full_name="╩рЁфшюыюу ╚трэют",
            hashed_password="hashed",
            role="cardio",
            is_active=True
        )
        db_session.add(cardio)
        specialists.append(cardio)
    
        # ╤яхЎшрышёЄ 2: ╦рсюЁрэЄ
        lab = User(
            username="lab_specialist",
            email="lab@clinic.com",
            full_name="╦рсюЁрэЄ ╧хЄЁютр",
            hashed_password="hashed",
            role="Lab",
            is_active=True
        )
        db_session.add(lab)
        specialists.append(lab)
    
>       db_session.commit()

tests\integration\test_queue_batch_api.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:2032: in commit
    trans.commit(_to_root=True)
<string>:2: in commit
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1313: in commit
    self._prepare_impl()
<string>:2: in _prepare_impl
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state_changes.py:137: in _go
    ret_value = fn(self, *arg, **kw)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:1288: in _prepare_impl
    self.session.flush()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4345: in flush
    self._flush(objects)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4480: in _flush
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\session.py:4441: in _flush
    flush_context.execute()
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:466: in execute
    rec.execute(self)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\unitofwork.py:642: in execute
    util.preloaded.orm_persistence.save_obj(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:93: in save_obj
    _emit_insert_statements(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\persistence.py:1143: in _emit_insert_statements
    result = connection.execute(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1419: in execute
    return meth(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\sql\elements.py:526: in _execute_on_connection
    return connection._execute_clauseelement(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1641: in _execute_clauseelement
    ret = self._execute_context(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:1844: in _execute_context
    return self._exec_insertmany_context(dialect, context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2126: in _exec_insertmany_context
    self._handle_dbapi_exception(
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2355: in _handle_dbapi_exception
    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\base.py:2118: in _exec_insertmany_context
    dialect.do_execute(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <sqlalchemy.dialects.sqlite.pysqlite.SQLiteDialect_pysqlite object at 0x000002070179ED10>
cursor = <sqlite3.Cursor object at 0x0000020703E0DE40>
statement = 'INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at'
parameters = ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, ...)
context = <sqlalchemy.dialects.sqlite.base.SQLiteExecutionContext object at 0x0000020704058350>

    def do_execute(self, cursor, statement, parameters, context=None):
>       cursor.execute(statement, parameters)
E       sqlalchemy.exc.IntegrityError: (sqlite3.IntegrityError) UNIQUE constraint failed: users.username
E       [SQL: INSERT INTO users (username, full_name, email, hashed_password, role, is_active, is_superuser) VALUES (?, ?, ?, ?, ?, ?, ?) RETURNING id, created_at, updated_at]
E       [parameters: ('cardio_specialist', '╩рЁфшюыюу ╚трэют', 'cardio@clinic.com', 'hashed', 'cardio', 1, 0)]
E       (Background on this error at: https://sqlalche.me/e/20/gkpj)

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\engine\default.py:951: IntegrityError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NzM4OTcsInR5cGUiOiJhY2Nlc3MifQ.VKZZl71Oh7CAmLyuCRbqcpos32scBb3YnLZw2nBa2b8', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiMTc0ODMyMTEtZDM1MS00NzFjLWFjZWYtZWQ0NWEwNjI5NGU1IiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzNjQwOTd9.hQoCnprUTzpvFes0TijuXSOyHTne_d7luAIDz7faNoc', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
================================== FAILURES ===================================
______________ TestE2EMigrationFlow.test_complete_migration_flow ______________

self = <test_e2e_migration_flow.TestE2EMigrationFlow object at 0x00000207015EAC10>
client = <starlette.testclient.TestClient object at 0x00000207034211D0>
db_session = <sqlalchemy.orm.session.Session object at 0x0000020703420C90>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg4NiwidHlwZSI6ImFjY2VzcyJ9.cASKleCCuHXfGWW6cgpTJAZoTImxGc8ZkSBDQky-d98'}
cardio_user = <app.models.user.User object at 0x000002070343E090>
test_patient = <app.models.patient.Patient object at 0x000002070343C4D0>

    def test_complete_migration_flow(self, client, db_session, auth_headers, cardio_user, test_patient):
        """
        ╧юыэ√щ E2E ЄхёЄ ьшуЁрЎшш:
        \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0434\u0430\u043d\u043d\u044b\u0445 \u2192 \u0420\u0435\u0437\u0435\u0440\u0432\u043d\u043e\u0435 \u043a\u043e\u043f\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 \u2192 \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0446\u0435\u043b\u043e\u0441\u0442\u043d\u043e\u0441\u0442\u0438 \u2192 \u041e\u0447\u0438\u0441\u0442\u043a\u0430
        """
        # ╪└├ 1: ╤ючфрхь ЄхёЄют√х фрээ√х юўхЁхфхщ
        test_date = date.today()
    
        # ╤ючфрхь фэхтэє■ юўхЁхф№
        daily_queue = DailyQueue(
            day=test_date,
            specialist_id=cardio_user.id,
            queue_tag="test_migration_queue",
            active=True,
            opened_at=datetime.utcnow()
        )
        db_session.add(daily_queue)
        db_session.commit()
    
        # ╤ючфрхь чряшёш т юўхЁхфш
        queue_entries = []
        for i in range(3):
            entry = OnlineQueueEntry(
                queue_id=daily_queue.id,
                number=i + 1,
                patient_id=test_patient.id if i == 0 else None,
                patient_name=f"╥хёЄют√щ ╧рЎшхэЄ {i + 1}",
                phone=f"+99890123456{i}",
                telegram_id=123456789 + i,
                source="test_migration",
                status="waiting" if i < 2 else "served"
            )
            queue_entries.append(entry)
            db_session.add(entry)
    
        db_session.commit()
    
        # ╪└├ 2: ╧ЁютхЁ хь ёюёЄю эшх ёшёЄхь√ ьшуЁрЎшщ
        health_response = client.get("/api/v1/admin/migration/health", headers=auth_headers)
        assert health_response.status_code == 200
    
        health_data = health_response.json()
>       assert health_data["healthy"] is True
E       assert False is True

tests\integration\test_e2e_migration_flow.py:63: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg4NiwidHlwZSI6ImFjY2VzcyJ9.cASKleCCuHXfGWW6cgpTJAZoTImxGc8ZkSBDQky-d98', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiI4ZjkzNzA0OS0zY2UzLTRiMmUtYmE0Zi04OThkZGRjNGI2ODMiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODM2NDA4Nn0.W-15WYQIrddG7O2IwPBa_3NxaKVkx-OP-rSWBOXplm4', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
__________ TestE2EMigrationFlow.test_migration_with_old_data_cleanup __________

self = <test_e2e_migration_flow.TestE2EMigrationFlow object at 0x00000207015EB250>
client = <starlette.testclient.TestClient object at 0x000002070340EFD0>
db_session = <sqlalchemy.orm.session.Session object at 0x000002070340E890>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg4NywidHlwZSI6ImFjY2VzcyJ9.g6tWUi56xS7SwQrviCdqoRQAqUZciXclHHyaKGQHVM0'}
cardio_user = <app.models.user.User object at 0x000002070197C9D0>

    def test_migration_with_old_data_cleanup(self, client, db_session, auth_headers, cardio_user):
        """
        E2E ЄхёЄ ё юўшёЄъющ ёЄрЁ√ї фрээ√ї:
        \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0441\u0442\u0430\u0440\u044b\u0445 \u0434\u0430\u043d\u043d\u044b\u0445 \u2192 \u041e\u0447\u0438\u0441\u0442\u043a\u0430 \u2192 \u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430
        """
        # ╪└├ 1: ╤ючфрхь ёЄрЁ√х фрээ√х (40 фэхщ эрчрф)
        old_date = date.today() - timedelta(days=40)
    
        old_queue = DailyQueue(
            day=old_date,
            specialist_id=cardio_user.id,
            queue_tag="old_test_queue",
            active=False
        )
        db_session.add(old_queue)
        db_session.commit()
    
        # ─юсрты хь чряшёш т ёЄрЁє■ юўхЁхф№
        for i in range(2):
            entry = OnlineQueueEntry(
                queue_id=old_queue.id,
                number=i + 1,
                patient_name=f"╤ЄрЁ√щ ╧рЎшхэЄ {i + 1}",
                phone=f"+99890111111{i}",
                source="old_test_data",
                status="served"
            )
            db_session.add(entry)
    
        db_session.commit()
    
        # ╪└├ 2: ╤ючфрхь эют√х фрээ√х (ёхуюфэ )
        new_queue = DailyQueue(
            day=date.today(),
            specialist_id=cardio_user.id,
            queue_tag="new_test_queue",
            active=True
        )
        db_session.add(new_queue)
        db_session.commit()
    
        new_entry = OnlineQueueEntry(
            queue_id=new_queue.id,
            number=1,
            patient_name="═ют√щ ╧рЎшхэЄ",
            phone="+998901234567",
            source="new_test_data",
            status="waiting"
        )
        db_session.add(new_entry)
        db_session.commit()
    
        # ╪└├ 3: ╧юыєўрхь ёЄрЄшёЄшъє фю юўшёЄъш
        stats_before = client.get("/api/v1/admin/migration/stats", headers=auth_headers)
        assert stats_before.status_code == 200
    
        stats_before_data = stats_before.json()
        queues_before = stats_before_data["queue_statistics"]["total_queues"]
        entries_before = stats_before_data["entry_statistics"]["total_entries"]
    
        # ╪└├ 4: ╟ряєёърхь юўшёЄъє ёЄрЁ√ї фрээ√ї (юёЄрты хь 30 фэхщ)
        cleanup_response = client.post(
            "/api/v1/admin/migration/cleanup-old-data?days_to_keep=30",
            headers=auth_headers
        )
    
        assert cleanup_response.status_code == 200
        cleanup_data = cleanup_response.json()
    
        assert cleanup_data["success"] is True
        assert cleanup_data["deleted_queues"] >= 1
        assert cleanup_data["deleted_entries"] >= 2
    
        cutoff_date = datetime.fromisoformat(cleanup_data["cutoff_date"]).date()
        expected_cutoff = date.today() - timedelta(days=30)
        assert cutoff_date == expected_cutoff
    
        # ╪└├ 5: ╧ЁютхЁ хь ўЄю ёЄрЁ√х фрээ√х єфрышышё№
        remaining_old_queues = db_session.query(DailyQueue).filter(
            DailyQueue.day < cutoff_date
        ).count()
        assert remaining_old_queues == 0
    
        # ╪└├ 6: ╧ЁютхЁ хь ўЄю эют√х фрээ√х юёЄрышё№
        remaining_new_queues = db_session.query(DailyQueue).filter(
            DailyQueue.day >= cutoff_date
        ).count()
        assert remaining_new_queues >= 1
    
        # ╪└├ 7: ╧юыєўрхь ёЄрЄшёЄшъє яюёых юўшёЄъш
        stats_after = client.get("/api/v1/admin/migration/stats", headers=auth_headers)
        assert stats_after.status_code == 200
    
        stats_after_data = stats_after.json()
        queues_after = stats_after_data["queue_statistics"]["total_queues"]
        entries_after = stats_after_data["entry_statistics"]["total_entries"]
    
        # ╧ЁютхЁ хь ўЄю ъюышўхёЄтю єьхэ№°шыюё№
        assert queues_after < queues_before
>       assert entries_after < entries_before
E       assert 42 < 42

tests\integration\test_e2e_migration_flow.py:276: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg4NywidHlwZSI6ImFjY2VzcyJ9.g6tWUi56xS7SwQrviCdqoRQAqUZciXclHHyaKGQHVM0', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiI4MWVlYTAzNS02MDlmLTQ4MDctYjE4MC1kZjliYWUxYWNkNGMiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODM2NDA4N30.K9eIUACaiIgBltFXu6eYfp7b3BHiygmoqIQdmQMRKsA', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
_______ TestE2EMigrationFlow.test_migration_service_direct_integration ________

self = <test_e2e_migration_flow.TestE2EMigrationFlow object at 0x00000207015DCFD0>
db_session = <sqlalchemy.orm.session.Session object at 0x00000207033EDF50>
cardio_user = <app.models.user.User object at 0x000002070340D250>
test_patient = <app.models.patient.Patient object at 0x00000207033C5D10>

    def test_migration_service_direct_integration(self, db_session, cardio_user, test_patient):
        """
        E2E ЄхёЄ яЁ ьюую шёяюы№чютрэш  MigrationService
        """
        # ╪└├ 1: ╤ючфрхь ёхЁтшё ьшуЁрЎшщ
        migration_service = MigrationService(db_session)
    
        # ╪└├ 2: ╤ючфрхь ЄхёЄют√х фрээ√х
        test_queue = DailyQueue(
            day=date.today(),
            specialist_id=cardio_user.id,
            queue_tag="direct_test_queue",
            active=True
        )
        db_session.add(test_queue)
        db_session.commit()
    
        test_entry = OnlineQueueEntry(
            queue_id=test_queue.id,
            number=1,
            patient_id=test_patient.id,
            patient_name=test_patient.short_name(),
            phone=test_patient.phone,
            source="direct_test",
            status="waiting"
        )
        db_session.add(test_entry)
        db_session.commit()
    
        # ╪└├ 3: ╧ЁютхЁ хь ЎхыюёЄэюёЄ№ фрээ√ї
        integrity_result = migration_service._check_data_integrity()
>       assert integrity_result["passed"] is True
E       assert False is True

tests\integration\test_e2e_migration_flow.py:316: AssertionError
_________ TestE2EMigrationFlow.test_error_recovery_in_migration_flow __________

self = <test_e2e_migration_flow.TestE2EMigrationFlow object at 0x00000207015E87D0>
client = <starlette.testclient.TestClient object at 0x00000207033C5DD0>
db_session = <sqlalchemy.orm.session.Session object at 0x00000207033EF890>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg4NywidHlwZSI6ImFjY2VzcyJ9.g6tWUi56xS7SwQrviCdqoRQAqUZciXclHHyaKGQHVM0'}

    def test_error_recovery_in_migration_flow(self, client, db_session, auth_headers):
        """
        E2E ЄхёЄ тюёёЄрэютыхэш  яюёых ю°шсюъ т яЁюЎхёёх ьшуЁрЎшш
        """
        # ╪└├ 1: ╧юя√Єър тюёёЄрэютыхэш  шч эхёє∙хёЄтє■∙хую Їрщыр
        restore_response = client.post(
            "/api/v1/admin/migration/restore-queue-data?backup_file=nonexistent.json",
            headers=auth_headers
        )
    
>       assert restore_response.status_code == 500
E       assert 200 == 500
E        +  where 200 = <Response [200 OK]>.status_code

tests\integration\test_e2e_migration_flow.py:367: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg4NywidHlwZSI6ImFjY2VzcyJ9.g6tWUi56xS7SwQrviCdqoRQAqUZciXclHHyaKGQHVM0', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiJiODY0NTQ1NC0zYTgyLTQwMzAtYjA0Yy03YmE4MTZiN2MzYTkiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODM2NDA4N30.JbE3P-GmMFPgE0z-h6QlzEsVC1fMPC1Q4yRZOltGL4o', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
---------------------------- Captured stderr call -----------------------------
ERROR:app.services.migration_service:╬°шсър тюёёЄрэютыхэш  фрээ√ї: [Errno 2] No such file or directory: 'nonexistent.json'
------------------------------ Captured log call ------------------------------
ERROR    app.services.migration_service:migration_service.py:499 ╬°шсър тюёёЄрэютыхэш  фрээ√ї: [Errno 2] No such file or directory: 'nonexistent.json'
__________ TestE2EMigrationFlow.test_concurrent_migration_operations __________

self = <test_e2e_migration_flow.TestE2EMigrationFlow object at 0x00000207015EB710>
client = <starlette.testclient.TestClient object at 0x00000207034480D0>
db_session = <sqlalchemy.orm.session.Session object at 0x000002070344A0D0>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg4NywidHlwZSI6ImFjY2VzcyJ9.g6tWUi56xS7SwQrviCdqoRQAqUZciXclHHyaKGQHVM0'}
cardio_user = <app.models.user.User object at 0x00000207036CAA50>

    def test_concurrent_migration_operations(self, client, db_session, auth_headers, cardio_user):
        """
        E2E ЄхёЄ ярЁрыыхы№э√ї юяхЁрЎшщ ьшуЁрЎшш
        """
        # ╪└├ 1: ╤ючфрхь фрээ√х фы  ЄхёЄшЁютрэш 
        test_queue = DailyQueue(
            day=date.today(),
            specialist_id=cardio_user.id,
            queue_tag="concurrent_test_queue",
            active=True
        )
        db_session.add(test_queue)
        db_session.commit()
    
        # ╪└├ 2: ╟ряєёърхь эхёъюы№ъю юяхЁрЎшщ ярЁрыыхы№эю
        # (┬ Ёхры№эюь ЄхёЄх ¤Єю с√ыю с√ ё threading, эю фы  яЁюёЄюЄ√ фхырхь яюёыхфютрЄхы№эю)
    
        # ╧ЁютхЁър ЎхыюёЄэюёЄш
        integrity_response = client.get("/api/v1/admin/migration/check-integrity", headers=auth_headers)
        assert integrity_response.status_code == 200
    
        # ╧юыєўхэшх ёЄрЄшёЄшъш
        stats_response = client.get("/api/v1/admin/migration/stats", headers=auth_headers)
        assert stats_response.status_code == 200
    
        # ╧ЁютхЁър чфюЁют№  ёшёЄхь√
        health_response = client.get("/api/v1/admin/migration/health", headers=auth_headers)
        assert health_response.status_code == 200
    
        # ╪└├ 3: ╧ЁютхЁ хь ўЄю тёх юяхЁрЎшш чртхЁ°шышё№ єёях°эю
>       assert integrity_response.json()["passed"] is True
E       assert False is True

tests\integration\test_e2e_migration_flow.py:425: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg4NywidHlwZSI6ImFjY2VzcyJ9.g6tWUi56xS7SwQrviCdqoRQAqUZciXclHHyaKGQHVM0', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiJkZTE5YTMyNi1mZWEyLTQwYzktOGIwOC03MjVmZmVjZTc3OTkiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODM2NDA4N30.uwTxR0agzgx_XF81VFWke2pOg8MBmVTN561dH0-bQHQ', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
____________ TestPatientAuthFlow.test_unauthorized_access_rejected ____________

self = <test_e2e_patient_flow.TestPatientAuthFlow object at 0x0000020701604AD0>
client = <starlette.testclient.TestClient object at 0x000002070158EBD0>

    def test_unauthorized_access_rejected(self, client: TestClient):
        """═хртЄюЁшчютрээ√щ фюёЄєя юЄъыюэ хЄё """
        response = client.get("/api/v1/patient/appointments")
>       assert response.status_code == 401
E       assert 404 == 401
E        +  where 404 = <Response [404 Not Found]>.status_code

tests\integration\test_e2e_patient_flow.py:312: AssertionError
_______________ TestPatientAuthFlow.test_invalid_token_rejected _______________

self = <test_e2e_patient_flow.TestPatientAuthFlow object at 0x0000020701605150>
client = <starlette.testclient.TestClient object at 0x0000020703386710>

    def test_invalid_token_rejected(self, client: TestClient):
        """═хтрышфэ√щ Єюъхэ юЄъыюэ хЄё """
        response = client.get(
            "/api/v1/patient/appointments",
            headers={"Authorization": "Bearer invalid_token_here"},
        )
>       assert response.status_code in [401, 403]
E       assert 404 in [401, 403]
E        +  where 404 = <Response [404 Not Found]>.status_code

tests\integration\test_e2e_patient_flow.py:320: AssertionError
______________ TestPaymentSecurity.test_invalid_amount_rejected _______________
  + Exception Group Traceback (most recent call last):
  |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 76, in collapse_excgroups
  |     yield
  |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 177, in __call__
  |     async with anyio.create_task_group() as task_group:
  |   File "C:\Program Files\Python311\Lib\site-packages\anyio\_backends\_asyncio.py", line 772, in __aexit__
  |     raise BaseExceptionGroup(
  | ExceptionGroup: unhandled errors in a TaskGroup (1 sub-exception)
  +-+---------------- 1 ----------------
    | Traceback (most recent call last):
    |   File "C:\Program Files\Python311\Lib\site-packages\_pytest\runner.py", line 344, in from_call
    |     result: TResult | None = func()
    |                              ^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\_pytest\runner.py", line 246, in <lambda>
    |     lambda: runtest_hook(item=item, **kwds), when=when, reraise=reraise
    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_hooks.py", line 512, in __call__
    |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_manager.py", line 120, in _hookexec
    |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_callers.py", line 167, in _multicall
    |     raise exception
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |   File "C:\Program Files\Python311\Lib\site-packages\_pytest\logging.py", line 850, in pytest_runtest_call
    |     yield
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |   File "C:\Program Files\Python311\Lib\site-packages\_pytest\capture.py", line 900, in pytest_runtest_call
    |     return (yield)
    |             ^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |   File "C:\Program Files\Python311\Lib\site-packages\_pytest\skipping.py", line 263, in pytest_runtest_call
    |     return (yield)
    |             ^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_callers.py", line 121, in _multicall
    |     res = hook_impl.function(*args)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\_pytest\runner.py", line 178, in pytest_runtest_call
    |     item.runtest()
    |   File "C:\Program Files\Python311\Lib\site-packages\_pytest\python.py", line 1671, in runtest
    |     self.ihook.pytest_pyfunc_call(pyfuncitem=self)
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_hooks.py", line 512, in __call__
    |     return self._hookexec(self.name, self._hookimpls.copy(), kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_manager.py", line 120, in _hookexec
    |     return self._inner_hookexec(hook_name, methods, kwargs, firstresult)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_callers.py", line 167, in _multicall
    |     raise exception
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_callers.py", line 139, in _multicall
    |     teardown.throw(exception)
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_callers.py", line 53, in run_old_style_hookwrapper
    |     return result.get_result()
    |            ^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_result.py", line 103, in get_result
    |     raise exc.with_traceback(tb)
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_callers.py", line 38, in run_old_style_hookwrapper
    |     res = yield
    |           ^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\pluggy\_callers.py", line 121, in _multicall
    |     res = hook_impl.function(*args)
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\_pytest\python.py", line 157, in pytest_pyfunc_call
    |     result = testfunction(**testargs)
    |              ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\final\backend\tests\integration\test_e2e_payment_flow.py", line 258, in test_invalid_amount_rejected
    |     response = client.post(
    |                ^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py", line 538, in post
    |     return super().post(
    |            ^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 1157, in post
    |     return self.request(
    |            ^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py", line 437, in request
    |     return super().request(
    |            ^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 837, in request
    |     return self.send(request, auth=auth, follow_redirects=follow_redirects)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 926, in send
    |     response = self._send_handling_auth(
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 954, in _send_handling_auth
    |     response = self._send_handling_redirects(
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 991, in _send_handling_redirects
    |     response = self._send_single_request(request)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 1027, in _send_single_request
    |     response = transport.handle_request(request)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py", line 340, in handle_request
    |     raise exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py", line 337, in handle_request
    |     portal.call(self.app, scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\anyio\from_thread.py", line 291, in call
    |     return cast(T_Retval, self.start_task_soon(func, *args).result())
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\concurrent\futures\_base.py", line 456, in result
    |     return self.__get_result()
    |            ^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\concurrent\futures\_base.py", line 401, in __get_result
    |     raise self._exception
    |   File "C:\Program Files\Python311\Lib\site-packages\anyio\from_thread.py", line 222, in _call_func
    |     retval = await retval_or_awaitable
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\fastapi\applications.py", line 1054, in __call__
    |     await super().__call__(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\applications.py", line 112, in __call__
    |     await self.middleware_stack(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\errors.py", line 187, in __call__
    |     raise exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\errors.py", line 165, in __call__
    |     await self.app(scope, receive, _send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\cors.py", line 85, in __call__
    |     await self.app(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    |     with recv_stream, send_stream, collapse_excgroups():
    |   File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    |     self.gen.throw(typ, value, traceback)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    |     raise exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    |     response = await self.dispatch_func(request, call_next)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\final\backend\app\middleware\security_middleware.py", line 241, in dispatch
    |     return await call_next(request)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    |     raise app_exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    |     await self.app(scope, receive_or_disconnect, send_no_error)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    |     with recv_stream, send_stream, collapse_excgroups():
    |   File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    |     self.gen.throw(typ, value, traceback)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    |     raise exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    |     response = await self.dispatch_func(request, call_next)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\final\backend\app\middleware\audit_middleware.py", line 41, in dispatch
    |     response = await call_next(request)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    |     raise app_exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    |     await self.app(scope, receive_or_disconnect, send_no_error)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\exceptions.py", line 62, in __call__
    |     await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 53, in wrapped_app
    |     raise exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 42, in wrapped_app
    |     await app(scope, receive, sender)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 714, in __call__
    |     await self.middleware_stack(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 734, in app
    |     await route.handle(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 288, in handle
    |     await self.app(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 76, in app
    |     await wrap_app_handling_exceptions(app, request)(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 59, in wrapped_app
    |     response = await handler(conn, exc)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\final\backend\app\core\exception_handlers.py", line 221, in validation_exception_handler
    |     return JSONResponse(
    |            ^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 182, in __init__
    |     super().__init__(content, status_code, headers, media_type, background)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 45, in __init__
    |     self.body = self.render(content)
    |                 ^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 185, in render
    |     return json.dumps(
    |            ^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\__init__.py", line 238, in dumps
    |     **kw).encode(obj)
    |           ^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\encoder.py", line 200, in encode
    |     chunks = self.iterencode(o, _one_shot=True)
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\encoder.py", line 258, in iterencode
    |     return _iterencode(o, 0)
    |            ^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\encoder.py", line 180, in default
    |     raise TypeError(f'Object of type {o.__class__.__name__} '
    | TypeError: Object of type Decimal is not JSON serializable
    +------------------------------------

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\final\backend\tests\integration\test_e2e_payment_flow.py", line 258, in test_invalid_amount_rejected
    response = client.post(
               ^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py", line 538, in post
    return super().post(
           ^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 1157, in post
    return self.request(
           ^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py", line 437, in request
    return super().request(
           ^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 837, in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 926, in send
    response = self._send_handling_auth(
               ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 954, in _send_handling_auth
    response = self._send_handling_redirects(
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 991, in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\httpx\_client.py", line 1027, in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py", line 340, in handle_request
    raise exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py", line 337, in handle_request
    portal.call(self.app, scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\anyio\from_thread.py", line 291, in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\concurrent\futures\_base.py", line 456, in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\concurrent\futures\_base.py", line 401, in __get_result
    raise self._exception
  File "C:\Program Files\Python311\Lib\site-packages\anyio\from_thread.py", line 222, in _call_func
    retval = await retval_or_awaitable
             ^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\fastapi\applications.py", line 1054, in __call__
    await super().__call__(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\applications.py", line 112, in __call__
    await self.middleware_stack(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\errors.py", line 187, in __call__
    raise exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\errors.py", line 165, in __call__
    await self.app(scope, receive, _send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\cors.py", line 85, in __call__
    await self.app(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    with recv_stream, send_stream, collapse_excgroups():
  File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    self.gen.throw(typ, value, traceback)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    raise exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\final\backend\app\middleware\security_middleware.py", line 241, in dispatch
    return await call_next(request)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    raise app_exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    with recv_stream, send_stream, collapse_excgroups():
  File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    self.gen.throw(typ, value, traceback)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    raise exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\final\backend\app\middleware\audit_middleware.py", line 41, in dispatch
    response = await call_next(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    raise app_exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\exceptions.py", line 62, in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 714, in __call__
    await self.middleware_stack(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 734, in app
    await route.handle(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 288, in handle
    await self.app(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 76, in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 59, in wrapped_app
    response = await handler(conn, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\final\backend\app\core\exception_handlers.py", line 221, in validation_exception_handler
    return JSONResponse(
           ^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 182, in __init__
    super().__init__(content, status_code, headers, media_type, background)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 45, in __init__
    self.body = self.render(content)
                ^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 185, in render
    return json.dumps(
           ^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\__init__.py", line 238, in dumps
    **kw).encode(obj)
          ^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type Decimal is not JSON serializable

During handling of the above exception, another exception occurred:

self = <test_e2e_payment_flow.TestPaymentSecurity object at 0x00000207016094D0>
client = <starlette.testclient.TestClient object at 0x00000207033E6290>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg4OSwidHlwZSI6ImFjY2VzcyJ9.E0lFbh9uIcR4inRTv7PDsxGuQ6bJZbfPn7X9fBU-Kgk'}

    def test_invalid_amount_rejected(self, client: TestClient, auth_headers):
        """═хъюЁЁхъЄэр  ёєььр юЄъыюэ хЄё """
>       response = client.post(
            "/api/v1/payments/init",
            headers=auth_headers,
            json={
                "amount": -100,  # ╬ЄЁшЎрЄхы№эр  ёєььр
                "currency": "UZS",
                "provider": "click",
            },
        )

tests\integration\test_e2e_payment_flow.py:258: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py:538: in post
    return super().post(
C:\Program Files\Python311\Lib\site-packages\httpx\_client.py:1157: in post
    return self.request(
C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py:437: in request
    return super().request(
C:\Program Files\Python311\Lib\site-packages\httpx\_client.py:837: in request
    return self.send(request, auth=auth, follow_redirects=follow_redirects)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\httpx\_client.py:926: in send
    response = self._send_handling_auth(
C:\Program Files\Python311\Lib\site-packages\httpx\_client.py:954: in _send_handling_auth
    response = self._send_handling_redirects(
C:\Program Files\Python311\Lib\site-packages\httpx\_client.py:991: in _send_handling_redirects
    response = self._send_single_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\httpx\_client.py:1027: in _send_single_request
    response = transport.handle_request(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py:340: in handle_request
    raise exc
C:\Program Files\Python311\Lib\site-packages\starlette\testclient.py:337: in handle_request
    portal.call(self.app, scope, receive, send)
C:\Program Files\Python311\Lib\site-packages\anyio\from_thread.py:291: in call
    return cast(T_Retval, self.start_task_soon(func, *args).result())
                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\concurrent\futures\_base.py:456: in result
    return self.__get_result()
           ^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\concurrent\futures\_base.py:401: in __get_result
    raise self._exception
C:\Program Files\Python311\Lib\site-packages\anyio\from_thread.py:222: in _call_func
    retval = await retval_or_awaitable
             ^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\fastapi\applications.py:1054: in __call__
    await super().__call__(scope, receive, send)
C:\Program Files\Python311\Lib\site-packages\starlette\applications.py:112: in __call__
    await self.middleware_stack(scope, receive, send)
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\errors.py:187: in __call__
    raise exc
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\errors.py:165: in __call__
    await self.app(scope, receive, _send)
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\cors.py:85: in __call__
    await self.app(scope, receive, send)
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py:176: in __call__
    with recv_stream, send_stream, collapse_excgroups():
C:\Program Files\Python311\Lib\contextlib.py:155: in __exit__
    self.gen.throw(typ, value, traceback)
C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py:82: in collapse_excgroups
    raise exc
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py:178: in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
app\middleware\security_middleware.py:241: in dispatch
    return await call_next(request)
           ^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py:156: in call_next
    raise app_exc
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py:141: in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py:176: in __call__
    with recv_stream, send_stream, collapse_excgroups():
C:\Program Files\Python311\Lib\contextlib.py:155: in __exit__
    self.gen.throw(typ, value, traceback)
C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py:82: in collapse_excgroups
    raise exc
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py:178: in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
app\middleware\audit_middleware.py:41: in dispatch
    response = await call_next(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py:156: in call_next
    raise app_exc
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py:141: in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
C:\Program Files\Python311\Lib\site-packages\starlette\middleware\exceptions.py:62: in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py:53: in wrapped_app
    raise exc
C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py:42: in wrapped_app
    await app(scope, receive, sender)
C:\Program Files\Python311\Lib\site-packages\starlette\routing.py:714: in __call__
    await self.middleware_stack(scope, receive, send)
C:\Program Files\Python311\Lib\site-packages\starlette\routing.py:734: in app
    await route.handle(scope, receive, send)
C:\Program Files\Python311\Lib\site-packages\starlette\routing.py:288: in handle
    await self.app(scope, receive, send)
C:\Program Files\Python311\Lib\site-packages\starlette\routing.py:76: in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py:59: in wrapped_app
    response = await handler(conn, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^
app\core\exception_handlers.py:221: in validation_exception_handler
    return JSONResponse(
C:\Program Files\Python311\Lib\site-packages\starlette\responses.py:182: in __init__
    super().__init__(content, status_code, headers, media_type, background)
C:\Program Files\Python311\Lib\site-packages\starlette\responses.py:45: in __init__
    self.body = self.render(content)
                ^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\starlette\responses.py:185: in render
    return json.dumps(
C:\Program Files\Python311\Lib\json\__init__.py:238: in dumps
    **kw).encode(obj)
          ^^^^^^^^^^^
C:\Program Files\Python311\Lib\json\encoder.py:200: in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\json\encoder.py:258: in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <json.encoder.JSONEncoder object at 0x00000207036FA910>, o = Decimal('0')

    def default(self, o):
        """Implement this method in a subclass such that it returns
        a serializable object for ``o``, or calls the base implementation
        (to raise a ``TypeError``).
    
        For example, to support arbitrary iterators, you could
        implement default like this::
    
            def default(self, o):
                try:
                    iterable = iter(o)
                except TypeError:
                    pass
                else:
                    return list(iterable)
                # Let the base class default method raise the TypeError
                return JSONEncoder.default(self, o)
    
        """
>       raise TypeError(f'Object of type {o.__class__.__name__} '
                        f'is not JSON serializable')
E       TypeError: Object of type Decimal is not JSON serializable

C:\Program Files\Python311\Lib\json\encoder.py:180: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg4OSwidHlwZSI6ImFjY2VzcyJ9.E0lFbh9uIcR4inRTv7PDsxGuQ6bJZbfPn7X9fBU-Kgk', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiI3NjI2YWI5NS0xN2E1LTQ3ZDAtOTY1Ny1hMmU4ODg3YTQxOGIiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODM2NDA4OX0.LZkzNH7q5DRABHINvrXna6fhrBOsnJYdnuoUh6maCR8', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
---------------------------- Captured stderr call -----------------------------
WARNING:app.core.exception_handlers:RequestValidationError: [{'type': 'missing', 'loc': ('body', 'visit_id'), 'msg': 'Field required', 'input': {'amount': -100, 'currency': 'UZS', 'provider': 'click'}}, {'type': 'greater_than', 'loc': ('body', 'amount'), 'msg': 'Input should be greater than 0', 'input': -100, 'ctx': {'gt': Decimal('0')}}] (path: /api/v1/payments/init)
ERROR:app.core.exception_handlers:Unhandled exception: TypeError: Object of type Decimal is not JSON serializable (path: /api/v1/payments/init)
  + Exception Group Traceback (most recent call last):
  |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 76, in collapse_excgroups
  |     yield
  |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 177, in __call__
  |     async with anyio.create_task_group() as task_group:
  |   File "C:\Program Files\Python311\Lib\site-packages\anyio\_backends\_asyncio.py", line 772, in __aexit__
  |     raise BaseExceptionGroup(
  | ExceptionGroup: unhandled errors in a TaskGroup (1 sub-exception)
  +-+---------------- 1 ----------------
    | Traceback (most recent call last):
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\errors.py", line 165, in __call__
    |     await self.app(scope, receive, _send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\cors.py", line 85, in __call__
    |     await self.app(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    |     with recv_stream, send_stream, collapse_excgroups():
    |   File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    |     self.gen.throw(typ, value, traceback)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    |     raise exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    |     response = await self.dispatch_func(request, call_next)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\final\backend\app\middleware\security_middleware.py", line 241, in dispatch
    |     return await call_next(request)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    |     raise app_exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    |     await self.app(scope, receive_or_disconnect, send_no_error)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    |     with recv_stream, send_stream, collapse_excgroups():
    |   File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    |     self.gen.throw(typ, value, traceback)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    |     raise exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    |     response = await self.dispatch_func(request, call_next)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\final\backend\app\middleware\audit_middleware.py", line 41, in dispatch
    |     response = await call_next(request)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    |     raise app_exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    |     await self.app(scope, receive_or_disconnect, send_no_error)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\exceptions.py", line 62, in __call__
    |     await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 53, in wrapped_app
    |     raise exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 42, in wrapped_app
    |     await app(scope, receive, sender)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 714, in __call__
    |     await self.middleware_stack(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 734, in app
    |     await route.handle(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 288, in handle
    |     await self.app(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 76, in app
    |     await wrap_app_handling_exceptions(app, request)(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 59, in wrapped_app
    |     response = await handler(conn, exc)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\final\backend\app\core\exception_handlers.py", line 221, in validation_exception_handler
    |     return JSONResponse(
    |            ^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 182, in __init__
    |     super().__init__(content, status_code, headers, media_type, background)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 45, in __init__
    |     self.body = self.render(content)
    |                 ^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 185, in render
    |     return json.dumps(
    |            ^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\__init__.py", line 238, in dumps
    |     **kw).encode(obj)
    |           ^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\encoder.py", line 200, in encode
    |     chunks = self.iterencode(o, _one_shot=True)
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\encoder.py", line 258, in iterencode
    |     return _iterencode(o, 0)
    |            ^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\encoder.py", line 180, in default
    |     raise TypeError(f'Object of type {o.__class__.__name__} '
    | TypeError: Object of type Decimal is not JSON serializable
    +------------------------------------

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\errors.py", line 165, in __call__
    await self.app(scope, receive, _send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\cors.py", line 85, in __call__
    await self.app(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    with recv_stream, send_stream, collapse_excgroups():
  File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    self.gen.throw(typ, value, traceback)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    raise exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\final\backend\app\middleware\security_middleware.py", line 241, in dispatch
    return await call_next(request)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    raise app_exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    with recv_stream, send_stream, collapse_excgroups():
  File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    self.gen.throw(typ, value, traceback)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    raise exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\final\backend\app\middleware\audit_middleware.py", line 41, in dispatch
    response = await call_next(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    raise app_exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\exceptions.py", line 62, in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 714, in __call__
    await self.middleware_stack(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 734, in app
    await route.handle(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 288, in handle
    await self.app(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 76, in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 59, in wrapped_app
    response = await handler(conn, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\final\backend\app\core\exception_handlers.py", line 221, in validation_exception_handler
    return JSONResponse(
           ^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 182, in __init__
    super().__init__(content, status_code, headers, media_type, background)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 45, in __init__
    self.body = self.render(content)
                ^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 185, in render
    return json.dumps(
           ^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\__init__.py", line 238, in dumps
    **kw).encode(obj)
          ^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type Decimal is not JSON serializable
------------------------------ Captured log call ------------------------------
WARNING  app.core.exception_handlers:exception_handlers.py:216 RequestValidationError: [{'type': 'missing', 'loc': ('body', 'visit_id'), 'msg': 'Field required', 'input': {'amount': -100, 'currency': 'UZS', 'provider': 'click'}}, {'type': 'greater_than', 'loc': ('body', 'amount'), 'msg': 'Input should be greater than 0', 'input': -100, 'ctx': {'gt': Decimal('0')}}] (path: /api/v1/payments/init)
ERROR    app.core.exception_handlers:exception_handlers.py:237 Unhandled exception: TypeError: Object of type Decimal is not JSON serializable (path: /api/v1/payments/init)
  + Exception Group Traceback (most recent call last):
  |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 76, in collapse_excgroups
  |     yield
  |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 177, in __call__
  |     async with anyio.create_task_group() as task_group:
  |   File "C:\Program Files\Python311\Lib\site-packages\anyio\_backends\_asyncio.py", line 772, in __aexit__
  |     raise BaseExceptionGroup(
  | ExceptionGroup: unhandled errors in a TaskGroup (1 sub-exception)
  +-+---------------- 1 ----------------
    | Traceback (most recent call last):
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\errors.py", line 165, in __call__
    |     await self.app(scope, receive, _send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\cors.py", line 85, in __call__
    |     await self.app(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    |     with recv_stream, send_stream, collapse_excgroups():
    |   File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    |     self.gen.throw(typ, value, traceback)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    |     raise exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    |     response = await self.dispatch_func(request, call_next)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\final\backend\app\middleware\security_middleware.py", line 241, in dispatch
    |     return await call_next(request)
    |            ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    |     raise app_exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    |     await self.app(scope, receive_or_disconnect, send_no_error)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    |     with recv_stream, send_stream, collapse_excgroups():
    |   File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    |     self.gen.throw(typ, value, traceback)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    |     raise exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    |     response = await self.dispatch_func(request, call_next)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\final\backend\app\middleware\audit_middleware.py", line 41, in dispatch
    |     response = await call_next(request)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    |     raise app_exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    |     await self.app(scope, receive_or_disconnect, send_no_error)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\exceptions.py", line 62, in __call__
    |     await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 53, in wrapped_app
    |     raise exc
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 42, in wrapped_app
    |     await app(scope, receive, sender)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 714, in __call__
    |     await self.middleware_stack(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 734, in app
    |     await route.handle(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 288, in handle
    |     await self.app(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 76, in app
    |     await wrap_app_handling_exceptions(app, request)(scope, receive, send)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 59, in wrapped_app
    |     response = await handler(conn, exc)
    |                ^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\final\backend\app\core\exception_handlers.py", line 221, in validation_exception_handler
    |     return JSONResponse(
    |            ^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 182, in __init__
    |     super().__init__(content, status_code, headers, media_type, background)
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 45, in __init__
    |     self.body = self.render(content)
    |                 ^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 185, in render
    |     return json.dumps(
    |            ^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\__init__.py", line 238, in dumps
    |     **kw).encode(obj)
    |           ^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\encoder.py", line 200, in encode
    |     chunks = self.iterencode(o, _one_shot=True)
    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\encoder.py", line 258, in iterencode
    |     return _iterencode(o, 0)
    |            ^^^^^^^^^^^^^^^^^
    |   File "C:\Program Files\Python311\Lib\json\encoder.py", line 180, in default
    |     raise TypeError(f'Object of type {o.__class__.__name__} '
    | TypeError: Object of type Decimal is not JSON serializable
    +------------------------------------

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\errors.py", line 165, in __call__
    await self.app(scope, receive, _send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\cors.py", line 85, in __call__
    await self.app(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    with recv_stream, send_stream, collapse_excgroups():
  File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    self.gen.throw(typ, value, traceback)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    raise exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\final\backend\app\middleware\security_middleware.py", line 241, in dispatch
    return await call_next(request)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    raise app_exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 176, in __call__
    with recv_stream, send_stream, collapse_excgroups():
  File "C:\Program Files\Python311\Lib\contextlib.py", line 155, in __exit__
    self.gen.throw(typ, value, traceback)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_utils.py", line 82, in collapse_excgroups
    raise exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 178, in __call__
    response = await self.dispatch_func(request, call_next)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\final\backend\app\middleware\audit_middleware.py", line 41, in dispatch
    response = await call_next(request)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 156, in call_next
    raise app_exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\base.py", line 141, in coro
    await self.app(scope, receive_or_disconnect, send_no_error)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\middleware\exceptions.py", line 62, in __call__
    await wrap_app_handling_exceptions(self.app, conn)(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 53, in wrapped_app
    raise exc
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 42, in wrapped_app
    await app(scope, receive, sender)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 714, in __call__
    await self.middleware_stack(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 734, in app
    await route.handle(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 288, in handle
    await self.app(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\routing.py", line 76, in app
    await wrap_app_handling_exceptions(app, request)(scope, receive, send)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\_exception_handler.py", line 59, in wrapped_app
    response = await handler(conn, exc)
               ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\final\backend\app\core\exception_handlers.py", line 221, in validation_exception_handler
    return JSONResponse(
           ^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 182, in __init__
    super().__init__(content, status_code, headers, media_type, background)
  File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 45, in __init__
    self.body = self.render(content)
                ^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\site-packages\starlette\responses.py", line 185, in render
    return json.dumps(
           ^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\__init__.py", line 238, in dumps
    **kw).encode(obj)
          ^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\encoder.py", line 200, in encode
    chunks = self.iterencode(o, _one_shot=True)
             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\encoder.py", line 258, in iterencode
    return _iterencode(o, 0)
           ^^^^^^^^^^^^^^^^^
  File "C:\Program Files\Python311\Lib\json\encoder.py", line 180, in default
    raise TypeError(f'Object of type {o.__class__.__name__} '
TypeError: Object of type Decimal is not JSON serializable
____________ TestE2EVisitFlow.test_complete_visit_flow_future_date ____________

self = <test_e2e_visit_flow.TestE2EVisitFlow object at 0x000002070160B8D0>
client = <starlette.testclient.TestClient object at 0x0000020703455190>
db_session = <sqlalchemy.orm.session.Session object at 0x00000207036B03D0>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg4OSwidHlwZSI6ImFjY2VzcyJ9.E0lFbh9uIcR4inRTv7PDsxGuQ6bJZbfPn7X9fBU-Kgk'}
test_patient = <app.models.patient.Patient object at 0x00000207015AB690>

    def test_complete_visit_flow_future_date(self, client, db_session, auth_headers, test_patient):
        """
        E2E \u0442\u0435\u0441\u0442: \u0432\u0440\u0430\u0447 \u043d\u0430\u0437\u043d\u0430\u0447\u0438\u043b \u0432\u0438\u0437\u0438\u0442 \u043d\u0430 \u0437\u0430\u0432\u0442\u0440\u0430 \u2192 \u043f\u0430\u0446\u0438\u0435\u043d\u0442 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u043b \u2192 \u043d\u043e\u043c\u0435\u0440 \u041d\u0415 \u0432\u044b\u0434\u0430\u043d
        """
        # ╤ючфрхь єэшъры№эє■ єёыєує фы  ¤Єюую ЄхёЄр
        from app.models.service import Service
>       future_service = Service(
            code="FUTURE_TEST",
            name="┴єфє∙р  єёыєур",
            price=100000.00,
            queue_tag="cardiology_common",
            is_active=True
        )

tests\integration\test_e2e_visit_flow.py:122: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.service.Service object at 0x00000207036B24D0>
kwargs = {'code': 'FUTURE_TEST', 'is_active': True, 'name': '┴єфє∙р  єёыєур', 'price': 100000.0, ...}
cls_ = <class 'app.models.service.Service'>, k = 'is_active'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'is_active' is an invalid keyword argument for Service

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg4OSwidHlwZSI6ImFjY2VzcyJ9.E0lFbh9uIcR4inRTv7PDsxGuQ6bJZbfPn7X9fBU-Kgk', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiJhOWVhNTJjZi1jYmI0LTQ5OTEtYTM5My0xYjU0MjMzZDFlZGUiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODM2NDA4OX0.bjEGaZXSOU62JVXPqWUq3IEYuI-HfrTXv8X_LVkDBLI', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
________________ TestE2EVisitFlow.test_morning_assignment_flow ________________

self = <test_e2e_visit_flow.TestE2EVisitFlow object at 0x000002070160BED0>
client = <starlette.testclient.TestClient object at 0x00000207036C8490>
db_session = <sqlalchemy.orm.session.Session object at 0x00000207036C8350>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg4OSwidHlwZSI6ImFjY2VzcyJ9.E0lFbh9uIcR4inRTv7PDsxGuQ6bJZbfPn7X9fBU-Kgk'}
test_patient = <app.models.patient.Patient object at 0x00000207036393D0>
admin_user = <app.models.user.User object at 0x0000020703D376D0>

    def test_morning_assignment_flow(self, client, db_session, auth_headers, test_patient, admin_user):
        """
        E2E \u0442\u0435\u0441\u0442 \u0443\u0442\u0440\u0435\u043d\u043d\u0435\u0433\u043e \u043f\u0440\u0438\u0441\u0432\u043e\u0435\u043d\u0438\u044f \u043d\u043e\u043c\u0435\u0440\u043e\u0432: \u0432\u0438\u0437\u0438\u0442 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d \u0432\u0447\u0435\u0440\u0430 \u2192 \u0443\u0442\u0440\u043e\u043c \u043d\u043e\u043c\u0435\u0440 \u0432\u044b\u0434\u0430\u043d
        """
        # ╤ючфрхь єэшъры№эє■ єёыєує фы  ¤Єюую ЄхёЄр
        from app.models.service import Service
>       morning_service = Service(
            code="MORNING_TEST",
            name="╙ЄЁхээ   єёыєур",
            price=75000.00,
            queue_tag="cardiology_common",
            is_active=True
        )

tests\integration\test_e2e_visit_flow.py:193: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.service.Service object at 0x000002070343C310>
kwargs = {'code': 'MORNING_TEST', 'is_active': True, 'name': '╙ЄЁхээ   єёыєур', 'price': 75000.0, ...}
cls_ = <class 'app.models.service.Service'>, k = 'is_active'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'is_active' is an invalid keyword argument for Service

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg4OSwidHlwZSI6ImFjY2VzcyJ9.E0lFbh9uIcR4inRTv7PDsxGuQ6bJZbfPn7X9fBU-Kgk', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiJmMDQzZDg2Mi05ZTU2LTQxODQtOTQzNS1iMmYyMTliMmI4MzMiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODM2NDA4OX0.rLMwNL6INArG6j_5mx8XTleqTfxbwkiu0xtI81ZWjrM', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
______________ TestE2EVisitFlow.test_registrar_confirmation_flow ______________

self = <test_e2e_visit_flow.TestE2EVisitFlow object at 0x0000020701618550>
client = <starlette.testclient.TestClient object at 0x0000020703CFFAD0>
db_session = <sqlalchemy.orm.session.Session object at 0x0000020703CFFDD0>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg4OSwidHlwZSI6ImFjY2VzcyJ9.E0lFbh9uIcR4inRTv7PDsxGuQ6bJZbfPn7X9fBU-Kgk'}
test_patient = <app.models.patient.Patient object at 0x0000020703BCFF50>
admin_user = <app.models.user.User object at 0x000002070409EA50>

    def test_registrar_confirmation_flow(self, client, db_session, auth_headers, test_patient, admin_user):
        """
        E2E \u0442\u0435\u0441\u0442 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0436\u0434\u0435\u043d\u0438\u044f \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440\u043e\u043c: \u0432\u0438\u0437\u0438\u0442 \u0441\u043e\u0437\u0434\u0430\u043d \u2192 \u0440\u0435\u0433\u0438\u0441\u0442\u0440\u0430\u0442\u043e\u0440 \u043f\u043e\u0434\u0442\u0432\u0435\u0440\u0434\u0438\u043b \u2192 \u043d\u043e\u043c\u0435\u0440 \u0432\u044b\u0434\u0430\u043d
        """
        # ╪└├ 1: ╤ючфрхь тшчшЄ юцшфр■∙шщ яюфЄтхЁцфхэш 
        visit = Visit(
            patient_id=test_patient.id,
            doctor_id=admin_user.id,
            visit_date=date.today(),
            visit_time="11:00",
            status="pending_confirmation",
            discount_mode="none",
            department="cardiology",
            confirmation_token="test-registrar-token",
            confirmation_channel="phone",
            confirmation_expires_at=datetime.utcnow() + timedelta(hours=24)
        )
        db_session.add(visit)
        db_session.commit()
    
        # ╪└├ 2: ╤ючфрхь фэхтэє■ юўхЁхф№
        daily_queue = DailyQueue(
            day=date.today(),
            specialist_id=visit.doctor_id,
            queue_tag="cardiology_common",
            active=True
        )
        db_session.add(daily_queue)
        db_session.commit()
    
        # ╪└├ 3: ╨хушёЄЁрЄюЁ яюфЄтхЁцфрхЄ тшчшЄ яю ЄхыхЇюэє
        confirm_response = client.post(
            f"/api/v1/registrar/visits/{visit.id}/confirm",
            json={
                "confirmation_notes": "╧юфЄтхЁцфхэю яю ЄхыхЇюэє +998901234567"
            },
            headers=auth_headers
        )
    
        assert confirm_response.status_code == 200
        confirm_data = confirm_response.json()
    
        assert confirm_data["success"] is True
        assert confirm_data["visit_id"] == visit.id
        assert confirm_data["status"] == "open"
    
        # ╪└├ 4: ╧ЁютхЁ хь ўЄю эюьхЁ т√фрэ
        assert "queue_numbers" in confirm_data
>       assert len(confirm_data["queue_numbers"]) > 0
E       assert 0 > 0
E        +  where 0 = len({})

tests\integration\test_e2e_visit_flow.py:322: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg4OSwidHlwZSI6ImFjY2VzcyJ9.E0lFbh9uIcR4inRTv7PDsxGuQ6bJZbfPn7X9fBU-Kgk', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiJkNGY4YTM1MC03MTBmLTQyNjgtOTBjMS01NzRiOTM2MWZhNTkiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODM2NDA4OX0.PtpfYkOtk1JNjgde82vYf10xWTUYUGkLdFl387OHuMM', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
__________ TestE2EVisitFlow.test_multiple_services_queue_assignment ___________

self = <test_e2e_visit_flow.TestE2EVisitFlow object at 0x0000020701608C10>
client = <starlette.testclient.TestClient object at 0x000002070197DC50>
db_session = <sqlalchemy.orm.session.Session object at 0x000002070197E3D0>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg5MCwidHlwZSI6ImFjY2VzcyJ9.P-eFbeepp55R25ZhrmBKKU6_sLF1mxCVfoQ1CIjDZ4Y'}
test_patient = <app.models.patient.Patient object at 0x00000207043A1690>

    def test_multiple_services_queue_assignment(self, client, db_session, auth_headers, test_patient):
        """
        E2E ЄхёЄ ё эхёъюы№ъшьш єёыєурьш: Ёрчэ√х юўхЁхфш фы  Ёрчэ√ї єёыєу
        """
        # ╪└├ 1: ╤ючфрхь фюяюыэшЄхы№э√х єёыєуш ё єэшъры№э√ьш ъюфрьш
>       ecg_service = Service(
            code="ECG_MULTI_TEST",
            name="▌╩├ ьєы№Єш ЄхёЄ",
            price=50000.00,
            queue_tag="ecg",
            is_active=True
        )

tests\integration\test_e2e_visit_flow.py:343: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.service.Service object at 0x0000020703CFF7D0>
kwargs = {'code': 'ECG_MULTI_TEST', 'is_active': True, 'name': '▌╩├ ьєы№Єш ЄхёЄ', 'price': 50000.0, ...}
cls_ = <class 'app.models.service.Service'>, k = 'is_active'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'is_active' is an invalid keyword argument for Service

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg5MCwidHlwZSI6ImFjY2VzcyJ9.P-eFbeepp55R25ZhrmBKKU6_sLF1mxCVfoQ1CIjDZ4Y', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiJmODQ3NTFlOC1lMzU5LTRmOGItYjkzZi0xY2U5MTc0M2YwZjYiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODM2NDA5MH0.Mm2of7WZTHWG4ovbIGb_FmcO1YLDBmQU-MeWQhbzSp0', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
________________ TestE2EVisitFlow.test_error_handling_in_flow _________________

self = <test_e2e_visit_flow.TestE2EVisitFlow object at 0x0000020701606610>
client = <starlette.testclient.TestClient object at 0x00000207043FA750>
db_session = <sqlalchemy.orm.session.Session object at 0x00000207036D7E10>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg5MCwidHlwZSI6ImFjY2VzcyJ9.P-eFbeepp55R25ZhrmBKKU6_sLF1mxCVfoQ1CIjDZ4Y'}
test_patient = <app.models.patient.Patient object at 0x0000020703625B10>

    def test_error_handling_in_flow(self, client, db_session, auth_headers, test_patient):
        """
        E2E ЄхёЄ юсЁрсюЄъш ю°шсюъ т яюыэюь ёЎхэрЁшш
        """
        # ╪└├ 1: ╧юя√Єър яюфЄтхЁфшЄ№ эхёє∙хёЄтє■∙шщ Єюъхэ
        confirm_response = client.post(
            "/api/v1/telegram/visits/confirm",
            json={
                "token": "nonexistent-token-123",
                "telegram_user_id": "123456789"
            }
        )
    
>       assert confirm_response.status_code == 404
E       assert 400 == 404
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\integration\test_e2e_visit_flow.py:448: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg5MCwidHlwZSI6ImFjY2VzcyJ9.P-eFbeepp55R25ZhrmBKKU6_sLF1mxCVfoQ1CIjDZ4Y', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiJlZmZjMWNlMS1lZGEyLTQ1MTEtYWFlZS1hODdkYTdjODYwOWQiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODM2NDA5MH0.MDBU2-iN1s3u-pZIrsqcbnH6RRhRRNytTFw3PKa1dj4', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
_______________ TestE2EVisitFlow.test_notification_integration ________________

self = <test_e2e_visit_flow.TestE2EVisitFlow object at 0x0000020701618A10>
mock_telegram = <AsyncMock name='send_confirmation_invitation' id='2229146946320'>
client = <starlette.testclient.TestClient object at 0x00000207033265D0>
db_session = <sqlalchemy.orm.session.Session object at 0x0000020703327710>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg5MCwidHlwZSI6ImFjY2VzcyJ9.P-eFbeepp55R25ZhrmBKKU6_sLF1mxCVfoQ1CIjDZ4Y'}
test_patient = <app.models.patient.Patient object at 0x0000020703832FD0>

    @patch('app.services.telegram.bot.ClinicTelegramBot.send_confirmation_invitation')
    def test_notification_integration(self, mock_telegram, client, db_session, auth_headers, test_patient):
        """
        E2E ЄхёЄ шэЄхуЁрЎшш ё ёшёЄхьющ єтхфюьыхэшщ
        """
        # ╤ючфрхь єэшъры№эє■ єёыєує фы  ¤Єюую ЄхёЄр
        from app.models.service import Service
>       notification_service = Service(
            code="NOTIFICATION_TEST",
            name="╙тхфюьшЄхы№эр  єёыєур",
            price=60000.00,
            queue_tag="cardiology_common",
            is_active=True
        )

tests\integration\test_e2e_visit_flow.py:508: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
<string>:4: in __init__
    ???
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:571: in _initialize_instance
    with util.safe_reraise():
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\util\langhelpers.py:224: in __exit__
    raise exc_value.with_traceback(exc_tb)
C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\state.py:569: in _initialize_instance
    manager.original_init(*mixed[1:], **kwargs)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <app.models.service.Service object at 0x0000020703D37F50>
kwargs = {'code': 'NOTIFICATION_TEST', 'is_active': True, 'name': '╙тхфюьшЄхы№эр  єёыєур', 'price': 60000.0, ...}
cls_ = <class 'app.models.service.Service'>, k = 'is_active'

    def _declarative_constructor(self: Any, **kwargs: Any) -> None:
        """A simple constructor that allows initialization from kwargs.
    
        Sets attributes on the constructed instance using the names and
        values in ``kwargs``.
    
        Only keys that are present as
        attributes of the instance's class are allowed. These could be,
        for example, any mapped columns or relationships.
        """
        cls_ = type(self)
        for k in kwargs:
            if not hasattr(cls_, k):
>               raise TypeError(
                    "%r is an invalid keyword argument for %s" % (k, cls_.__name__)
                )
E               TypeError: 'is_active' is an invalid keyword argument for Service

C:\Program Files\Python311\Lib\site-packages\sqlalchemy\orm\decl_base.py:2179: TypeError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg5MCwidHlwZSI6ImFjY2VzcyJ9.P-eFbeepp55R25ZhrmBKKU6_sLF1mxCVfoQ1CIjDZ4Y', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiI1NmJkYjk1Yi1hZmUyLTQ5ZjUtOTQxZS03MDhiNGI1ZDVhNDUiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODM2NDA5MH0.4Z2qltCRqAEaGCFWYipmV7qltFJR7jiQ1wVrDALRPzI', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
_______ TestMigrationManagementAPI.test_check_data_integrity_with_data ________

self = <test_migration_management_api.TestMigrationManagementAPI object at 0x000002070161AE90>
client = <starlette.testclient.TestClient object at 0x00000207033FA310>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg5MSwidHlwZSI6ImFjY2VzcyJ9.nVmnoQpTab_SxGy-V7o5_yTji06NaQMMwJMgrccusAo'}
test_queue_entry = <app.models.online_queue.OnlineQueueEntry object at 0x0000020701972890>

    def test_check_data_integrity_with_data(self, client, auth_headers, test_queue_entry):
        """╥хёЄ яЁютхЁъш ЎхыюёЄэюёЄш ё ёє∙хёЄтє■∙шьш фрээ√ьш"""
        response = client.get("/api/v1/admin/migration/check-integrity", headers=auth_headers)
    
        assert response.status_code == 200
        data = response.json()
    
        # ╤ ъюЁЁхъЄэ√ьш фрээ√ьш тёх яЁютхЁъш фюыцэ√ яЁющЄш
>       assert data["passed"] is True
E       assert False is True

tests\integration\test_migration_management_api.py:70: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg5MSwidHlwZSI6ImFjY2VzcyJ9.nVmnoQpTab_SxGy-V7o5_yTji06NaQMMwJMgrccusAo', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiJkNmU3MzI0Mi03NGEwLTQwMjAtODhhMC0yOGVhZTY0MGRiOTgiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODM2NDA5MX0.KkfoKKmPWAV8glhKSjZHXRsGA0TPyrgOlEuxQ2EF4nA', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
______ TestMigrationManagementAPI.test_restore_queue_data_file_not_found ______

self = <test_migration_management_api.TestMigrationManagementAPI object at 0x000002070162A350>
client = <starlette.testclient.TestClient object at 0x00000207040170D0>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg5MSwidHlwZSI6ImFjY2VzcyJ9.nVmnoQpTab_SxGy-V7o5_yTji06NaQMMwJMgrccusAo'}

    def test_restore_queue_data_file_not_found(self, client, auth_headers):
        """╥хёЄ тюёёЄрэютыхэш  шч эхёє∙хёЄтє■∙хую Їрщыр"""
        response = client.post(
            "/api/v1/admin/migration/restore-queue-data?backup_file=nonexistent.json",
            headers=auth_headers
        )
    
>       assert response.status_code == 500
E       assert 200 == 500
E        +  where 200 = <Response [200 OK]>.status_code

tests\integration\test_migration_management_api.py:240: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg5MSwidHlwZSI6ImFjY2VzcyJ9.nVmnoQpTab_SxGy-V7o5_yTji06NaQMMwJMgrccusAo', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiI4Y2U2NTQzYy01MGY5LTQ0NzktOWVmZi1iNDVkYWZiMjVkY2UiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODM2NDA5MX0.M0QzK8XN5M9ZCQ-nbuWYrzeKywljOhHc2wcz_bn7fOs', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
---------------------------- Captured stderr call -----------------------------
ERROR:app.services.migration_service:╬°шсър тюёёЄрэютыхэш  фрээ√ї: [Errno 2] No such file or directory: 'nonexistent.json'
------------------------------ Captured log call ------------------------------
ERROR    app.services.migration_service:migration_service.py:499 ╬°шсър тюёёЄрэютыхэш  фрээ√ї: [Errno 2] No such file or directory: 'nonexistent.json'
_____________ TestMigrationManagementAPI.test_api_error_handling ______________

self = <test_migration_management_api.TestMigrationManagementAPI object at 0x000002070162B110>
client = <starlette.testclient.TestClient object at 0x00000207036B1AD0>
auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI...lLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg5MiwidHlwZSI6ImFjY2VzcyJ9.KT60JUSjDhd2liA7jx2fQg22Mgd4CwU8cjFqPrgXvWQ'}

    def test_api_error_handling(self, client, auth_headers):
        """╥хёЄ юсЁрсюЄъш ю°шсюъ т API"""
        # ╥хёЄ ё эхъюЁЁхъЄэ√ьш ярЁрьхЄЁрьш
        response = client.post(
            "/api/v1/admin/migration/cleanup-old-data?days_to_keep=invalid",
            headers=auth_headers
        )
    
        assert response.status_code == 422
    
        # ╥хёЄ тюёёЄрэютыхэш  ё эхъюЁЁхъЄэ√ь Їрщыюь
        response = client.post(
            "/api/v1/admin/migration/restore-queue-data?backup_file=",
            headers=auth_headers
        )
    
>       assert response.status_code == 422
E       assert 200 == 422
E        +  where 200 = <Response [200 OK]>.status_code

tests\integration\test_migration_management_api.py:338: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_admin
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 4, 'username': 'test_admin', 'full_name': 'Test Admin', 'email': 'admin@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': True}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI0IiwidXNlcm5hbWUiOiJ0ZXN0X2FkbWluIiwicm9sZSI6IkFkbWluIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOnRydWUsImV4cCI6MTc2NTc3Mzg5MiwidHlwZSI6ImFjY2VzcyJ9.KT60JUSjDhd2liA7jx2fQg22Mgd4CwU8cjFqPrgXvWQ', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo0LCJqdGkiOiJhYmJhMGY0NS0yNGNmLTRkYjctOGJlZC1jZGNiYTIyM2M5MzAiLCJ0eXBlIjoicmVmcmVzaCIsImV4cCI6MTc2ODM2NDA5Mn0.-gfqZroPmDXZRupbGi_o3MLF3DS3790-VqQS85tRvhg', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
---------------------------- Captured stderr call -----------------------------
WARNING:app.core.exception_handlers:RequestValidationError: [{'type': 'int_parsing', 'loc': ('query', 'days_to_keep'), 'msg': 'Input should be a valid integer, unable to parse string as an integer', 'input': 'invalid'}] (path: /api/v1/admin/migration/cleanup-old-data)
ERROR:app.services.migration_service:╬°шсър тюёёЄрэютыхэш  фрээ√ї: [Errno 2] No such file or directory: ''
------------------------------ Captured log call ------------------------------
WARNING  app.core.exception_handlers:exception_handlers.py:216 RequestValidationError: [{'type': 'int_parsing', 'loc': ('query', 'days_to_keep'), 'msg': 'Input should be a valid integer, unable to parse string as an integer', 'input': 'invalid'}] (path: /api/v1/admin/migration/cleanup-old-data)
ERROR    app.services.migration_service:migration_service.py:499 ╬°шсър тюёёЄрэютыхэш  фрээ√ї: [Errno 2] No such file or directory: ''
______________ TestQueueBatchAPI.test_empty_services_list_error _______________

self = <test_queue_batch_api.TestQueueBatchAPI object at 0x000002070165C290>
client = <starlette.testclient.TestClient object at 0x0000020703448BD0>
registrar_auth_headers = {'Authorization': 'Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJ...CJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NzM4OTcsInR5cGUiOiJhY2Nlc3MifQ.VKZZl71Oh7CAmLyuCRbqcpos32scBb3YnLZw2nBa2b8'}
test_patient = <app.models.patient.Patient object at 0x00000207040734D0>

    def test_empty_services_list_error(
        self, client, registrar_auth_headers, test_patient
    ):
        """╥хёЄ: ╬°шсър - яєёЄющ ёяшёюъ єёыєу"""
        response = client.post(
            "/api/v1/registrar-integration/queue/entries/batch",
            headers=registrar_auth_headers,
            json={
                "patient_id": test_patient.id,
                "source": "desk",
                "services": []  # ╧єёЄющ ёяшёюъ
            }
        )
    
>       assert response.status_code == 422  # Validation error
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E       assert 200 == 422
E        +  where 200 = <Response [200 OK]>.status_code

tests\integration\test_queue_batch_api.py:539: AssertionError
---------------------------- Captured stdout setup ----------------------------
DEBUG: Login endpoint called with username=test_registrar
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 10, 'username': 'test_registrar', 'full_name': 'Test Registrar', 'email': 'registrar@test.com', 'role': 'Registrar', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMCIsInVzZXJuYW1lIjoidGVzdF9yZWdpc3RyYXIiLCJyb2xlIjoiUmVnaXN0cmFyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NzM4OTcsInR5cGUiOiJhY2Nlc3MifQ.VKZZl71Oh7CAmLyuCRbqcpos32scBb3YnLZw2nBa2b8', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMCwianRpIjoiMmI2MjQxNTYtZTgxNS00YTM5LWE3MDMtNDVmYmY0MjFlYTVmIiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzNjQwOTd9.5OZmVMld9_G74g6HzY-h4oSCXmHVBPeLCsP1wk_FNdM', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
---------------------------- Captured stdout call -----------------------------
DEBUG: Checking roles for user 10 (test_registrar)
DEBUG: User Role: 'Registrar', Normalized: 'registrar'
DEBUG: Required Roles: ('Admin', 'Registrar'), Normalized: ['admin', 'registrar']
____________________________ test_health_endpoint _____________________________

self = <urllib3.connection.HTTPConnection object at 0x0000020703D36290>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
>           sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:85: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('127.0.0.1', 8000), timeout = 30, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address: tuple[str, int],
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        source_address: tuple[str, int] | None = None,
        socket_options: _TYPE_SOCKET_OPTIONS | None = None,
    ) -> socket.socket:
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            raise LocationParseError(f"'{host}', label empty or too long") from None
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not _DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:73: ConnectionRefusedError

The above exception was the direct cause of the following exception:

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x000002070408AD90>
method = 'GET', url = '/api/v1/health', body = None
headers = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate, br', 'Accept': '*/*', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=30, read=30, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None, preload_content = False
decode_content = False, response_kw = {}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v1/health', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(  # type: ignore[override]
        self,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | bool | int | None = None,
        redirect: bool = True,
        assert_same_host: bool = True,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        pool_timeout: int | None = None,
        release_conn: bool | None = None,
        chunked: bool = False,
        body_pos: _TYPE_BODY_POSITION | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        **response_kw: typing.Any,
    ) -> BaseHTTPResponse:
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method
           such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param bool preload_content:
            If True, the response's body will be preloaded into memory.
    
        :param bool decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of ``preload_content``
            which defaults to ``True``.
    
        :param bool chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
        """
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = preload_content
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = to_str(_encode_target(url))
        else:
            url = to_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()  # type: ignore[attr-defined]
            headers.update(self.proxy_headers)  # type: ignore[union-attr]
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]
    
            # Is this a closed/new connection that requires CONNECT tunnelling?
            if self.proxy is not None and http_tunnel_required and conn.is_closed:
                try:
                    self._prepare_proxy(conn)
                except (BaseSSLError, OSError, SocketTimeout) as e:
                    self._raise_timeout(
                        err=e, url=self.proxy.url, timeout_value=conn.timeout
                    )
                    raise
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Make the request on the HTTPConnection object
>           response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
                retries=retries,
                response_conn=response_conn,
                preload_content=preload_content,
                decode_content=decode_content,
                **response_kw,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:493: in _make_request
    conn.request(
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:494: in request
    self.endheaders()
C:\Program Files\Python311\Lib\http\client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
C:\Program Files\Python311\Lib\http\client.py:1037: in _send_output
    self.send(msg)
C:\Program Files\Python311\Lib\http\client.py:975: in send
    self.connect()
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:325: in connect
    self.sock = self._new_conn()
                ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <urllib3.connection.HTTPConnection object at 0x0000020703D36290>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
            sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )
        except socket.gaierror as e:
            raise NameResolutionError(self.host, self, e) from e
        except SocketTimeout as e:
            raise ConnectTimeoutError(
                self,
                f"Connection to {self.host} timed out. (connect timeout={self.timeout})",
            ) from e
    
        except OSError as e:
>           raise NewConnectionError(
                self, f"Failed to establish a new connection: {e}"
            ) from e
E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x0000020703D36290>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:213: NewConnectionError

The above exception was the direct cause of the following exception:

self = <requests.adapters.HTTPAdapter object at 0x0000020704256410>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
>           resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:486: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:841: in urlopen
    retries = retries.increment(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'GET', url = '/api/v1/health', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x0000020703D36290>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x000002070408AD90>
_stacktrace = <traceback object at 0x00000207038EE980>

    def increment(
        self,
        method: str | None = None,
        url: str | None = None,
        response: BaseHTTPResponse | None = None,
        error: Exception | None = None,
        _pool: ConnectionPool | None = None,
        _stacktrace: TracebackType | None = None,
    ) -> Self:
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.BaseHTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or method is None or not self._is_method_retryable(method):
                raise reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            response_redirect_location = response.get_redirect_location()
            if response_redirect_location:
                redirect_location = response_redirect_location
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
            reason = error or ResponseError(cause)
>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/health (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x0000020703D36290>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\urllib3\util\retry.py:519: MaxRetryError

During handling of the above exception, another exception occurred:

    def test_health_endpoint():
        """╥хёЄ health endpoint"""
>       response = requests.get("http://127.0.0.1:8000/api/v1/health", timeout=30)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\integration\test_server_integration.py:11: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\requests\api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:703: in send
    r = adapter.send(request, **kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <requests.adapters.HTTPAdapter object at 0x0000020704256410>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/health (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x0000020703D36290>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:519: ConnectionError
____________________________ test_status_endpoint _____________________________

self = <urllib3.connection.HTTPConnection object at 0x00000207042C7B90>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
>           sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:85: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('127.0.0.1', 8000), timeout = 30, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address: tuple[str, int],
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        source_address: tuple[str, int] | None = None,
        socket_options: _TYPE_SOCKET_OPTIONS | None = None,
    ) -> socket.socket:
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            raise LocationParseError(f"'{host}', label empty or too long") from None
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not _DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:73: ConnectionRefusedError

The above exception was the direct cause of the following exception:

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000207042C7950>
method = 'GET', url = '/api/v1/status', body = None
headers = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate, br', 'Accept': '*/*', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=30, read=30, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None, preload_content = False
decode_content = False, response_kw = {}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/api/v1/status', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(  # type: ignore[override]
        self,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | bool | int | None = None,
        redirect: bool = True,
        assert_same_host: bool = True,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        pool_timeout: int | None = None,
        release_conn: bool | None = None,
        chunked: bool = False,
        body_pos: _TYPE_BODY_POSITION | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        **response_kw: typing.Any,
    ) -> BaseHTTPResponse:
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method
           such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param bool preload_content:
            If True, the response's body will be preloaded into memory.
    
        :param bool decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of ``preload_content``
            which defaults to ``True``.
    
        :param bool chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
        """
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = preload_content
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = to_str(_encode_target(url))
        else:
            url = to_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()  # type: ignore[attr-defined]
            headers.update(self.proxy_headers)  # type: ignore[union-attr]
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]
    
            # Is this a closed/new connection that requires CONNECT tunnelling?
            if self.proxy is not None and http_tunnel_required and conn.is_closed:
                try:
                    self._prepare_proxy(conn)
                except (BaseSSLError, OSError, SocketTimeout) as e:
                    self._raise_timeout(
                        err=e, url=self.proxy.url, timeout_value=conn.timeout
                    )
                    raise
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Make the request on the HTTPConnection object
>           response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
                retries=retries,
                response_conn=response_conn,
                preload_content=preload_content,
                decode_content=decode_content,
                **response_kw,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:493: in _make_request
    conn.request(
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:494: in request
    self.endheaders()
C:\Program Files\Python311\Lib\http\client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
C:\Program Files\Python311\Lib\http\client.py:1037: in _send_output
    self.send(msg)
C:\Program Files\Python311\Lib\http\client.py:975: in send
    self.connect()
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:325: in connect
    self.sock = self._new_conn()
                ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <urllib3.connection.HTTPConnection object at 0x00000207042C7B90>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
            sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )
        except socket.gaierror as e:
            raise NameResolutionError(self.host, self, e) from e
        except SocketTimeout as e:
            raise ConnectTimeoutError(
                self,
                f"Connection to {self.host} timed out. (connect timeout={self.timeout})",
            ) from e
    
        except OSError as e:
>           raise NewConnectionError(
                self, f"Failed to establish a new connection: {e}"
            ) from e
E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x00000207042C7B90>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:213: NewConnectionError

The above exception was the direct cause of the following exception:

self = <requests.adapters.HTTPAdapter object at 0x00000207042C6B90>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
>           resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:486: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:841: in urlopen
    retries = retries.increment(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'GET', url = '/api/v1/status', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000207042C7B90>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x00000207042C7950>
_stacktrace = <traceback object at 0x00000207042C7BC0>

    def increment(
        self,
        method: str | None = None,
        url: str | None = None,
        response: BaseHTTPResponse | None = None,
        error: Exception | None = None,
        _pool: ConnectionPool | None = None,
        _stacktrace: TracebackType | None = None,
    ) -> Self:
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.BaseHTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or method is None or not self._is_method_retryable(method):
                raise reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            response_redirect_location = response.get_redirect_location()
            if response_redirect_location:
                redirect_location = response_redirect_location
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
            reason = error or ResponseError(cause)
>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/status (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000207042C7B90>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\urllib3\util\retry.py:519: MaxRetryError

During handling of the above exception, another exception occurred:

    def test_status_endpoint():
        """╥хёЄ status endpoint"""
>       response = requests.get("http://127.0.0.1:8000/api/v1/status", timeout=30)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\integration\test_server_integration.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\requests\api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:703: in send
    r = adapter.send(request, **kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <requests.adapters.HTTPAdapter object at 0x00000207042C6B90>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /api/v1/status (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x00000207042C7B90>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:519: ConnectionError
______________________________ test_openapi_docs ______________________________

self = <urllib3.connection.HTTPConnection object at 0x0000020703A25F50>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
>           sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:198: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:85: in create_connection
    raise err
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

address = ('127.0.0.1', 8000), timeout = 30, source_address = None
socket_options = [(6, 1, 1)]

    def create_connection(
        address: tuple[str, int],
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        source_address: tuple[str, int] | None = None,
        socket_options: _TYPE_SOCKET_OPTIONS | None = None,
    ) -> socket.socket:
        """Connect to *address* and return the socket object.
    
        Convenience function.  Connect to *address* (a 2-tuple ``(host,
        port)``) and return the socket object.  Passing the optional
        *timeout* parameter will set the timeout on the socket instance
        before attempting to connect.  If no *timeout* is supplied, the
        global default timeout setting returned by :func:`socket.getdefaulttimeout`
        is used.  If *source_address* is set it must be a tuple of (host, port)
        for the socket to bind as a source address before making the connection.
        An host of '' or port 0 tells the OS to use the default.
        """
    
        host, port = address
        if host.startswith("["):
            host = host.strip("[]")
        err = None
    
        # Using the value from allowed_gai_family() in the context of getaddrinfo lets
        # us select whether to work with IPv4 DNS records, IPv6 records, or both.
        # The original create_connection function always returns all records.
        family = allowed_gai_family()
    
        try:
            host.encode("idna")
        except UnicodeError:
            raise LocationParseError(f"'{host}', label empty or too long") from None
    
        for res in socket.getaddrinfo(host, port, family, socket.SOCK_STREAM):
            af, socktype, proto, canonname, sa = res
            sock = None
            try:
                sock = socket.socket(af, socktype, proto)
    
                # If provided, set socket level options before connecting.
                _set_socket_options(sock, socket_options)
    
                if timeout is not _DEFAULT_TIMEOUT:
                    sock.settimeout(timeout)
                if source_address:
                    sock.bind(source_address)
>               sock.connect(sa)
E               ConnectionRefusedError: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\util\connection.py:73: ConnectionRefusedError

The above exception was the direct cause of the following exception:

self = <urllib3.connectionpool.HTTPConnectionPool object at 0x0000020703A27110>
method = 'GET', url = '/docs', body = None
headers = {'User-Agent': 'python-requests/2.31.0', 'Accept-Encoding': 'gzip, deflate, br', 'Accept': '*/*', 'Connection': 'keep-alive'}
retries = Retry(total=0, connect=None, read=False, redirect=None, status=None)
redirect = False, assert_same_host = False
timeout = Timeout(connect=30, read=30, total=None), pool_timeout = None
release_conn = False, chunked = False, body_pos = None, preload_content = False
decode_content = False, response_kw = {}
parsed_url = Url(scheme=None, auth=None, host=None, port=None, path='/docs', query=None, fragment=None)
destination_scheme = None, conn = None, release_this_conn = True
http_tunnel_required = False, err = None, clean_exit = False

    def urlopen(  # type: ignore[override]
        self,
        method: str,
        url: str,
        body: _TYPE_BODY | None = None,
        headers: typing.Mapping[str, str] | None = None,
        retries: Retry | bool | int | None = None,
        redirect: bool = True,
        assert_same_host: bool = True,
        timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
        pool_timeout: int | None = None,
        release_conn: bool | None = None,
        chunked: bool = False,
        body_pos: _TYPE_BODY_POSITION | None = None,
        preload_content: bool = True,
        decode_content: bool = True,
        **response_kw: typing.Any,
    ) -> BaseHTTPResponse:
        """
        Get a connection from the pool and perform an HTTP request. This is the
        lowest level call for making a request, so you'll need to specify all
        the raw details.
    
        .. note::
    
           More commonly, it's appropriate to use a convenience method
           such as :meth:`request`.
    
        .. note::
    
           `release_conn` will only behave as expected if
           `preload_content=False` because we want to make
           `preload_content=False` the default behaviour someday soon without
           breaking backwards compatibility.
    
        :param method:
            HTTP request method (such as GET, POST, PUT, etc.)
    
        :param url:
            The URL to perform the request on.
    
        :param body:
            Data to send in the request body, either :class:`str`, :class:`bytes`,
            an iterable of :class:`str`/:class:`bytes`, or a file-like object.
    
        :param headers:
            Dictionary of custom headers to send, such as User-Agent,
            If-None-Match, etc. If None, pool headers are used. If provided,
            these headers completely replace any pool-specific headers.
    
        :param retries:
            Configure the number of retries to allow before raising a
            :class:`~urllib3.exceptions.MaxRetryError` exception.
    
            If ``None`` (default) will retry 3 times, see ``Retry.DEFAULT``. Pass a
            :class:`~urllib3.util.retry.Retry` object for fine-grained control
            over different types of retries.
            Pass an integer number to retry connection errors that many times,
            but no other types of errors. Pass zero to never retry.
    
            If ``False``, then retries are disabled and any exception is raised
            immediately. Also, instead of raising a MaxRetryError on redirects,
            the redirect response will be returned.
    
        :type retries: :class:`~urllib3.util.retry.Retry`, False, or an int.
    
        :param redirect:
            If True, automatically handle redirects (status codes 301, 302,
            303, 307, 308). Each redirect counts as a retry. Disabling retries
            will disable redirect, too.
    
        :param assert_same_host:
            If ``True``, will make sure that the host of the pool requests is
            consistent else will raise HostChangedError. When ``False``, you can
            use the pool on an HTTP proxy and request foreign hosts.
    
        :param timeout:
            If specified, overrides the default timeout for this one
            request. It may be a float (in seconds) or an instance of
            :class:`urllib3.util.Timeout`.
    
        :param pool_timeout:
            If set and the pool is set to block=True, then this method will
            block for ``pool_timeout`` seconds and raise EmptyPoolError if no
            connection is available within the time period.
    
        :param bool preload_content:
            If True, the response's body will be preloaded into memory.
    
        :param bool decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
    
        :param release_conn:
            If False, then the urlopen call will not release the connection
            back into the pool once a response is received (but will release if
            you read the entire contents of the response such as when
            `preload_content=True`). This is useful if you're not preloading
            the response's content immediately. You will need to call
            ``r.release_conn()`` on the response ``r`` to return the connection
            back into the pool. If None, it takes the value of ``preload_content``
            which defaults to ``True``.
    
        :param bool chunked:
            If True, urllib3 will send the body using chunked transfer
            encoding. Otherwise, urllib3 will send the body using the standard
            content-length form. Defaults to False.
    
        :param int body_pos:
            Position to seek to in file-like body in the event of a retry or
            redirect. Typically this won't need to be set because urllib3 will
            auto-populate the value when needed.
        """
        parsed_url = parse_url(url)
        destination_scheme = parsed_url.scheme
    
        if headers is None:
            headers = self.headers
    
        if not isinstance(retries, Retry):
            retries = Retry.from_int(retries, redirect=redirect, default=self.retries)
    
        if release_conn is None:
            release_conn = preload_content
    
        # Check host
        if assert_same_host and not self.is_same_host(url):
            raise HostChangedError(self, url, retries)
    
        # Ensure that the URL we're connecting to is properly encoded
        if url.startswith("/"):
            url = to_str(_encode_target(url))
        else:
            url = to_str(parsed_url.url)
    
        conn = None
    
        # Track whether `conn` needs to be released before
        # returning/raising/recursing. Update this variable if necessary, and
        # leave `release_conn` constant throughout the function. That way, if
        # the function recurses, the original value of `release_conn` will be
        # passed down into the recursive call, and its value will be respected.
        #
        # See issue #651 [1] for details.
        #
        # [1] <https://github.com/urllib3/urllib3/issues/651>
        release_this_conn = release_conn
    
        http_tunnel_required = connection_requires_http_tunnel(
            self.proxy, self.proxy_config, destination_scheme
        )
    
        # Merge the proxy headers. Only done when not using HTTP CONNECT. We
        # have to copy the headers dict so we can safely change it without those
        # changes being reflected in anyone else's copy.
        if not http_tunnel_required:
            headers = headers.copy()  # type: ignore[attr-defined]
            headers.update(self.proxy_headers)  # type: ignore[union-attr]
    
        # Must keep the exception bound to a separate variable or else Python 3
        # complains about UnboundLocalError.
        err = None
    
        # Keep track of whether we cleanly exited the except block. This
        # ensures we do proper cleanup in finally.
        clean_exit = False
    
        # Rewind body position, if needed. Record current position
        # for future rewinds in the event of a redirect/retry.
        body_pos = set_file_position(body, body_pos)
    
        try:
            # Request a connection from the queue.
            timeout_obj = self._get_timeout(timeout)
            conn = self._get_conn(timeout=pool_timeout)
    
            conn.timeout = timeout_obj.connect_timeout  # type: ignore[assignment]
    
            # Is this a closed/new connection that requires CONNECT tunnelling?
            if self.proxy is not None and http_tunnel_required and conn.is_closed:
                try:
                    self._prepare_proxy(conn)
                except (BaseSSLError, OSError, SocketTimeout) as e:
                    self._raise_timeout(
                        err=e, url=self.proxy.url, timeout_value=conn.timeout
                    )
                    raise
    
            # If we're going to release the connection in ``finally:``, then
            # the response doesn't need to know about the connection. Otherwise
            # it will also try to release it and we'll have a double-release
            # mess.
            response_conn = conn if not release_conn else None
    
            # Make the request on the HTTPConnection object
>           response = self._make_request(
                conn,
                method,
                url,
                timeout=timeout_obj,
                body=body,
                headers=headers,
                chunked=chunked,
                retries=retries,
                response_conn=response_conn,
                preload_content=preload_content,
                decode_content=decode_content,
                **response_kw,
            )

C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:787: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:493: in _make_request
    conn.request(
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:494: in request
    self.endheaders()
C:\Program Files\Python311\Lib\http\client.py:1277: in endheaders
    self._send_output(message_body, encode_chunked=encode_chunked)
C:\Program Files\Python311\Lib\http\client.py:1037: in _send_output
    self.send(msg)
C:\Program Files\Python311\Lib\http\client.py:975: in send
    self.connect()
C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:325: in connect
    self.sock = self._new_conn()
                ^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <urllib3.connection.HTTPConnection object at 0x0000020703A25F50>

    def _new_conn(self) -> socket.socket:
        """Establish a socket connection and set nodelay settings on it.
    
        :return: New socket connection.
        """
        try:
            sock = connection.create_connection(
                (self._dns_host, self.port),
                self.timeout,
                source_address=self.source_address,
                socket_options=self.socket_options,
            )
        except socket.gaierror as e:
            raise NameResolutionError(self.host, self, e) from e
        except SocketTimeout as e:
            raise ConnectTimeoutError(
                self,
                f"Connection to {self.host} timed out. (connect timeout={self.timeout})",
            ) from e
    
        except OSError as e:
>           raise NewConnectionError(
                self, f"Failed to establish a new connection: {e}"
            ) from e
E           urllib3.exceptions.NewConnectionError: <urllib3.connection.HTTPConnection object at 0x0000020703A25F50>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх

C:\Program Files\Python311\Lib\site-packages\urllib3\connection.py:213: NewConnectionError

The above exception was the direct cause of the following exception:

self = <requests.adapters.HTTPAdapter object at 0x0000020703A252D0>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
>           resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:486: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\urllib3\connectionpool.py:841: in urlopen
    retries = retries.increment(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = Retry(total=0, connect=None, read=False, redirect=None, status=None)
method = 'GET', url = '/docs', response = None
error = NewConnectionError('<urllib3.connection.HTTPConnection object at 0x0000020703A25F50>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх')
_pool = <urllib3.connectionpool.HTTPConnectionPool object at 0x0000020703A27110>
_stacktrace = <traceback object at 0x0000020703A25F80>

    def increment(
        self,
        method: str | None = None,
        url: str | None = None,
        response: BaseHTTPResponse | None = None,
        error: Exception | None = None,
        _pool: ConnectionPool | None = None,
        _stacktrace: TracebackType | None = None,
    ) -> Self:
        """Return a new Retry object with incremented retry counters.
    
        :param response: A response object, or None, if the server did not
            return a response.
        :type response: :class:`~urllib3.response.BaseHTTPResponse`
        :param Exception error: An error encountered during the request, or
            None if the response was received successfully.
    
        :return: A new ``Retry`` object.
        """
        if self.total is False and error:
            # Disabled, indicate to re-raise the error.
            raise reraise(type(error), error, _stacktrace)
    
        total = self.total
        if total is not None:
            total -= 1
    
        connect = self.connect
        read = self.read
        redirect = self.redirect
        status_count = self.status
        other = self.other
        cause = "unknown"
        status = None
        redirect_location = None
    
        if error and self._is_connection_error(error):
            # Connect retry?
            if connect is False:
                raise reraise(type(error), error, _stacktrace)
            elif connect is not None:
                connect -= 1
    
        elif error and self._is_read_error(error):
            # Read retry?
            if read is False or method is None or not self._is_method_retryable(method):
                raise reraise(type(error), error, _stacktrace)
            elif read is not None:
                read -= 1
    
        elif error:
            # Other retry?
            if other is not None:
                other -= 1
    
        elif response and response.get_redirect_location():
            # Redirect retry?
            if redirect is not None:
                redirect -= 1
            cause = "too many redirects"
            response_redirect_location = response.get_redirect_location()
            if response_redirect_location:
                redirect_location = response_redirect_location
            status = response.status
    
        else:
            # Incrementing because of a server error like a 500 in
            # status_forcelist and the given method is in the allowed_methods
            cause = ResponseError.GENERIC_ERROR
            if response and response.status:
                if status_count is not None:
                    status_count -= 1
                cause = ResponseError.SPECIFIC_ERROR.format(status_code=response.status)
                status = response.status
    
        history = self.history + (
            RequestHistory(method, url, error, status, redirect_location),
        )
    
        new_retry = self.new(
            total=total,
            connect=connect,
            read=read,
            redirect=redirect,
            status=status_count,
            other=other,
            history=history,
        )
    
        if new_retry.is_exhausted():
            reason = error or ResponseError(cause)
>           raise MaxRetryError(_pool, url, reason) from reason  # type: ignore[arg-type]
            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
E           urllib3.exceptions.MaxRetryError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /docs (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x0000020703A25F50>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\urllib3\util\retry.py:519: MaxRetryError

During handling of the above exception, another exception occurred:

    def test_openapi_docs():
        """╥хёЄ OpenAPI фюъєьхэЄрЎшш"""
>       response = requests.get("http://127.0.0.1:8000/docs", timeout=30)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

tests\integration\test_server_integration.py:29: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Program Files\Python311\Lib\site-packages\requests\api.py:73: in get
    return request("get", url, params=params, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\api.py:59: in request
    return session.request(method=method, url=url, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:589: in request
    resp = self.send(prep, **send_kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
C:\Program Files\Python311\Lib\site-packages\requests\sessions.py:703: in send
    r = adapter.send(request, **kwargs)
        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <requests.adapters.HTTPAdapter object at 0x0000020703A252D0>
request = <PreparedRequest [GET]>, stream = False
timeout = Timeout(connect=30, read=30, total=None), verify = True, cert = None
proxies = OrderedDict()

    def send(
        self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None
    ):
        """Sends PreparedRequest object. Returns Response object.
    
        :param request: The :class:`PreparedRequest <PreparedRequest>` being sent.
        :param stream: (optional) Whether to stream the request content.
        :param timeout: (optional) How long to wait for the server to send
            data before giving up, as a float, or a :ref:`(connect timeout,
            read timeout) <timeouts>` tuple.
        :type timeout: float or tuple or urllib3 Timeout object
        :param verify: (optional) Either a boolean, in which case it controls whether
            we verify the server's TLS certificate, or a string, in which case it
            must be a path to a CA bundle to use
        :param cert: (optional) Any user-provided SSL certificate to be trusted.
        :param proxies: (optional) The proxies dictionary to apply to the request.
        :rtype: requests.Response
        """
    
        try:
            conn = self.get_connection(request.url, proxies)
        except LocationValueError as e:
            raise InvalidURL(e, request=request)
    
        self.cert_verify(conn, request.url, verify, cert)
        url = self.request_url(request, proxies)
        self.add_headers(
            request,
            stream=stream,
            timeout=timeout,
            verify=verify,
            cert=cert,
            proxies=proxies,
        )
    
        chunked = not (request.body is None or "Content-Length" in request.headers)
    
        if isinstance(timeout, tuple):
            try:
                connect, read = timeout
                timeout = TimeoutSauce(connect=connect, read=read)
            except ValueError:
                raise ValueError(
                    f"Invalid timeout {timeout}. Pass a (connect, read) timeout tuple, "
                    f"or a single float to set both timeouts to the same value."
                )
        elif isinstance(timeout, TimeoutSauce):
            pass
        else:
            timeout = TimeoutSauce(connect=timeout, read=timeout)
    
        try:
            resp = conn.urlopen(
                method=request.method,
                url=url,
                body=request.body,
                headers=request.headers,
                redirect=False,
                assert_same_host=False,
                preload_content=False,
                decode_content=False,
                retries=self.max_retries,
                timeout=timeout,
                chunked=chunked,
            )
    
        except (ProtocolError, OSError) as err:
            raise ConnectionError(err, request=request)
    
        except MaxRetryError as e:
            if isinstance(e.reason, ConnectTimeoutError):
                # TODO: Remove this in 3.0.0: see #2811
                if not isinstance(e.reason, NewConnectionError):
                    raise ConnectTimeout(e, request=request)
    
            if isinstance(e.reason, ResponseError):
                raise RetryError(e, request=request)
    
            if isinstance(e.reason, _ProxyError):
                raise ProxyError(e, request=request)
    
            if isinstance(e.reason, _SSLError):
                # This branch is for urllib3 v1.22 and later.
                raise SSLError(e, request=request)
    
>           raise ConnectionError(e, request=request)
E           requests.exceptions.ConnectionError: HTTPConnectionPool(host='127.0.0.1', port=8000): Max retries exceeded with url: /docs (Caused by NewConnectionError('<urllib3.connection.HTTPConnection object at 0x0000020703A25F50>: Failed to establish a new connection: [WinError 10061] ╧юфъы■ўхэшх эх єёЄрэютыхэю, Є.ъ. ъюэхўэ√щ ъюья№■ЄхЁ юЄтхЁу чряЁюё эр яюфъы■ўхэшх'))

C:\Program Files\Python311\Lib\site-packages\requests\adapters.py:519: ConnectionError
____________ TestVisitConfirmationAPI.test_get_visit_info_success _____________

self = <test_visit_confirmation_api.TestVisitConfirmationAPI object at 0x0000020701676B90>
client = <starlette.testclient.TestClient object at 0x0000020703F68D90>
test_visit = <app.models.visit.Visit object at 0x0000020703F6CA50>

    def test_get_visit_info_success(self, client, test_visit):
        """╥хёЄ яюыєўхэш  шэЇюЁьрЎшш ю тшчшЄх яю Єюъхэє"""
        response = client.get(f"/api/v1/visits/info/{test_visit.confirmation_token}")
    
        assert response.status_code == 200
        data = response.json()
    
>       assert data["success"] is True
               ^^^^^^^^^^^^^^^
E       KeyError: 'success'

tests\integration\test_visit_confirmation_api.py:24: KeyError
_________ TestVisitConfirmationAPI.test_get_visit_info_expired_token __________

self = <test_visit_confirmation_api.TestVisitConfirmationAPI object at 0x0000020701677890>
client = <starlette.testclient.TestClient object at 0x0000020703422590>
test_visit = <app.models.visit.Visit object at 0x0000020703F6B650>

    def test_get_visit_info_expired_token(self, client, test_visit):
        """╥хёЄ яюыєўхэш  шэЇюЁьрЎшш ё шёЄхъ°шь Єюъхэюь"""
        # ╙ёЄрэртыштрхь тЁхь  шёЄхўхэш  т яЁю°ыюь
        test_visit.confirmation_expires_at = datetime.utcnow() - timedelta(hours=1)
    
        response = client.get(f"/api/v1/visits/info/{test_visit.confirmation_token}")
    
>       assert response.status_code == 400
E       assert 200 == 400
E        +  where 200 = <Response [200 OK]>.status_code

tests\integration\test_visit_confirmation_api.py:45: AssertionError
________ TestVisitConfirmationAPI.test_confirm_visit_telegram_success _________

self = <test_visit_confirmation_api.TestVisitConfirmationAPI object at 0x0000020701677F10>
client = <starlette.testclient.TestClient object at 0x0000020703B06750>
test_visit = <app.models.visit.Visit object at 0x0000020703B04B90>
test_daily_queue = <app.models.online_queue.DailyQueue object at 0x0000020703F6B890>

    def test_confirm_visit_telegram_success(self, client, test_visit, test_daily_queue):
        """╥хёЄ єёях°эюую яюфЄтхЁцфхэш  тшчшЄр ўхЁхч Telegram"""
        response = client.post("/api/v1/telegram/visits/confirm", json={
            "token": test_visit.confirmation_token,
            "telegram_user_id": "123456789",
            "telegram_username": "testuser"
        })
    
>       assert response.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\integration\test_visit_confirmation_api.py:57: AssertionError
_____ TestVisitConfirmationAPI.test_confirm_visit_telegram_invalid_token ______

self = <test_visit_confirmation_api.TestVisitConfirmationAPI object at 0x00000207016885D0>
client = <starlette.testclient.TestClient object at 0x00000207036FB790>

    def test_confirm_visit_telegram_invalid_token(self, client):
        """╥хёЄ яюфЄтхЁцфхэш  ё эхфхщёЄтшЄхы№э√ь Єюъхэюь"""
        response = client.post("/api/v1/telegram/visits/confirm", json={
            "token": "invalid-token-123",
            "telegram_user_id": "123456789"
        })
    
>       assert response.status_code == 404
E       assert 400 == 404
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\integration\test_visit_confirmation_api.py:72: AssertionError
_____ TestVisitConfirmationAPI.test_confirm_visit_telegram_wrong_channel ______

self = <test_visit_confirmation_api.TestVisitConfirmationAPI object at 0x0000020701688C50>
client = <starlette.testclient.TestClient object at 0x0000020703B6E0D0>
test_visit = <app.models.visit.Visit object at 0x0000020703ED8410>

    def test_confirm_visit_telegram_wrong_channel(self, client, test_visit):
        """╥хёЄ яюфЄтхЁцфхэш  ўхЁхч эхяЁртшы№э√щ ърэры"""
        test_visit.confirmation_channel = "phone"
    
        response = client.post("/api/v1/telegram/visits/confirm", json={
            "token": test_visit.confirmation_token,
            "telegram_user_id": "123456789"
        })
    
        assert response.status_code == 400
        data = response.json()
>       assert "Telegram" in data["detail"]
E       AssertionError: assert 'Telegram' in '╤ыш°ъюь с√ёЄЁр  яюя√Єър яюфЄтхЁцфхэш '

tests\integration\test_visit_confirmation_api.py:87: AssertionError
___________ TestVisitConfirmationAPI.test_confirm_visit_pwa_success ___________

self = <test_visit_confirmation_api.TestVisitConfirmationAPI object at 0x0000020701689290>
client = <starlette.testclient.TestClient object at 0x0000020703F6C5D0>
test_visit = <app.models.visit.Visit object at 0x0000020703B05050>
test_daily_queue = <app.models.online_queue.DailyQueue object at 0x0000020703AD9190>

    def test_confirm_visit_pwa_success(self, client, test_visit, test_daily_queue):
        """╥хёЄ єёях°эюую яюфЄтхЁцфхэш  тшчшЄр ўхЁхч PWA"""
        test_visit.confirmation_channel = "pwa"
    
        response = client.post("/api/v1/patient/visits/confirm", json={
            "token": test_visit.confirmation_token,
>           "patient_phone": test_visit.patient.phone
                             ^^^^^^^^^^^^^^^^^^
        })
E       AttributeError: 'Visit' object has no attribute 'patient'

tests\integration\test_visit_confirmation_api.py:95: AttributeError
_______ TestVisitConfirmationAPI.test_confirm_visit_pwa_phone_mismatch ________

self = <test_visit_confirmation_api.TestVisitConfirmationAPI object at 0x0000020701689910>
client = <starlette.testclient.TestClient object at 0x0000020703D003D0>
test_visit = <app.models.visit.Visit object at 0x0000020703F69C10>

    def test_confirm_visit_pwa_phone_mismatch(self, client, test_visit):
        """╥хёЄ яюфЄтхЁцфхэш  PWA ё эхяЁртшы№э√ь ЄхыхЇюэюь"""
        test_visit.confirmation_channel = "pwa"
    
        response = client.post("/api/v1/patient/visits/confirm", json={
            "token": test_visit.confirmation_token,
            "patient_phone": "+998901111111"
        })
    
        assert response.status_code == 400
        data = response.json()
>       assert "эх ёютярфрхЄ" in data["detail"]
E       AssertionError: assert 'эх ёютярфрхЄ' in '▌ЄюЄ тшчшЄ эхы№ч  яюфЄтхЁфшЄ№ ўхЁхч PWA'

tests\integration\test_visit_confirmation_api.py:115: AssertionError
____ TestVisitConfirmationAPI.test_confirm_visit_creates_queue_entry_today ____

self = <test_visit_confirmation_api.TestVisitConfirmationAPI object at 0x000002070168A890>
client = <starlette.testclient.TestClient object at 0x0000020703BDEED0>
db_session = <sqlalchemy.orm.session.Session object at 0x0000020703BCC210>
test_visit = <app.models.visit.Visit object at 0x00000207042C5110>
test_daily_queue = <app.models.online_queue.DailyQueue object at 0x0000020703ADB150>

    def test_confirm_visit_creates_queue_entry_today(self, client, db_session, test_visit, test_daily_queue):
        """╥хёЄ ёючфрэш  чряшёш т юўхЁхфш яЁш яюфЄтхЁцфхэшш тшчшЄр эр ёхуюфэ """
        # ╙ёЄрэртыштрхь фрЄє тшчшЄр эр ёхуюфэ 
        test_visit.visit_date = date.today()
        db_session.commit()
    
        response = client.post("/api/v1/telegram/visits/confirm", json={
            "token": test_visit.confirmation_token,
            "telegram_user_id": "123456789"
        })
    
>       assert response.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\integration\test_visit_confirmation_api.py:167: AssertionError
___ TestVisitConfirmationAPI.test_confirm_visit_no_queue_entry_future_date ____

self = <test_visit_confirmation_api.TestVisitConfirmationAPI object at 0x0000020701688750>
client = <starlette.testclient.TestClient object at 0x0000020703BDEAD0>
db_session = <sqlalchemy.orm.session.Session object at 0x00000207042C4950>
test_visit = <app.models.visit.Visit object at 0x0000020703D34C50>
test_daily_queue = <app.models.online_queue.DailyQueue object at 0x0000020703C459D0>

    def test_confirm_visit_no_queue_entry_future_date(self, client, db_session, test_visit, test_daily_queue):
        """╥хёЄ юЄёєЄёЄтш  чряшёш т юўхЁхфш яЁш яюфЄтхЁцфхэшш тшчшЄр эр сєфє∙є■ фрЄє"""
        # ╙ёЄрэртыштрхь фрЄє тшчшЄр эр чртЄЁр
        test_visit.visit_date = date.today() + timedelta(days=1)
        db_session.commit()
    
        response = client.post("/api/v1/telegram/visits/confirm", json={
            "token": test_visit.confirmation_token,
            "telegram_user_id": "123456789"
        })
    
>       assert response.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\integration\test_visit_confirmation_api.py:195: AssertionError
_________ TestVisitConfirmationAPI.test_confirm_visit_updates_status __________

self = <test_visit_confirmation_api.TestVisitConfirmationAPI object at 0x000002070168ABD0>
client = <starlette.testclient.TestClient object at 0x0000020703D35D90>
db_session = <sqlalchemy.orm.session.Session object at 0x0000020703D35510>
test_visit = <app.models.visit.Visit object at 0x00000207040BC4D0>

    def test_confirm_visit_updates_status(self, client, db_session, test_visit):
        """╥хёЄ юсэютыхэш  ёЄрЄєёр тшчшЄр яЁш яюфЄтхЁцфхэшш"""
        original_status = test_visit.status
    
        response = client.post("/api/v1/telegram/visits/confirm", json={
            "token": test_visit.confirmation_token,
            "telegram_user_id": "123456789"
        })
    
>       assert response.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\integration\test_visit_confirmation_api.py:217: AssertionError
__________ TestVisitConfirmationAPI.test_confirm_visit_rate_limiting __________

self = <test_visit_confirmation_api.TestVisitConfirmationAPI object at 0x000002070168AF90>
client = <starlette.testclient.TestClient object at 0x000002070161AA90>
test_visit = <app.models.visit.Visit object at 0x00000207036B1450>

    def test_confirm_visit_rate_limiting(self, client, test_visit):
        """╥хёЄ rate limiting яЁш ьэюцхёЄтхээ√ї яюя√Єърї яюфЄтхЁцфхэш """
        # ╧хЁтюх яюфЄтхЁцфхэшх фюыцэю яЁющЄш
        response1 = client.post("/api/v1/telegram/visits/confirm", json={
            "token": test_visit.confirmation_token,
            "telegram_user_id": "123456789"
        })
    
>       assert response1.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\integration\test_visit_confirmation_api.py:236: AssertionError
___________ Test2FAEnforcement.test_admin_cannot_login_without_2fa ____________

self = <tests.test_2fa_enforcement.Test2FAEnforcement object at 0x00000207016953D0>
client = <starlette.testclient.TestClient object at 0x0000020704014950>
admin_user_without_2fa = <app.models.user.User object at 0x0000020704079910>

    def test_admin_cannot_login_without_2fa(
        self, client: TestClient, admin_user_without_2fa: User
    ):
        """Admin ═┼ ьюцхЄ тющЄш схч эрёЄЁющъш 2FA"""
        response = client.post(
            "/api/v1/authentication/login",
            json={
                "username": admin_user_without_2fa.username,
                "password": "admin123",
            },
        )
    
        # ▌эфяюшэЄ тючтЁр∙рхЄ 401, ъюуфр success=False
>       assert response.status_code == 401, f"Expected 401, got {response.status_code}. Response: {response.text}"
E       AssertionError: Expected 401, got 200. Response: {"access_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxNiIsInVzZXJuYW1lIjoidGVzdF9hZG1pbl8yZmEiLCJyb2xlIjoiQWRtaW4iLCJpc19hY3RpdmUiOnRydWUsImlzX3N1cGVydXNlciI6ZmFsc2UsImV4cCI6MTc2NTc3MzkwNiwidHlwZSI6ImFjY2VzcyJ9.KWhScocudxckHcqhMdn58F3ki4JGQMpsunay-9SMOHI","refresh_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxNiwianRpIjoiNjg5YTZkMTAtZDJlZi00NjZiLTg2M2QtMmRhZTBmZTQwMDI0IiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzNjQxMDZ9.DQQOg-6c3I_-knAm1xkqCY5lOSMOTuf7BYT0JyrWKYg","token_type":"bearer","expires_in":1800,"user":{"id":16,"username":"test_admin_2fa","full_name":"Test Admin 2FA","email":"admin2fa@test.com","role":"Admin","is_active":true,"is_superuser":false},"requires_2fa":false,"two_factor_method":null,"pending_2fa_token":null}
E       assert 200 == 401
E        +  where 200 = <Response [200 OK]>.status_code

tests\test_2fa_enforcement.py:159: AssertionError
---------------------------- Captured stdout call -----------------------------
DEBUG: Login endpoint called with username=test_admin_2fa
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 16, 'username': 'test_admin_2fa', 'full_name': 'Test Admin 2FA', 'email': 'admin2fa@test.com', 'role': 'Admin', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxNiIsInVzZXJuYW1lIjoidGVzdF9hZG1pbl8yZmEiLCJyb2xlIjoiQWRtaW4iLCJpc19hY3RpdmUiOnRydWUsImlzX3N1cGVydXNlciI6ZmFsc2UsImV4cCI6MTc2NTc3MzkwNiwidHlwZSI6ImFjY2VzcyJ9.KWhScocudxckHcqhMdn58F3ki4JGQMpsunay-9SMOHI', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxNiwianRpIjoiNjg5YTZkMTAtZDJlZi00NjZiLTg2M2QtMmRhZTBmZTQwMDI0IiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzNjQxMDZ9.DQQOg-6c3I_-knAm1xkqCY5lOSMOTuf7BYT0JyrWKYg', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
__________ Test2FAEnforcement.test_cashier_cannot_login_without_2fa ___________

self = <tests.test_2fa_enforcement.Test2FAEnforcement object at 0x0000020701695A50>
client = <starlette.testclient.TestClient object at 0x0000020703AF25D0>
cashier_user_without_2fa = <app.models.user.User object at 0x0000020703831B10>

    def test_cashier_cannot_login_without_2fa(
        self, client: TestClient, cashier_user_without_2fa: User
    ):
        """Cashier ═┼ ьюцхЄ тющЄш схч эрёЄЁющъш 2FA"""
        response = client.post(
            "/api/v1/authentication/login",
            json={
                "username": cashier_user_without_2fa.username,
                "password": "cashier123",
            },
        )
    
        # ▌эфяюшэЄ тючтЁр∙рхЄ 401, ъюуфр success=False
>       assert response.status_code == 401, f"Expected 401, got {response.status_code}. Response: {response.text}"
E       AssertionError: Expected 401, got 200. Response: {"access_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxNyIsInVzZXJuYW1lIjoidGVzdF9jYXNoaWVyXzJmYSIsInJvbGUiOiJDYXNoaWVyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NzM5MDYsInR5cGUiOiJhY2Nlc3MifQ.9xMWww_YV-3eF_IurxSip_tTImTYWEhkHYmyVjzHJZc","refresh_token":"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxNywianRpIjoiZjdkYWFlNTQtZWU0MC00ZmJmLTkyMmItMTQ5MDgyMDRkYTZmIiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzNjQxMDZ9.1XfWW4ieQm5yvIs_8_w1NGrHDs9kLQfXvUz9cmMVILY","token_type":"bearer","expires_in":1800,"user":{"id":17,"username":"test_cashier_2fa","full_name":"Test Cashier 2FA","email":"cashier2fa@test.com","role":"Cashier","is_active":true,"is_superuser":false},"requires_2fa":false,"two_factor_method":null,"pending_2fa_token":null}
E       assert 200 == 401
E        +  where 200 = <Response [200 OK]>.status_code

tests\test_2fa_enforcement.py:179: AssertionError
---------------------------- Captured stdout call -----------------------------
DEBUG: Login endpoint called with username=test_cashier_2fa
DEBUG: IP=testclient, UserAgent=testclient
DEBUG: Service obtained: <app.services.authentication_service.AuthenticationService object at 0x00000207593D1F10>
DEBUG: login_user result: {'success': True, 'message': '╙ёях°э√щ тїюф', 'user': {'id': 17, 'username': 'test_cashier_2fa', 'full_name': 'Test Cashier 2FA', 'email': 'cashier2fa@test.com', 'role': 'Cashier', 'is_active': True, 'is_superuser': False}, 'tokens': {'access_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxNyIsInVzZXJuYW1lIjoidGVzdF9jYXNoaWVyXzJmYSIsInJvbGUiOiJDYXNoaWVyIiwiaXNfYWN0aXZlIjp0cnVlLCJpc19zdXBlcnVzZXIiOmZhbHNlLCJleHAiOjE3NjU3NzM5MDYsInR5cGUiOiJhY2Nlc3MifQ.9xMWww_YV-3eF_IurxSip_tTImTYWEhkHYmyVjzHJZc', 'refresh_token': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxNywianRpIjoiZjdkYWFlNTQtZWU0MC00ZmJmLTkyMmItMTQ5MDgyMDRkYTZmIiwidHlwZSI6InJlZnJlc2giLCJleHAiOjE3NjgzNjQxMDZ9.1XfWW4ieQm5yvIs_8_w1NGrHDs9kLQfXvUz9cmMVILY', 'token_type': 'bearer', 'expires_in': 1800}, 'requires_2fa': False, 'two_factor_method': None}
____________ TestFileSecurity.test_file_hash_is_computed_on_upload ____________

self = <tests.test_file_security.TestFileSecurity object at 0x00000207016C4910>
client = <starlette.testclient.TestClient object at 0x0000020703C10090>
db_session = <sqlalchemy.orm.session.Session object at 0x0000020703C12E10>

    def test_file_hash_is_computed_on_upload(
        self, client: TestClient, db_session: Session
    ):
        """\u2705 CERTIFICATION: SHA256 \u0445\u0435\u0448 \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u0442\u0441\u044f \u043f\u0440\u0438 \u0437\u0430\u0433\u0440\u0443\u0437\u043a\u0435 \u0444\u0430\u0439\u043b\u0430"""
        # ╤ючфрхь яюы№чютрЄхы  ё Ёюы№■, ъюЄюЁр  ьюцхЄ чруЁєцрЄ№ Їрщы√ (Doctor)
        from app.core.security import get_password_hash
        from app.models.user import User
    
        doctor_user = db_session.query(User).filter(User.username == "doctor_file_test").first()
        if not doctor_user:
            doctor_user = User(
                username="doctor_file_test",
                email="doctor_file@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                is_superuser=False,
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╧юыєўрхь Єюъхэ
        login_response = client.post(
            "/api/v1/auth/minimal-login",
            json={"username": doctor_user.username, "password": "doctor123"},
        )
        assert login_response.status_code == 200
        token = login_response.json()["access_token"]
    
        # ╟руЁєцрхь ЄхёЄют√щ Їрщы
        file_content = b"Test file content for hashing"
        file_obj = BytesIO(file_content)
        file_obj.name = "test.txt"
    
        response = client.post(
            "/api/v1/files/upload",
            files={"file": ("test.txt", file_obj, "text/plain")},
            data={
                "file_type": "document",
                "permission": "private",
            },
            headers={"Authorization": f"Bearer {token}"},
        )
    
>       assert response.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\test_file_security.py:66: AssertionError
---------------------------- Captured stdout call -----------------------------
DEBUG: Minimal login called with username=doctor_file_test
DEBUG: User found: ID=20, Username=doctor_file_test, IsActive=1
DEBUG: Verifying password...
DEBUG: Password verification result: True
DEBUG: Token created successfully, expires in 28800 seconds
DEBUG: Successful authentication for user doctor_file_test
DEBUG: Checking roles for user 20 (doctor_file_test)
DEBUG: User Role: 'Doctor', Normalized: 'doctor'
DEBUG: Required Roles: ('Admin', 'Doctor', 'Nurse', 'Receptionist'), Normalized: ['admin', 'doctor', 'nurse', 'receptionist']
---------------------------- Captured stderr call -----------------------------
WARNING:app.utils.file_validator:[File Validator] Unknown file type for test.txt
------------------------------ Captured log call ------------------------------
WARNING  app.utils.file_validator:file_validator.py:257 [File Validator] Unknown file type for test.txt
__________ TestFileSecurity.test_file_versioning_on_content_replace ___________

self = <tests.test_file_security.TestFileSecurity object at 0x00000207016C4F50>
client = <starlette.testclient.TestClient object at 0x0000020703F6F110>
db_session = <sqlalchemy.orm.session.Session object at 0x0000020703F6C8D0>

    def test_file_versioning_on_content_replace(
        self, client: TestClient, db_session: Session
    ):
        """\u2705 CERTIFICATION: \u0412\u0435\u0440\u0441\u0438\u044f \u0441\u043e\u0437\u0434\u0430\u0435\u0442\u0441\u044f \u043f\u0440\u0438 \u0437\u0430\u043c\u0435\u043d\u0435 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u043c\u043e\u0433\u043e \u0444\u0430\u0439\u043b\u0430"""
        # ╤ючфрхь яюы№чютрЄхы  ё Ёюы№■ Doctor
        from app.core.security import get_password_hash
        from app.models.user import User
    
        doctor_user = db_session.query(User).filter(User.username == "doctor_file_test2").first()
        if not doctor_user:
            doctor_user = User(
                username="doctor_file_test2",
                email="doctor_file2@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                is_superuser=False,
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╧юыєўрхь Єюъхэ
        login_response = client.post(
            "/api/v1/auth/minimal-login",
            json={"username": doctor_user.username, "password": "doctor123"},
        )
        assert login_response.status_code == 200
        token = login_response.json()["access_token"]
    
        # ╪ру 1: ╟руЁєцрхь шёїюфэ√щ Їрщы
        file_content_1 = b"Original file content"
        file_obj_1 = BytesIO(file_content_1)
        file_obj_1.name = "original.txt"
    
        upload_response = client.post(
            "/api/v1/files/upload",
            files={"file": ("original.txt", file_obj_1, "text/plain")},
            data={
                "file_type": "document",
                "permission": "private",
            },
            headers={"Authorization": f"Bearer {token}"},
        )
>       assert upload_response.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\test_file_security.py:121: AssertionError
---------------------------- Captured stdout call -----------------------------
DEBUG: Minimal login called with username=doctor_file_test2
DEBUG: User found: ID=21, Username=doctor_file_test2, IsActive=1
DEBUG: Verifying password...
DEBUG: Password verification result: True
DEBUG: Token created successfully, expires in 28800 seconds
DEBUG: Successful authentication for user doctor_file_test2
DEBUG: Checking roles for user 21 (doctor_file_test2)
DEBUG: User Role: 'Doctor', Normalized: 'doctor'
DEBUG: Required Roles: ('Admin', 'Doctor', 'Nurse', 'Receptionist'), Normalized: ['admin', 'doctor', 'nurse', 'receptionist']
---------------------------- Captured stderr call -----------------------------
WARNING:app.utils.file_validator:[File Validator] Unknown file type for original.txt
------------------------------ Captured log call ------------------------------
WARNING  app.utils.file_validator:file_validator.py:257 [File Validator] Unknown file type for original.txt
_________________ TestFileSecurity.test_file_hash_consistency _________________

self = <tests.test_file_security.TestFileSecurity object at 0x00000207016C5C50>
client = <starlette.testclient.TestClient object at 0x0000020704470DD0>
db_session = <sqlalchemy.orm.session.Session object at 0x0000020704473510>

    def test_file_hash_consistency(
        self, client: TestClient, db_session: Session
    ):
        """\u2705 CERTIFICATION: \u041e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u044b\u0435 \u0444\u0430\u0439\u043b\u044b \u0438\u043c\u0435\u044e\u0442 \u043e\u0434\u0438\u043d\u0430\u043a\u043e\u0432\u044b\u0439 \u0445\u0435\u0448"""
        # ╤ючфрхь яюы№чютрЄхы  ё Ёюы№■ Doctor
        from app.core.security import get_password_hash
        from app.models.user import User
    
        doctor_user = db_session.query(User).filter(User.username == "doctor_file_test3").first()
        if not doctor_user:
            doctor_user = User(
                username="doctor_file_test3",
                email="doctor_file3@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                is_superuser=False,
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╧юыєўрхь Єюъхэ
        login_response = client.post(
            "/api/v1/auth/minimal-login",
            json={"username": doctor_user.username, "password": "doctor123"},
        )
        assert login_response.status_code == 200
        token = login_response.json()["access_token"]
    
        file_content = b"Identical content"
    
        # ╟руЁєцрхь яхЁт√щ Їрщы
        file_obj_1 = BytesIO(file_content)
        file_obj_1.name = "file1.txt"
        response_1 = client.post(
            "/api/v1/files/upload",
            files={"file": ("file1.txt", file_obj_1, "text/plain")},
            data={"file_type": "document", "permission": "private"},
            headers={"Authorization": f"Bearer {token}"},
        )
>       assert response_1.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\test_file_security.py:221: AssertionError
---------------------------- Captured stdout call -----------------------------
DEBUG: Minimal login called with username=doctor_file_test3
DEBUG: User found: ID=22, Username=doctor_file_test3, IsActive=1
DEBUG: Verifying password...
DEBUG: Password verification result: True
DEBUG: Token created successfully, expires in 28800 seconds
DEBUG: Successful authentication for user doctor_file_test3
DEBUG: Checking roles for user 22 (doctor_file_test3)
DEBUG: User Role: 'Doctor', Normalized: 'doctor'
DEBUG: Required Roles: ('Admin', 'Doctor', 'Nurse', 'Receptionist'), Normalized: ['admin', 'doctor', 'nurse', 'receptionist']
---------------------------- Captured stderr call -----------------------------
WARNING:app.utils.file_validator:[File Validator] Unknown file type for file1.txt
------------------------------ Captured log call ------------------------------
WARNING  app.utils.file_validator:file_validator.py:257 [File Validator] Unknown file type for file1.txt
______________ TestFileSecurity.test_file_version_hash_required _______________

self = <tests.test_file_security.TestFileSecurity object at 0x00000207016C6290>
client = <starlette.testclient.TestClient object at 0x0000020703D34210>
db_session = <sqlalchemy.orm.session.Session object at 0x0000020703D37FD0>

    def test_file_version_hash_required(
        self, client: TestClient, db_session: Session
    ):
        """\u2705 CERTIFICATION: \u0412\u0435\u0440\u0441\u0438\u044f \u0444\u0430\u0439\u043b\u0430 \u0441\u043e\u0434\u0435\u0440\u0436\u0438\u0442 file_hash"""
        # ╤ючфрхь яюы№чютрЄхы  ё Ёюы№■ Doctor
        from app.core.security import get_password_hash
        from app.models.user import User
    
        doctor_user = db_session.query(User).filter(User.username == "doctor_file_test4").first()
        if not doctor_user:
            doctor_user = User(
                username="doctor_file_test4",
                email="doctor_file4@test.com",
                hashed_password=get_password_hash("doctor123"),
                role="Doctor",
                is_active=True,
                is_superuser=False,
            )
            db_session.add(doctor_user)
            db_session.commit()
            db_session.refresh(doctor_user)
    
        # ╧юыєўрхь Єюъхэ
        login_response = client.post(
            "/api/v1/auth/minimal-login",
            json={"username": doctor_user.username, "password": "doctor123"},
        )
        assert login_response.status_code == 200
        token = login_response.json()["access_token"]
    
        # ╟руЁєцрхь Їрщы
        file_content = b"Version test"
        file_obj = BytesIO(file_content)
        file_obj.name = "version_test.txt"
    
        upload_response = client.post(
            "/api/v1/files/upload",
            files={"file": ("version_test.txt", file_obj, "text/plain")},
            data={"file_type": "document", "permission": "private"},
            headers={"Authorization": f"Bearer {token}"},
        )
>       assert upload_response.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\test_file_security.py:280: AssertionError
---------------------------- Captured stdout call -----------------------------
DEBUG: Minimal login called with username=doctor_file_test4
DEBUG: User found: ID=23, Username=doctor_file_test4, IsActive=1
DEBUG: Verifying password...
DEBUG: Password verification result: True
DEBUG: Token created successfully, expires in 28800 seconds
DEBUG: Successful authentication for user doctor_file_test4
DEBUG: Checking roles for user 23 (doctor_file_test4)
DEBUG: User Role: 'Doctor', Normalized: 'doctor'
DEBUG: Required Roles: ('Admin', 'Doctor', 'Nurse', 'Receptionist'), Normalized: ['admin', 'doctor', 'nurse', 'receptionist']
---------------------------- Captured stderr call -----------------------------
WARNING:app.utils.file_validator:[File Validator] Unknown file type for version_test.txt
------------------------------ Captured log call ------------------------------
WARNING  app.utils.file_validator:file_validator.py:257 [File Validator] Unknown file type for version_test.txt
_______________ TestRateLimiting.test_rate_limit_login_endpoint _______________

self = <tests.test_security_middleware.TestRateLimiting object at 0x00000207016D83D0>
app_with_security = <fastapi.applications.FastAPI object at 0x0000020703C83910>

    def test_rate_limit_login_endpoint(self, app_with_security):
        """╥хёЄ: яЁхт√°хэшх ышьшЄр эр login endpoint"""
        client = TestClient(app_with_security)
        # ─хырхь 6 чряЁюёют (ышьшЄ: 5 чр 5 ьшэєЄ)
        for i in range(5):
            response = client.post("/api/v1/authentication/login")
            assert response.status_code in [200, 400, 401]  # ╠юцхЄ с√Є№ ю°шсър трышфрЎшш
    
        # 6-щ чряЁюё фюыцхэ с√Є№ чрсыюъшЁютрэ
        response = client.post("/api/v1/authentication/login")
>       assert response.status_code == status.HTTP_429_TOO_MANY_REQUESTS
E       assert 200 == 429
E        +  where 200 = <Response [200 OK]>.status_code
E        +  and   429 = status.HTTP_429_TOO_MANY_REQUESTS

tests\test_security_middleware.py:64: AssertionError
_________________ TestRateLimiting.test_rate_limit_2fa_verify _________________

self = <tests.test_security_middleware.TestRateLimiting object at 0x00000207016D8750>
app_with_security = <fastapi.applications.FastAPI object at 0x0000020703BC0E90>

    def test_rate_limit_2fa_verify(self, app_with_security):
        """╥хёЄ: яЁхт√°хэшх ышьшЄр эр 2FA verify endpoint"""
        client = TestClient(app_with_security)
        # ─хырхь 11 чряЁюёют (ышьшЄ: 10 чр 5 ьшэєЄ)
        for i in range(10):
            response = client.post("/api/v1/2fa/verify")
            assert response.status_code in [200, 400, 401]
    
        # 11-щ чряЁюё фюыцхэ с√Є№ чрсыюъшЁютрэ
        response = client.post("/api/v1/2fa/verify")
>       assert response.status_code == status.HTTP_429_TOO_MANY_REQUESTS
E       assert 200 == 429
E        +  where 200 = <Response [200 OK]>.status_code
E        +  and   429 = status.HTTP_429_TOO_MANY_REQUESTS

tests\test_security_middleware.py:77: AssertionError
_______________ TestRateLimiting.test_rate_limit_password_reset _______________

self = <tests.test_security_middleware.TestRateLimiting object at 0x00000207016D8AD0>
app_with_security = <fastapi.applications.FastAPI object at 0x0000020703F6F5D0>

    def test_rate_limit_password_reset(self, app_with_security):
        """╥хёЄ: яЁхт√°хэшх ышьшЄр эр password reset endpoint"""
        client = TestClient(app_with_security)
        # ─хырхь 4 чряЁюёр (ышьшЄ: 3 чр ўрё)
        for i in range(3):
            response = client.post("/api/v1/authentication/password-reset")
            assert response.status_code in [200, 400]
    
        # 4-щ чряЁюё фюыцхэ с√Є№ чрсыюъшЁютрэ
        response = client.post("/api/v1/authentication/password-reset")
>       assert response.status_code == status.HTTP_429_TOO_MANY_REQUESTS
E       assert 200 == 429
E        +  where 200 = <Response [200 OK]>.status_code
E        +  and   429 = status.HTTP_429_TOO_MANY_REQUESTS

tests\test_security_middleware.py:89: AssertionError
__________________ TestRateLimiting.test_rate_limit_headers ___________________

self = <tests.test_security_middleware.TestRateLimiting object at 0x00000207016D8F50>
app_with_security = <fastapi.applications.FastAPI object at 0x00000207036E6890>

    def test_rate_limit_headers(self, app_with_security):
        """╥хёЄ: яЁютхЁър чруюыютъют rate limit"""
        client = TestClient(app_with_security)
        response = client.post("/api/v1/authentication/login")
        # ╟руюыютъш фюсрты ■Єё  Єюы№ъю фы  єёях°э√ї чряЁюёют (status < 400)
        if response.status_code < 400:
>           assert "X-RateLimit-Limit" in response.headers
E           AssertionError: assert 'X-RateLimit-Limit' in Headers({'content-length': '30', 'content-type': 'application/json'})
E            +  where Headers({'content-length': '30', 'content-type': 'application/json'}) = <Response [200 OK]>.headers

tests\test_security_middleware.py:97: AssertionError
___________ TestBruteForceProtection.test_brute_force_login_blocked ___________

self = <tests.test_security_middleware.TestBruteForceProtection object at 0x00000207016D9ED0>
client = <starlette.testclient.TestClient object at 0x0000020703A16ED0>

    def test_brute_force_login_blocked(self, client: TestClient):
        """╥хёЄ: сыюъшЁютър IP яюёых ьэюцхёЄтхээ√ї эхєфрўэ√ї яюя√Єюъ login"""
        # ╤шьєышЁєхь эхєфрўэ√х яюя√Єъш (4xx/5xx юЄтхЄ√)
        # ─ы  ¤Єюую эєцэю, ўЄюс√ endpoint тючтЁр∙ры ю°шсъє
    
        # ╤ючфрхь юЄфхы№э√щ endpoint, ъюЄюЁ√щ тёхуфр тючтЁр∙рхЄ ю°шсъє
        app = FastAPI()
    
        @app.post("/api/v1/authentication/login")
        async def failing_login():
            from fastapi import HTTPException
            raise HTTPException(status_code=401, detail="Invalid credentials")
    
        app.add_middleware(SecurityMiddleware)
        test_client = TestClient(app)
    
        # ─хырхь 5 эхєфрўэ√ї яюя√Єюъ (ышьшЄ: 5)
        for i in range(5):
            response = test_client.post("/api/v1/authentication/login")
            assert response.status_code == 401
    
        # 6-  яюя√Єър фюыцэр с√Є№ чрсыюъшЁютрэр
        response = test_client.post("/api/v1/authentication/login")
>       assert response.status_code == status.HTTP_429_TOO_MANY_REQUESTS
E       assert 401 == 429
E        +  where 401 = <Response [401 Unauthorized]>.status_code
E        +  and   429 = status.HTTP_429_TOO_MANY_REQUESTS

tests\test_security_middleware.py:138: AssertionError
____________ TestBruteForceProtection.test_brute_force_2fa_blocked ____________

self = <tests.test_security_middleware.TestBruteForceProtection object at 0x00000207016DA590>
client = <starlette.testclient.TestClient object at 0x0000020703A40E90>

    def test_brute_force_2fa_blocked(self, client: TestClient):
        """╥хёЄ: сыюъшЁютър IP яюёых ьэюцхёЄтхээ√ї эхєфрўэ√ї яюя√Єюъ 2FA"""
        app = FastAPI()
    
        @app.post("/api/v1/2fa/verify")
        async def failing_2fa():
            from fastapi import HTTPException
            raise HTTPException(status_code=400, detail="Invalid OTP")
    
        app.add_middleware(SecurityMiddleware)
        test_client = TestClient(app)
    
        # ─хырхь 5 эхєфрўэ√ї яюя√Єюъ
        for i in range(5):
            response = test_client.post("/api/v1/2fa/verify")
            assert response.status_code == 400
    
        # 6-  яюя√Єър фюыцэр с√Є№ чрсыюъшЁютрэр
        response = test_client.post("/api/v1/2fa/verify")
>       assert response.status_code == status.HTTP_429_TOO_MANY_REQUESTS
E       assert 400 == 429
E        +  where 400 = <Response [400 Bad Request]>.status_code
E        +  and   429 = status.HTTP_429_TOO_MANY_REQUESTS

tests\test_security_middleware.py:160: AssertionError
____ TestSecurityMiddlewareIntegration.test_rate_limit_reset_after_window _____

self = <tests.test_security_middleware.TestSecurityMiddlewareIntegration object at 0x00000207016E0C50>
client = <starlette.testclient.TestClient object at 0x0000020703AB2F90>

    def test_rate_limit_reset_after_window(self, client: TestClient):
        """╥хёЄ: rate limit ёсЁрё√трхЄё  яюёых юъэр тЁхьхэш"""
        # ▌ЄюЄ ЄхёЄ ёыюцэю т√яюыэшЄ№ схч ьюъшЁютрэш  тЁхьхэш
        # ═ю ьюцэю яЁютхЁшЄ№, ўЄю ёўхЄўшъш юўш∙р■Єё 
        middleware = SecurityMiddleware(None)
    
        # ╤шьєышЁєхь ёЄрЁ√х чряшёш (ёЄрЁ°х юъэр)
        import time
        old_timestamp = time.time() - 2000  # 2000 ёхъєэф эрчрф (сюы№°х юъэр т 1 ўрё)
        middleware.request_counts["test:127.0.0.1"] = [old_timestamp]
    
        # ┬√ч√трхь cleanup
        middleware._cleanup_old_records()
    
        # ╧ЁютхЁ хь, ўЄю ёЄрЁ√х чряшёш єфрыхэ√
        # ╚ёяюы№чєхь юс√ўэ√щ dict тьхёЄю defaultdict фы  яЁютхЁъш
        if "test:127.0.0.1" in middleware.request_counts:
>           assert len(middleware.request_counts["test:127.0.0.1"]) == 0
E           assert 1 == 0
E            +  where 1 = len([1765770108.2921124])

tests\test_security_middleware.py:232: AssertionError
_ TestConfirmationSecurityService.test_validate_confirmation_request_valid_token _

self = <test_confirmation_security.TestConfirmationSecurityService object at 0x00000207017109D0>
db_session = <sqlalchemy.orm.session.Session object at 0x0000020703A41910>
test_visit = <app.models.visit.Visit object at 0x0000020703C9C810>

    def test_validate_confirmation_request_valid_token(self, db_session, test_visit):
        """╥хёЄ трышфрЎшш ъюЁЁхъЄэюую Єюъхэр"""
        service = ConfirmationSecurityService(db_session)
    
        result = service.validate_confirmation_request(
            token=test_visit.confirmation_token,
            source_ip="192.168.1.1",
            user_agent="TestAgent/1.0",
            channel="telegram"
        )
    
>       assert result.allowed is True
E       AssertionError: assert False is True
E        +  where False = SecurityCheckResult(allowed=False, reason='╤ыш°ъюь с√ёЄЁр  яюя√Єър яюфЄтхЁцфхэш ', retry_after=None, remaining_attempts=None).allowed

tests\unit\test_confirmation_security.py:33: AssertionError
_ TestConfirmationSecurityService.test_validate_confirmation_request_expired_token _

self = <test_confirmation_security.TestConfirmationSecurityService object at 0x0000020701710E90>
db_session = <sqlalchemy.orm.session.Session object at 0x0000020703AB12D0>
test_visit = <app.models.visit.Visit object at 0x0000020703CBB890>

    def test_validate_confirmation_request_expired_token(self, db_session, test_visit):
        """╥хёЄ трышфрЎшш шёЄхъ°хую Єюъхэр"""
        # ╙ёЄрэртыштрхь тЁхь  шёЄхўхэш  т яЁю°ыюь
        test_visit.confirmation_expires_at = datetime.utcnow() - timedelta(hours=1)
        db_session.commit()
    
        service = ConfirmationSecurityService(db_session)
    
        result = service.validate_confirmation_request(
            token=test_visit.confirmation_token,
            source_ip="192.168.1.1",
            user_agent="TestAgent/1.0",
            channel="telegram"
        )
    
        assert result.allowed is False
>       assert "╤Ёюъ фхщёЄтш  Єюъхэр шёЄхъ" in result.reason
E       AssertionError: assert '╤Ёюъ фхщёЄтш  Єюъхэр шёЄхъ' in '╤ыш°ъюь с√ёЄЁр  яюя√Єър яюфЄтхЁцфхэш '
E        +  where '╤ыш°ъюь с√ёЄЁр  яюя√Єър яюфЄтхЁцфхэш ' = SecurityCheckResult(allowed=False, reason='╤ыш°ъюь с√ёЄЁр  яюя√Єър яюфЄтхЁцфхэш ', retry_after=None, remaining_attempts=None).reason

tests\unit\test_confirmation_security.py:66: AssertionError
_ TestConfirmationSecurityService.test_validate_confirmation_request_wrong_status _

self = <test_confirmation_security.TestConfirmationSecurityService object at 0x0000020701711290>
db_session = <sqlalchemy.orm.session.Session object at 0x0000020704336110>
test_visit = <app.models.visit.Visit object at 0x0000020703C13090>

    def test_validate_confirmation_request_wrong_status(self, db_session, test_visit):
        """╥хёЄ трышфрЎшш Єюъхэр ё эхяЁртшы№э√ь ёЄрЄєёюь тшчшЄр"""
        test_visit.status = "confirmed"
        db_session.commit()
    
        service = ConfirmationSecurityService(db_session)
    
        result = service.validate_confirmation_request(
            token=test_visit.confirmation_token,
            source_ip="192.168.1.1",
            user_agent="TestAgent/1.0",
            channel="telegram"
        )
    
        assert result.allowed is False
>       assert "єцх шьххЄ ёЄрЄєё" in result.reason
E       AssertionError: assert 'єцх шьххЄ ёЄрЄєё' in '╤ыш°ъюь с√ёЄЁр  яюя√Єър яюфЄтхЁцфхэш '
E        +  where '╤ыш°ъюь с√ёЄЁр  яюя√Єър яюфЄтхЁцфхэш ' = SecurityCheckResult(allowed=False, reason='╤ыш°ъюь с√ёЄЁр  яюя√Єър яюфЄтхЁцфхэш ', retry_after=None, remaining_attempts=None).reason

tests\unit\test_confirmation_security.py:83: AssertionError
_ TestConfirmationSecurityService.test_validate_confirmation_request_suspicious_user_agent _

self = <test_confirmation_security.TestConfirmationSecurityService object at 0x0000020701711710>
db_session = <sqlalchemy.orm.session.Session object at 0x0000020703BC06D0>
test_visit = <app.models.visit.Visit object at 0x0000020703C9D190>

    def test_validate_confirmation_request_suspicious_user_agent(self, db_session, test_visit):
        """╥хёЄ юсэрЁєцхэш  яюфючЁшЄхы№эюую User-Agent"""
        service = ConfirmationSecurityService(db_session)
    
        result = service.validate_confirmation_request(
            token=test_visit.confirmation_token,
            source_ip="192.168.1.1",
            user_agent="Googlebot/2.1",
            channel="telegram"
        )
    
        assert result.allowed is False
>       assert "яюфючЁшЄхы№э√щ User-Agent" in result.reason
E       AssertionError: assert 'яюфючЁшЄхы№э√щ User-Agent' in '╧юфючЁшЄхы№э√щ User-Agent'
E        +  where '╧юфючЁшЄхы№э√щ User-Agent' = SecurityCheckResult(allowed=False, reason='╧юфючЁшЄхы№э√щ User-Agent', retry_after=None, remaining_attempts=None).reason

tests\unit\test_confirmation_security.py:97: AssertionError
________ TestMigrationService.test_get_or_create_daily_queue_existing _________

self = <test_migration_service.TestMigrationService object at 0x0000020701727510>
db_session = <sqlalchemy.orm.session.Session object at 0x0000020703A41A50>
test_daily_queue = <app.models.online_queue.DailyQueue object at 0x0000020703C57DD0>

    def test_get_or_create_daily_queue_existing(self, db_session, test_daily_queue):
        """╥хёЄ яюыєўхэш  ёє∙хёЄтє■∙хщ фэхтэющ юўхЁхфш"""
        service = MigrationService(db_session)
    
        queue = service._get_or_create_daily_queue(
            day=test_daily_queue.day,
            specialist_id=test_daily_queue.specialist_id,
            queue_tag=test_daily_queue.queue_tag
        )
    
>       assert queue.id == test_daily_queue.id
E       assert 19 == 10012
E        +  where 19 = <app.models.online_queue.DailyQueue object at 0x0000020703AB1E90>.id
E        +  and   10012 = <app.models.online_queue.DailyQueue object at 0x0000020703C57DD0>.id

tests\unit\test_migration_service.py:67: AssertionError
___________ TestMigrationService.test_check_data_integrity_empty_db ___________

self = <test_migration_service.TestMigrationService object at 0x000002070172C910>
db_session = <sqlalchemy.orm.session.Session object at 0x0000020703A7BBD0>

    def test_check_data_integrity_empty_db(self, db_session):
        """╥хёЄ яЁютхЁъш ЎхыюёЄэюёЄш фрээ√ї т яєёЄющ ┴─"""
        service = MigrationService(db_session)
    
        result = service._check_data_integrity()
    
>       assert result["passed"] is True
E       assert False is True

tests\unit\test_migration_service.py:100: AssertionError
__________ TestMigrationService.test_check_data_integrity_with_data ___________

self = <test_migration_service.TestMigrationService object at 0x000002070172CF50>
db_session = <sqlalchemy.orm.session.Session object at 0x0000020703A77510>
test_queue_entry = <app.models.online_queue.OnlineQueueEntry object at 0x0000020703C8B2D0>

    def test_check_data_integrity_with_data(self, db_session, test_queue_entry):
        """╥хёЄ яЁютхЁъш ЎхыюёЄэюёЄш фрээ√ї ё ёє∙хёЄтє■∙шьш фрээ√ьш"""
        service = MigrationService(db_session)
    
        result = service._check_data_integrity()
    
>       assert result["passed"] is True
E       assert False is True

tests\unit\test_migration_service.py:112: AssertionError
______________ TestMigrationService.test_backup_queue_data_empty ______________

self = <test_migration_service.TestMigrationService object at 0x000002070172D5D0>
db_session = <sqlalchemy.orm.session.Session object at 0x0000020703A40CD0>

    def test_backup_queue_data_empty(self, db_session):
        """╥хёЄ ёючфрэш  ЁхчхЁтэющ ъюяшш яєёЄ√ї фрээ√ї"""
        service = MigrationService(db_session)
    
        with patch('os.makedirs'), patch('builtins.open', create=True) as mock_open:
            mock_file = MagicMock()
            mock_open.return_value.__enter__.return_value = mock_file
    
            result = service.backup_queue_data(date.today())
    
            assert result["success"] is True
>           assert result["queues_count"] == 0
E           assert 29 == 0

tests\unit\test_migration_service.py:126: AssertionError
____________ TestMigrationService.test_backup_queue_data_with_data ____________

self = <test_migration_service.TestMigrationService object at 0x000002070172DC10>
db_session = <sqlalchemy.orm.session.Session object at 0x000002070435A3D0>
test_daily_queue = <app.models.online_queue.DailyQueue object at 0x0000020703C9C1D0>
test_queue_entry = <app.models.online_queue.OnlineQueueEntry object at 0x00000207042F0F10>

    def test_backup_queue_data_with_data(self, db_session, test_daily_queue, test_queue_entry):
        """╥хёЄ ёючфрэш  ЁхчхЁтэющ ъюяшш ё фрээ√ьш"""
        service = MigrationService(db_session)
    
        with patch('os.makedirs'), patch('builtins.open', create=True) as mock_open:
            mock_file = MagicMock()
            mock_open.return_value.__enter__.return_value = mock_file
    
            result = service.backup_queue_data(date.today())
    
            assert result["success"] is True
>           assert result["queues_count"] == 1
E           assert 30 == 1

tests\unit\test_migration_service.py:141: AssertionError
______________ TestMigrationService.test_cleanup_old_data_empty _______________

self = <test_migration_service.TestMigrationService object at 0x000002070172F610>
db_session = <sqlalchemy.orm.session.Session object at 0x0000020704344710>

    def test_cleanup_old_data_empty(self, db_session):
        """╥хёЄ юўшёЄъш ёЄрЁ√ї фрээ√ї т яєёЄющ ┴─"""
        service = MigrationService(db_session)
    
        result = service.cleanup_old_data(days_to_keep=30)
    
        assert result["success"] is True
>       assert result["deleted_queues"] == 0
E       assert 6 == 0

tests\unit\test_migration_service.py:220: AssertionError
============================== warnings summary ===============================
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1093
  C:\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1093: PydanticDeprecatedSince20: Using extra keyword arguments on `Field` is deprecated and will be removed. Use `json_schema_extra` instead. (Extra keys: 'env'). Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warn(

..\..\Program Files\Python311\Lib\site-packages\pydantic\_internal\_config.py:323: 51 warnings
  C:\Program Files\Python311\Lib\site-packages\pydantic\_internal\_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1068
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1068
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1068
  C:\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1068: PydanticDeprecatedSince20: `max_items` is deprecated and will be removed, use `max_length` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warn('`max_items` is deprecated and will be removed, use `max_length` instead', DeprecationWarning)

..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1062
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1062
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1062
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1062
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1062
..\..\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1062
  C:\Program Files\Python311\Lib\site-packages\pydantic\fields.py:1062: PydanticDeprecatedSince20: `min_items` is deprecated and will be removed, use `min_length` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warn('`min_items` is deprecated and will be removed, use `min_length` instead', DeprecationWarning)

tests\integration\test_e2e_doctor_visit.py:152
  C:\final\backend\tests\integration\test_e2e_doctor_visit.py:152: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests\integration\test_e2e_doctor_visit.py:312
  C:\final\backend\tests\integration\test_e2e_doctor_visit.py:312: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests\integration\test_e2e_doctor_visit.py:350
  C:\final\backend\tests\integration\test_e2e_doctor_visit.py:350: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests\integration\test_e2e_patient_flow.py:140
  C:\final\backend\tests\integration\test_e2e_patient_flow.py:140: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests\integration\test_e2e_patient_flow.py:305
  C:\final\backend\tests\integration\test_e2e_patient_flow.py:305: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests\integration\test_e2e_payment_flow.py:92
  C:\final\backend\tests\integration\test_e2e_payment_flow.py:92: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests\integration\test_e2e_payment_flow.py:212
  C:\final\backend\tests\integration\test_e2e_payment_flow.py:212: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests\integration\test_e2e_payment_flow.py:247
  C:\final\backend\tests\integration\test_e2e_payment_flow.py:247: PytestUnknownMarkWarning: Unknown pytest.mark.e2e - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @pytest.mark.e2e

tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
tests/integration/test_rbac_matrix.py::TestPositiveRBAC::test_admin_can_create_patient
tests/integration/test_rbac_matrix.py::TestPositiveRBAC::test_registrar_can_create_patient
tests/test_audit_logs.py::test_audit_log_create_patient
tests/test_audit_logs.py::test_audit_log_request_id
tests/test_audit_logs.py::test_audit_log_request_id
tests/test_audit_logs.py::test_audit_log_request_id
  C:\final\backend\app\crud\base.py:30: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    data: Dict[str, Any] = obj_in.dict(exclude_unset=True)

tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
tests/integration/test_rbac_matrix.py::TestPositiveRBAC::test_doctor_can_read_patient
tests/test_audit_logs.py::test_audit_log_update_patient
tests/test_audit_logs.py::test_audit_log_delete_patient
  C:\final\backend\app\crud\base.py:21: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    return db.query(self.model).get(id)

tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
  C:\final\backend\app\api\v1\endpoints\appointment_flow.py:389: PydanticDeprecatedSince20: The `from_orm` method is deprecated; set `model_config['from_attributes']=True` and use `model_validate` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    emr_dict = EMRSchema.from_orm(new_emr).dict()

tests/integration/test_e2e_clinic.py::test_e2e_clinic_flow
  C:\final\backend\app\api\v1\endpoints\appointment_flow.py:389: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    emr_dict = EMRSchema.from_orm(new_emr).dict()

tests/test_audit_logs.py::test_audit_log_update_patient
  C:\final\backend\app\crud\base.py:68: PydanticDeprecatedSince20: The `dict` method is deprecated; use `model_dump` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    update_data = obj_in.dict(exclude_unset=True)

tests/test_audit_logs.py::test_audit_log_delete_patient
  C:\final\backend\app\crud\base.py:98: LegacyAPIWarning: The Query.get() method is considered legacy as of the 1.x series of SQLAlchemy and becomes a legacy construct in 2.0. The method is now available as Session.get() (deprecated since: 2.0) (Background on SQLAlchemy 2.0 at: https://sqlalche.me/e/b8d9)
    obj = db.query(self.model).get(id)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED tests/integration/test_e2e_migration_flow.py::TestE2EMigrationFlow::test_complete_migration_flow
FAILED tests/integration/test_e2e_migration_flow.py::TestE2EMigrationFlow::test_migration_with_old_data_cleanup
FAILED tests/integration/test_e2e_migration_flow.py::TestE2EMigrationFlow::test_migration_service_direct_integration
FAILED tests/integration/test_e2e_migration_flow.py::TestE2EMigrationFlow::test_error_recovery_in_migration_flow
FAILED tests/integration/test_e2e_migration_flow.py::TestE2EMigrationFlow::test_concurrent_migration_operations
FAILED tests/integration/test_e2e_patient_flow.py::TestPatientAuthFlow::test_unauthorized_access_rejected
FAILED tests/integration/test_e2e_patient_flow.py::TestPatientAuthFlow::test_invalid_token_rejected
FAILED tests/integration/test_e2e_payment_flow.py::TestPaymentSecurity::test_invalid_amount_rejected
FAILED tests/integration/test_e2e_visit_flow.py::TestE2EVisitFlow::test_complete_visit_flow_future_date
FAILED tests/integration/test_e2e_visit_flow.py::TestE2EVisitFlow::test_morning_assignment_flow
FAILED tests/integration/test_e2e_visit_flow.py::TestE2EVisitFlow::test_registrar_confirmation_flow
FAILED tests/integration/test_e2e_visit_flow.py::TestE2EVisitFlow::test_multiple_services_queue_assignment
FAILED tests/integration/test_e2e_visit_flow.py::TestE2EVisitFlow::test_error_handling_in_flow
FAILED tests/integration/test_e2e_visit_flow.py::TestE2EVisitFlow::test_notification_integration
FAILED tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_check_data_integrity_with_data
FAILED tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_restore_queue_data_file_not_found
FAILED tests/integration/test_migration_management_api.py::TestMigrationManagementAPI::test_api_error_handling
FAILED tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_empty_services_list_error
FAILED tests/integration/test_server_integration.py::test_health_endpoint - r...
FAILED tests/integration/test_server_integration.py::test_status_endpoint - r...
FAILED tests/integration/test_server_integration.py::test_openapi_docs - requ...
FAILED tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_get_visit_info_success
FAILED tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_get_visit_info_expired_token
FAILED tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_telegram_success
FAILED tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_telegram_invalid_token
FAILED tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_telegram_wrong_channel
FAILED tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_pwa_success
FAILED tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_pwa_phone_mismatch
FAILED tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_creates_queue_entry_today
FAILED tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_no_queue_entry_future_date
FAILED tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_updates_status
FAILED tests/integration/test_visit_confirmation_api.py::TestVisitConfirmationAPI::test_confirm_visit_rate_limiting
FAILED tests/test_2fa_enforcement.py::Test2FAEnforcement::test_admin_cannot_login_without_2fa
FAILED tests/test_2fa_enforcement.py::Test2FAEnforcement::test_cashier_cannot_login_without_2fa
FAILED tests/test_file_security.py::TestFileSecurity::test_file_hash_is_computed_on_upload
FAILED tests/test_file_security.py::TestFileSecurity::test_file_versioning_on_content_replace
FAILED tests/test_file_security.py::TestFileSecurity::test_file_hash_consistency
FAILED tests/test_file_security.py::TestFileSecurity::test_file_version_hash_required
FAILED tests/test_security_middleware.py::TestRateLimiting::test_rate_limit_login_endpoint
FAILED tests/test_security_middleware.py::TestRateLimiting::test_rate_limit_2fa_verify
FAILED tests/test_security_middleware.py::TestRateLimiting::test_rate_limit_password_reset
FAILED tests/test_security_middleware.py::TestRateLimiting::test_rate_limit_headers
FAILED tests/test_security_middleware.py::TestBruteForceProtection::test_brute_force_login_blocked
FAILED tests/test_security_middleware.py::TestBruteForceProtection::test_brute_force_2fa_blocked
FAILED tests/test_security_middleware.py::TestSecurityMiddlewareIntegration::test_rate_limit_reset_after_window
FAILED tests/unit/test_confirmation_security.py::TestConfirmationSecurityService::test_validate_confirmation_request_valid_token
FAILED tests/unit/test_confirmation_security.py::TestConfirmationSecurityService::test_validate_confirmation_request_expired_token
FAILED tests/unit/test_confirmation_security.py::TestConfirmationSecurityService::test_validate_confirmation_request_wrong_status
FAILED tests/unit/test_confirmation_security.py::TestConfirmationSecurityService::test_validate_confirmation_request_suspicious_user_agent
FAILED tests/unit/test_migration_service.py::TestMigrationService::test_get_or_create_daily_queue_existing
FAILED tests/unit/test_migration_service.py::TestMigrationService::test_check_data_integrity_empty_db
FAILED tests/unit/test_migration_service.py::TestMigrationService::test_check_data_integrity_with_data
FAILED tests/unit/test_migration_service.py::TestMigrationService::test_backup_queue_data_empty
FAILED tests/unit/test_migration_service.py::TestMigrationService::test_backup_queue_data_with_data
FAILED tests/unit/test_migration_service.py::TestMigrationService::test_cleanup_old_data_empty
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_can_view_appointments
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_can_view_single_appointment
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_can_cancel_future_appointment
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_cannot_cancel_soon_appointment
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_can_reschedule_appointment
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_can_get_available_slots
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_can_view_results
ERROR tests/integration/test_e2e_patient_flow.py::TestPatientFlow::test_patient_cannot_view_others_appointments
ERROR tests/integration/test_e2e_payment_flow.py::TestPaymentFlow::test_create_payment_for_visit
ERROR tests/integration/test_e2e_payment_flow.py::TestPaymentFlow::test_get_payment_status
ERROR tests/integration/test_e2e_payment_flow.py::TestPaymentFlow::test_payment_receipt_generation
ERROR tests/integration/test_e2e_visit_flow.py::TestE2EVisitFlow::test_complete_visit_flow_today
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_create_single_queue_entry_success
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_create_multiple_queue_entries_different_specialists
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_source_preservation
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_duplicate_detection
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_service_grouping_by_specialist
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_auto_create_daily_queue
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_patient_not_found_error
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_service_not_found_error
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_specialist_not_found_error
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_invalid_source_error
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_admin_access_allowed
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_registrar_access_allowed
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_doctor_access_denied
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_unauthenticated_access_denied
ERROR tests/integration/test_queue_batch_api.py::TestQueueBatchAPI::test_fair_queue_numbering
=========== 55 failed, 179 passed, 88 warnings, 27 errors in 27.34s ===========
